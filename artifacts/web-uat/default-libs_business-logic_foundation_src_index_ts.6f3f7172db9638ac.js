"use strict";
(self["webpackChunkweb"] = self["webpackChunkweb"] || []).push([["default-libs_business-logic_foundation_src_index_ts"],{

/***/ 464929:
/*!*************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/boot/init.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defineGlobal": () => (/* binding */ defineGlobal),
/* harmony export */   "makePublicApi": () => (/* binding */ makePublicApi)
/* harmony export */ });
/* harmony import */ var _tools_catchUserErrors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/catchUserErrors */ 648755);
/* harmony import */ var _tools_monitor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/monitor */ 267830);
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/utils/polyfills */ 777760);



function makePublicApi(stub) {
  var publicApi = (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_0__.assign)({
    version: "4.39.0",
    // This API method is intentionally not monitored, since the only thing executed is the
    // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and
    // we don't want to interfere with the user uncaught exceptions.
    onReady: function (callback) {
      callback();
    }
  }, stub);
  // Add a "hidden" property to set debug mode. We define it that way to hide it
  // as much as possible but of course it's not a real protection.
  Object.defineProperty(publicApi, '_setDebug', {
    get: function () {
      return _tools_monitor__WEBPACK_IMPORTED_MODULE_1__.setDebugMode;
    },
    enumerable: false
  });
  return publicApi;
}
function defineGlobal(global, name, api) {
  var existingGlobalVariable = global[name];
  global[name] = api;
  if (existingGlobalVariable && existingGlobalVariable.q) {
    existingGlobalVariable.q.forEach(function (fn) {
      return (0,_tools_catchUserErrors__WEBPACK_IMPORTED_MODULE_2__.catchUserErrors)(fn, 'onReady callback threw an error:')();
    });
  }
}
//# sourceMappingURL=init.js.map

/***/ }),

/***/ 822006:
/*!****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/browser/addEventListener.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addEventListener": () => (/* binding */ addEventListener),
/* harmony export */   "addEventListeners": () => (/* binding */ addEventListeners)
/* harmony export */ });
/* harmony import */ var _tools_monitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/monitor */ 267830);
/* harmony import */ var _tools_getZoneJsOriginalValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/getZoneJsOriginalValue */ 129107);


/**
 * Add an event listener to an event target object (Window, Element, mock object...).  This provides
 * a few conveniences compared to using `element.addEventListener` directly:
 *
 * * supports IE11 by: using an option object only if needed and emulating the `once` option
 *
 * * wraps the listener with a `monitor` function
 *
 * * returns a `stop` function to remove the listener
 */
function addEventListener(eventTarget, eventName, listener, options) {
  return addEventListeners(eventTarget, [eventName], listener, options);
}
/**
 * Add event listeners to an event target object (Window, Element, mock object...).  This provides
 * a few conveniences compared to using `element.addEventListener` directly:
 *
 * * supports IE11 by: using an option object only if needed and emulating the `once` option
 *
 * * wraps the listener with a `monitor` function
 *
 * * returns a `stop` function to remove the listener
 *
 * * with `once: true`, the listener will be called at most once, even if different events are listened
 */
function addEventListeners(eventTarget, eventNames, listener, _a) {
  var _b = _a === void 0 ? {} : _a,
    once = _b.once,
    capture = _b.capture,
    passive = _b.passive;
  var wrappedListener = (0,_tools_monitor__WEBPACK_IMPORTED_MODULE_0__.monitor)(once ? function (event) {
    stop();
    listener(event);
  } : listener);
  var options = passive ? {
    capture: capture,
    passive: passive
  } : capture;
  var add = (0,_tools_getZoneJsOriginalValue__WEBPACK_IMPORTED_MODULE_1__.getZoneJsOriginalValue)(eventTarget, 'addEventListener');
  eventNames.forEach(function (eventName) {
    return add.call(eventTarget, eventName, wrappedListener, options);
  });
  function stop() {
    var remove = (0,_tools_getZoneJsOriginalValue__WEBPACK_IMPORTED_MODULE_1__.getZoneJsOriginalValue)(eventTarget, 'removeEventListener');
    eventNames.forEach(function (eventName) {
      return remove.call(eventTarget, eventName, wrappedListener, options);
    });
  }
  return {
    stop: stop
  };
}
//# sourceMappingURL=addEventListener.js.map

/***/ }),

/***/ 665627:
/*!******************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/browser/cookie.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "COOKIE_ACCESS_DELAY": () => (/* binding */ COOKIE_ACCESS_DELAY),
/* harmony export */   "areCookiesAuthorized": () => (/* binding */ areCookiesAuthorized),
/* harmony export */   "deleteCookie": () => (/* binding */ deleteCookie),
/* harmony export */   "getCookie": () => (/* binding */ getCookie),
/* harmony export */   "getCurrentSite": () => (/* binding */ getCurrentSite),
/* harmony export */   "setCookie": () => (/* binding */ setCookie)
/* harmony export */ });
/* harmony import */ var _tools_display__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/display */ 700959);
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/utils/timeUtils */ 573647);
/* harmony import */ var _tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/utils/stringUtils */ 347666);



var COOKIE_ACCESS_DELAY = _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_SECOND;
function setCookie(name, value, expireDelay, options) {
  var date = new Date();
  date.setTime(date.getTime() + expireDelay);
  var expires = "expires=".concat(date.toUTCString());
  var sameSite = options && options.crossSite ? 'none' : 'strict';
  var domain = options && options.domain ? ";domain=".concat(options.domain) : '';
  var secure = options && options.secure ? ';secure' : '';
  document.cookie = "".concat(name, "=").concat(value, ";").concat(expires, ";path=/;samesite=").concat(sameSite).concat(domain).concat(secure);
}
function getCookie(name) {
  return (0,_tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_1__.findCommaSeparatedValue)(document.cookie, name);
}
function deleteCookie(name, options) {
  setCookie(name, '', 0, options);
}
function areCookiesAuthorized(options) {
  if (document.cookie === undefined || document.cookie === null) {
    return false;
  }
  try {
    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during
    // the test cookie lifetime
    var testCookieName = "dd_cookie_test_".concat((0,_tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_1__.generateUUID)());
    var testCookieValue = 'test';
    setCookie(testCookieName, testCookieValue, _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_MINUTE, options);
    var isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue;
    deleteCookie(testCookieName, options);
    return isCookieCorrectlySet;
  } catch (error) {
    _tools_display__WEBPACK_IMPORTED_MODULE_2__.display.error(error);
    return false;
  }
}
/**
 * No API to retrieve it, number of levels for subdomain and suffix are unknown
 * strategy: find the minimal domain on which cookies are allowed to be set
 * https://web.dev/same-site-same-origin/#site
 */
var getCurrentSiteCache;
function getCurrentSite() {
  if (getCurrentSiteCache === undefined) {
    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during
    // the test cookie lifetime
    var testCookieName = "dd_site_test_".concat((0,_tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_1__.generateUUID)());
    var testCookieValue = 'test';
    var domainLevels = window.location.hostname.split('.');
    var candidateDomain = domainLevels.pop();
    while (domainLevels.length && !getCookie(testCookieName)) {
      candidateDomain = "".concat(domainLevels.pop(), ".").concat(candidateDomain);
      setCookie(testCookieName, testCookieValue, _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_SECOND, {
        domain: candidateDomain
      });
    }
    deleteCookie(testCookieName, {
      domain: candidateDomain
    });
    getCurrentSiteCache = candidateDomain;
  }
  return getCurrentSiteCache;
}
//# sourceMappingURL=cookie.js.map

/***/ }),

/***/ 847357:
/*!***************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/browser/fetchObservable.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initFetchObservable": () => (/* binding */ initFetchObservable)
/* harmony export */ });
/* harmony import */ var _tools_instrumentMethod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/instrumentMethod */ 101280);
/* harmony import */ var _tools_monitor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/monitor */ 267830);
/* harmony import */ var _tools_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/observable */ 32189);
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/utils/timeUtils */ 573647);
/* harmony import */ var _tools_utils_urlPolyfill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/utils/urlPolyfill */ 77615);





var fetchObservable;
function initFetchObservable() {
  if (!fetchObservable) {
    fetchObservable = createFetchObservable();
  }
  return fetchObservable;
}
function createFetchObservable() {
  var observable = new _tools_observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function () {
    if (!window.fetch) {
      return;
    }
    var stop = (0,_tools_instrumentMethod__WEBPACK_IMPORTED_MODULE_1__.instrumentMethod)(window, 'fetch', function (originalFetch) {
      return function (input, init) {
        var responsePromise;
        var context = (0,_tools_monitor__WEBPACK_IMPORTED_MODULE_2__.callMonitored)(beforeSend, null, [observable, input, init]);
        if (context) {
          responsePromise = originalFetch.call(this, context.input, context.init);
          (0,_tools_monitor__WEBPACK_IMPORTED_MODULE_2__.callMonitored)(afterSend, null, [observable, responsePromise, context]);
        } else {
          responsePromise = originalFetch.call(this, input, init);
        }
        return responsePromise;
      };
    }).stop;
    return stop;
  });
  return observable;
}
function beforeSend(observable, input, init) {
  var method = init && init.method || input instanceof Request && input.method || 'GET';
  var url = input instanceof Request ? input.url : (0,_tools_utils_urlPolyfill__WEBPACK_IMPORTED_MODULE_3__.normalizeUrl)(String(input));
  var startClocks = (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_4__.clocksNow)();
  var context = {
    state: 'start',
    init: init,
    input: input,
    method: method,
    startClocks: startClocks,
    url: url
  };
  observable.notify(context);
  return context;
}
function afterSend(observable, responsePromise, startContext) {
  var reportFetch = function (response) {
    var context = startContext;
    context.state = 'resolve';
    if ('stack' in response || response instanceof Error) {
      context.status = 0;
      context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR;
      context.error = response;
    } else if ('status' in response) {
      context.response = response;
      context.responseType = response.type;
      context.status = response.status;
      context.isAborted = false;
    }
    observable.notify(context);
  };
  responsePromise.then((0,_tools_monitor__WEBPACK_IMPORTED_MODULE_2__.monitor)(reportFetch), (0,_tools_monitor__WEBPACK_IMPORTED_MODULE_2__.monitor)(reportFetch));
}
//# sourceMappingURL=fetchObservable.js.map

/***/ }),

/***/ 37215:
/*!******************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/browser/pageExitObservable.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PageExitReason": () => (/* binding */ PageExitReason),
/* harmony export */   "createPageExitObservable": () => (/* binding */ createPageExitObservable),
/* harmony export */   "isPageExitReason": () => (/* binding */ isPageExitReason)
/* harmony export */ });
/* harmony import */ var _tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/experimentalFeatures */ 393968);
/* harmony import */ var _tools_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/observable */ 32189);
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/utils/polyfills */ 777760);
/* harmony import */ var _tools_utils_functionUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/utils/functionUtils */ 897826);
/* harmony import */ var _addEventListener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addEventListener */ 822006);





var PageExitReason = {
  HIDDEN: 'visibility_hidden',
  UNLOADING: 'before_unload',
  PAGEHIDE: 'page_hide',
  FROZEN: 'page_frozen'
};
function createPageExitObservable() {
  var observable = new _tools_observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function () {
    var pagehideEnabled = (0,_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_1__.isExperimentalFeatureEnabled)(_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_1__.ExperimentalFeature.PAGEHIDE);
    var stopListeners = (0,_addEventListener__WEBPACK_IMPORTED_MODULE_2__.addEventListeners)(window, ["visibilitychange" /* DOM_EVENT.VISIBILITY_CHANGE */, "freeze" /* DOM_EVENT.FREEZE */, "pagehide" /* DOM_EVENT.PAGE_HIDE */], function (event) {
      if (event.type === "pagehide" /* DOM_EVENT.PAGE_HIDE */ && pagehideEnabled) {
        /**
         * Only event that detect page unload events while being compatible with the back/forward cache (bfcache)
         */
        observable.notify({
          reason: PageExitReason.PAGEHIDE
        });
      } else if (event.type === "visibilitychange" /* DOM_EVENT.VISIBILITY_CHANGE */ && document.visibilityState === 'hidden') {
        /**
         * Only event that guarantee to fire on mobile devices when the page transitions to background state
         * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.
         */
        observable.notify({
          reason: PageExitReason.HIDDEN
        });
      } else if (event.type === "freeze" /* DOM_EVENT.FREEZE */) {
        /**
         * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)
         * Allow to collect events happening between hidden and frozen state.
         */
        observable.notify({
          reason: PageExitReason.FROZEN
        });
      }
    }, {
      capture: true
    }).stop;
    var stopBeforeUnloadListener = _tools_utils_functionUtils__WEBPACK_IMPORTED_MODULE_3__.noop;
    if (!pagehideEnabled) {
      stopBeforeUnloadListener = (0,_addEventListener__WEBPACK_IMPORTED_MODULE_2__.addEventListener)(window, "beforeunload" /* DOM_EVENT.BEFORE_UNLOAD */, function () {
        observable.notify({
          reason: PageExitReason.UNLOADING
        });
      }).stop;
    }
    return function () {
      stopListeners();
      stopBeforeUnloadListener();
    };
  });
  return observable;
}
function isPageExitReason(reason) {
  return (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_4__.includes)((0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_4__.objectValues)(PageExitReason), reason);
}
//# sourceMappingURL=pageExitObservable.js.map

/***/ }),

/***/ 656785:
/*!***************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/browser/runOnReadyState.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "runOnReadyState": () => (/* binding */ runOnReadyState)
/* harmony export */ });
/* harmony import */ var _addEventListener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addEventListener */ 822006);

function runOnReadyState(expectedReadyState, callback) {
  if (document.readyState === expectedReadyState || document.readyState === 'complete') {
    callback();
  } else {
    var eventName = expectedReadyState === 'complete' ? "load" /* DOM_EVENT.LOAD */ : "DOMContentLoaded" /* DOM_EVENT.DOM_CONTENT_LOADED */;
    (0,_addEventListener__WEBPACK_IMPORTED_MODULE_0__.addEventListener)(window, eventName, callback, {
      once: true
    });
  }
}
//# sourceMappingURL=runOnReadyState.js.map

/***/ }),

/***/ 995176:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/browser/xhrObservable.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initXhrObservable": () => (/* binding */ initXhrObservable)
/* harmony export */ });
/* harmony import */ var _tools_instrumentMethod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/instrumentMethod */ 101280);
/* harmony import */ var _tools_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/observable */ 32189);
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/utils/timeUtils */ 573647);
/* harmony import */ var _tools_utils_urlPolyfill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/utils/urlPolyfill */ 77615);
/* harmony import */ var _tools_utils_objectUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/utils/objectUtils */ 567934);
/* harmony import */ var _addEventListener__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./addEventListener */ 822006);






var xhrObservable;
var xhrContexts = new WeakMap();
function initXhrObservable() {
  if (!xhrObservable) {
    xhrObservable = createXhrObservable();
  }
  return xhrObservable;
}
function createXhrObservable() {
  var observable = new _tools_observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function () {
    var stopInstrumentingStart = (0,_tools_instrumentMethod__WEBPACK_IMPORTED_MODULE_1__.instrumentMethodAndCallOriginal)(XMLHttpRequest.prototype, 'open', {
      before: openXhr
    }).stop;
    var stopInstrumentingSend = (0,_tools_instrumentMethod__WEBPACK_IMPORTED_MODULE_1__.instrumentMethodAndCallOriginal)(XMLHttpRequest.prototype, 'send', {
      before: function () {
        sendXhr.call(this, observable);
      }
    }).stop;
    var stopInstrumentingAbort = (0,_tools_instrumentMethod__WEBPACK_IMPORTED_MODULE_1__.instrumentMethodAndCallOriginal)(XMLHttpRequest.prototype, 'abort', {
      before: abortXhr
    }).stop;
    return function () {
      stopInstrumentingStart();
      stopInstrumentingSend();
      stopInstrumentingAbort();
    };
  });
  return observable;
}
function openXhr(method, url) {
  xhrContexts.set(this, {
    state: 'open',
    method: method,
    url: (0,_tools_utils_urlPolyfill__WEBPACK_IMPORTED_MODULE_2__.normalizeUrl)(String(url))
  });
}
function sendXhr(observable) {
  var _this = this;
  var context = xhrContexts.get(this);
  if (!context) {
    return;
  }
  var startContext = context;
  startContext.state = 'start';
  startContext.startTime = (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_3__.relativeNow)();
  startContext.startClocks = (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_3__.clocksNow)();
  startContext.isAborted = false;
  startContext.xhr = this;
  var hasBeenReported = false;
  var stopInstrumentingOnReadyStateChange = (0,_tools_instrumentMethod__WEBPACK_IMPORTED_MODULE_1__.instrumentMethodAndCallOriginal)(this, 'onreadystatechange', {
    before: function () {
      if (this.readyState === XMLHttpRequest.DONE) {
        // Try to report the XHR as soon as possible, because the XHR may be mutated by the
        // application during a future event. For example, Angular is calling .abort() on
        // completed requests during a onreadystatechange event, so the status becomes '0'
        // before the request is collected.
        onEnd();
      }
    }
  }).stop;
  var onEnd = function () {
    unsubscribeLoadEndListener();
    stopInstrumentingOnReadyStateChange();
    if (hasBeenReported) {
      return;
    }
    hasBeenReported = true;
    var completeContext = context;
    completeContext.state = 'complete';
    completeContext.duration = (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_3__.elapsed)(startContext.startClocks.timeStamp, (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_3__.timeStampNow)());
    completeContext.status = _this.status;
    observable.notify((0,_tools_utils_objectUtils__WEBPACK_IMPORTED_MODULE_4__.shallowClone)(completeContext));
  };
  var unsubscribeLoadEndListener = (0,_addEventListener__WEBPACK_IMPORTED_MODULE_5__.addEventListener)(this, 'loadend', onEnd).stop;
  observable.notify(startContext);
}
function abortXhr() {
  var context = xhrContexts.get(this);
  if (context) {
    context.isAborted = true;
  }
}
//# sourceMappingURL=xhrObservable.js.map

/***/ }),

/***/ 351540:
/*!**************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/configuration/configuration.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultPrivacyLevel": () => (/* binding */ DefaultPrivacyLevel),
/* harmony export */   "buildCookieOptions": () => (/* binding */ buildCookieOptions),
/* harmony export */   "serializeConfiguration": () => (/* binding */ serializeConfiguration),
/* harmony export */   "validateAndBuildConfiguration": () => (/* binding */ validateAndBuildConfiguration)
/* harmony export */ });
/* harmony import */ var _browser_cookie__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../browser/cookie */ 665627);
/* harmony import */ var _tools_catchUserErrors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tools/catchUserErrors */ 648755);
/* harmony import */ var _tools_display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/display */ 700959);
/* harmony import */ var _tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/experimentalFeatures */ 393968);
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../tools/utils/timeUtils */ 573647);
/* harmony import */ var _tools_utils_numberUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/utils/numberUtils */ 159127);
/* harmony import */ var _tools_utils_byteUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../tools/utils/byteUtils */ 85010);
/* harmony import */ var _tools_utils_objectUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/utils/objectUtils */ 567934);
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/utils/polyfills */ 777760);
/* harmony import */ var _transportConfiguration__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./transportConfiguration */ 704970);










var DefaultPrivacyLevel = {
  ALLOW: 'allow',
  MASK: 'mask',
  MASK_USER_INPUT: 'mask-user-input'
};
function validateAndBuildConfiguration(initConfiguration) {
  var _a, _b, _c;
  if (!initConfiguration || !initConfiguration.clientToken) {
    _tools_display__WEBPACK_IMPORTED_MODULE_0__.display.error('Client Token is not configured, we will not send any data.');
    return;
  }
  var sessionSampleRate = (_a = initConfiguration.sessionSampleRate) !== null && _a !== void 0 ? _a : initConfiguration.sampleRate;
  if (sessionSampleRate !== undefined && !(0,_tools_utils_numberUtils__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(sessionSampleRate)) {
    _tools_display__WEBPACK_IMPORTED_MODULE_0__.display.error('Session Sample Rate should be a number between 0 and 100');
    return;
  }
  if (initConfiguration.telemetrySampleRate !== undefined && !(0,_tools_utils_numberUtils__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(initConfiguration.telemetrySampleRate)) {
    _tools_display__WEBPACK_IMPORTED_MODULE_0__.display.error('Telemetry Sample Rate should be a number between 0 and 100');
    return;
  }
  if (initConfiguration.telemetryConfigurationSampleRate !== undefined && !(0,_tools_utils_numberUtils__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(initConfiguration.telemetryConfigurationSampleRate)) {
    _tools_display__WEBPACK_IMPORTED_MODULE_0__.display.error('Telemetry Configuration Sample Rate should be a number between 0 and 100');
    return;
  }
  // Set the experimental feature flags as early as possible, so we can use them in most places
  if (Array.isArray(initConfiguration.enableExperimentalFeatures)) {
    (0,_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_2__.addExperimentalFeatures)(initConfiguration.enableExperimentalFeatures.filter(function (flag) {
      return (0,_tools_utils_objectUtils__WEBPACK_IMPORTED_MODULE_3__.objectHasValue)(_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_2__.ExperimentalFeature, flag);
    }));
  }
  return (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_4__.assign)({
    beforeSend: initConfiguration.beforeSend && (0,_tools_catchUserErrors__WEBPACK_IMPORTED_MODULE_5__.catchUserErrors)(initConfiguration.beforeSend, 'beforeSend threw an error:'),
    cookieOptions: buildCookieOptions(initConfiguration),
    sessionSampleRate: sessionSampleRate !== null && sessionSampleRate !== void 0 ? sessionSampleRate : 100,
    telemetrySampleRate: (_b = initConfiguration.telemetrySampleRate) !== null && _b !== void 0 ? _b : 20,
    telemetryConfigurationSampleRate: (_c = initConfiguration.telemetryConfigurationSampleRate) !== null && _c !== void 0 ? _c : 5,
    service: initConfiguration.service,
    silentMultipleInit: !!initConfiguration.silentMultipleInit,
    /**
     * beacon payload max queue size implementation is 64kb
     * ensure that we leave room for logs, rum and potential other users
     */
    batchBytesLimit: 16 * _tools_utils_byteUtils__WEBPACK_IMPORTED_MODULE_6__.ONE_KIBI_BYTE,
    eventRateLimiterThreshold: 3000,
    maxTelemetryEventsPerPage: 15,
    /**
     * flush automatically, aim to be lower than ALB connection timeout
     * to maximize connection reuse.
     */
    flushTimeout: 30 * _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_7__.ONE_SECOND,
    /**
     * Logs intake limit
     */
    batchMessagesLimit: 50,
    messageBytesLimit: 256 * _tools_utils_byteUtils__WEBPACK_IMPORTED_MODULE_6__.ONE_KIBI_BYTE
  }, (0,_transportConfiguration__WEBPACK_IMPORTED_MODULE_8__.computeTransportConfiguration)(initConfiguration));
}
function buildCookieOptions(initConfiguration) {
  var cookieOptions = {};
  cookieOptions.secure = mustUseSecureCookie(initConfiguration);
  cookieOptions.crossSite = !!initConfiguration.useCrossSiteSessionCookie;
  if (initConfiguration.trackSessionAcrossSubdomains) {
    cookieOptions.domain = (0,_browser_cookie__WEBPACK_IMPORTED_MODULE_9__.getCurrentSite)();
  }
  return cookieOptions;
}
function mustUseSecureCookie(initConfiguration) {
  return !!initConfiguration.useSecureSessionCookie || !!initConfiguration.useCrossSiteSessionCookie;
}
function serializeConfiguration(configuration) {
  var _a, _b;
  var proxy = (_a = configuration.proxy) !== null && _a !== void 0 ? _a : configuration.proxyUrl;
  return {
    session_sample_rate: (_b = configuration.sessionSampleRate) !== null && _b !== void 0 ? _b : configuration.sampleRate,
    telemetry_sample_rate: configuration.telemetrySampleRate,
    telemetry_configuration_sample_rate: configuration.telemetryConfigurationSampleRate,
    use_before_send: !!configuration.beforeSend,
    use_cross_site_session_cookie: configuration.useCrossSiteSessionCookie,
    use_secure_session_cookie: configuration.useSecureSessionCookie,
    use_proxy: proxy !== undefined ? !!proxy : undefined,
    silent_multiple_init: configuration.silentMultipleInit,
    track_session_across_subdomains: configuration.trackSessionAcrossSubdomains,
    track_resources: configuration.trackResources,
    track_long_task: configuration.trackLongTasks
  };
}
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ 588664:
/*!****************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/configuration/endpointBuilder.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ENDPOINTS": () => (/* binding */ ENDPOINTS),
/* harmony export */   "createEndpointBuilder": () => (/* binding */ createEndpointBuilder)
/* harmony export */ });
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/utils/timeUtils */ 573647);
/* harmony import */ var _tools_utils_urlPolyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/utils/urlPolyfill */ 77615);
/* harmony import */ var _tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/experimentalFeatures */ 393968);
/* harmony import */ var _tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/utils/stringUtils */ 347666);
/* harmony import */ var _intakeSites__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./intakeSites */ 713312);





var ENDPOINTS = {
  logs: 'logs',
  rum: 'rum',
  sessionReplay: 'session-replay'
};
var INTAKE_TRACKS = {
  logs: 'logs',
  rum: 'rum',
  sessionReplay: 'replay'
};
function createEndpointBuilder(initConfiguration, endpointType, configurationTags) {
  var buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, endpointType);
  return {
    build: function (api, flushReason, retry) {
      var parameters = buildEndpointParameters(initConfiguration, endpointType, configurationTags, api, flushReason, retry);
      return buildUrlWithParameters(parameters);
    },
    urlPrefix: buildUrlWithParameters(''),
    endpointType: endpointType
  };
}
/**
 * Create a function used to build a full endpoint url from provided parameters. The goal of this
 * function is to pre-compute some parts of the URL to avoid re-computing everything on every
 * request, as only parameters are changing.
 */
function createEndpointUrlWithParametersBuilder(initConfiguration, endpointType) {
  var path = "/api/v2/".concat(INTAKE_TRACKS[endpointType]);
  var proxy = initConfiguration.proxy,
    proxyUrl = initConfiguration.proxyUrl;
  if (proxy) {
    var normalizedProxyUrl_1 = (0,_tools_utils_urlPolyfill__WEBPACK_IMPORTED_MODULE_0__.normalizeUrl)(proxy);
    return function (parameters) {
      return "".concat(normalizedProxyUrl_1, "?ddforward=").concat(encodeURIComponent("".concat(path, "?").concat(parameters)));
    };
  }
  var host = buildEndpointHost(initConfiguration, endpointType);
  if (proxy === undefined && proxyUrl) {
    // TODO: remove this in a future major.
    var normalizedProxyUrl_2 = (0,_tools_utils_urlPolyfill__WEBPACK_IMPORTED_MODULE_0__.normalizeUrl)(proxyUrl);
    return function (parameters) {
      return "".concat(normalizedProxyUrl_2, "?ddforward=").concat(encodeURIComponent("https://".concat(host).concat(path, "?").concat(parameters)));
    };
  }
  return function (parameters) {
    return "https://".concat(host).concat(path, "?").concat(parameters);
  };
}
function buildEndpointHost(initConfiguration, endpointType) {
  var _a = initConfiguration.site,
    site = _a === void 0 ? _intakeSites__WEBPACK_IMPORTED_MODULE_1__.INTAKE_SITE_US1 : _a,
    internalAnalyticsSubdomain = initConfiguration.internalAnalyticsSubdomain;
  if (internalAnalyticsSubdomain && site === _intakeSites__WEBPACK_IMPORTED_MODULE_1__.INTAKE_SITE_US1) {
    return "".concat(internalAnalyticsSubdomain, ".").concat(_intakeSites__WEBPACK_IMPORTED_MODULE_1__.INTAKE_SITE_US1);
  }
  var domainParts = site.split('.');
  var extension = domainParts.pop();
  var subdomain = site !== _intakeSites__WEBPACK_IMPORTED_MODULE_1__.INTAKE_SITE_AP1 ? "".concat(ENDPOINTS[endpointType], ".") : '';
  return "".concat(subdomain, "browser-intake-").concat(domainParts.join('-'), ".").concat(extension);
}
/**
 * Build parameters to be used for an intake request. Parameters should be re-built for each
 * request, as they change randomly.
 */
function buildEndpointParameters(_a, endpointType, configurationTags, api, flushReason, retry) {
  var clientToken = _a.clientToken,
    internalAnalyticsSubdomain = _a.internalAnalyticsSubdomain;
  var tags = ["sdk_version:".concat("4.39.0"), "api:".concat(api)].concat(configurationTags);
  if (flushReason && (0,_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_2__.isExperimentalFeatureEnabled)(_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_2__.ExperimentalFeature.COLLECT_FLUSH_REASON)) {
    tags.push("flush_reason:".concat(flushReason));
  }
  if (retry) {
    tags.push("retry_count:".concat(retry.count), "retry_after:".concat(retry.lastFailureStatus));
  }
  var parameters = ['ddsource=browser', "ddtags=".concat(encodeURIComponent(tags.join(','))), "dd-api-key=".concat(clientToken), "dd-evp-origin-version=".concat(encodeURIComponent("4.39.0")), 'dd-evp-origin=browser', "dd-request-id=".concat((0,_tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_3__.generateUUID)())];
  if (endpointType === 'rum') {
    parameters.push("batch_time=".concat((0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_4__.timeStampNow)()));
  }
  if (internalAnalyticsSubdomain) {
    parameters.reverse();
  }
  return parameters.join('&');
}
//# sourceMappingURL=endpointBuilder.js.map

/***/ }),

/***/ 713312:
/*!************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/configuration/intakeSites.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "INTAKE_SITE_AP1": () => (/* binding */ INTAKE_SITE_AP1),
/* harmony export */   "INTAKE_SITE_EU1": () => (/* binding */ INTAKE_SITE_EU1),
/* harmony export */   "INTAKE_SITE_STAGING": () => (/* binding */ INTAKE_SITE_STAGING),
/* harmony export */   "INTAKE_SITE_US1": () => (/* binding */ INTAKE_SITE_US1),
/* harmony export */   "INTAKE_SITE_US1_FED": () => (/* binding */ INTAKE_SITE_US1_FED)
/* harmony export */ });
var INTAKE_SITE_STAGING = 'datad0g.com';
var INTAKE_SITE_US1 = 'datadoghq.com';
var INTAKE_SITE_EU1 = 'datadoghq.eu';
var INTAKE_SITE_AP1 = 'ap1.datadoghq.com';
var INTAKE_SITE_US1_FED = 'ddog-gov.com';
//# sourceMappingURL=intakeSites.js.map

/***/ }),

/***/ 620022:
/*!*****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/configuration/tags.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TAG_SIZE_LIMIT": () => (/* binding */ TAG_SIZE_LIMIT),
/* harmony export */   "buildTag": () => (/* binding */ buildTag),
/* harmony export */   "buildTags": () => (/* binding */ buildTags)
/* harmony export */ });
/* harmony import */ var _tools_display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/display */ 700959);

var TAG_SIZE_LIMIT = 200;
function buildTags(configuration) {
  var env = configuration.env,
    service = configuration.service,
    version = configuration.version,
    datacenter = configuration.datacenter;
  var tags = [];
  if (env) {
    tags.push(buildTag('env', env));
  }
  if (service) {
    tags.push(buildTag('service', service));
  }
  if (version) {
    tags.push(buildTag('version', version));
  }
  if (datacenter) {
    tags.push(buildTag('datacenter', datacenter));
  }
  return tags;
}
var FORBIDDEN_CHARACTERS = /[^a-z0-9_:./-]/;
function buildTag(key, rawValue) {
  // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note
  // that the backend may not follow the exact same rules, so we only want to display an informal
  // warning.
  var valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1;
  if (rawValue.length > valueSizeLimit || FORBIDDEN_CHARACTERS.test(rawValue)) {
    _tools_display__WEBPACK_IMPORTED_MODULE_0__.display.warn("".concat(key, " value doesn't meet tag requirements and will be sanitized"));
  }
  // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted
  // by forging a value containing commas.
  var sanitizedValue = rawValue.replace(/,/g, '_');
  return "".concat(key, ":").concat(sanitizedValue);
}
//# sourceMappingURL=tags.js.map

/***/ }),

/***/ 704970:
/*!***********************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/configuration/transportConfiguration.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "computeTransportConfiguration": () => (/* binding */ computeTransportConfiguration)
/* harmony export */ });
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/utils/polyfills */ 777760);
/* harmony import */ var _endpointBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./endpointBuilder */ 588664);
/* harmony import */ var _tags__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tags */ 620022);
/* harmony import */ var _intakeSites__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./intakeSites */ 713312);




function computeTransportConfiguration(initConfiguration) {
  var tags = (0,_tags__WEBPACK_IMPORTED_MODULE_0__.buildTags)(initConfiguration);
  var endpointBuilders = computeEndpointBuilders(initConfiguration, tags);
  var intakeUrlPrefixes = (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_1__.objectValues)(endpointBuilders).map(function (builder) {
    return builder.urlPrefix;
  });
  var replicaConfiguration = computeReplicaConfiguration(initConfiguration, intakeUrlPrefixes, tags);
  return (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_1__.assign)({
    isIntakeUrl: function (url) {
      return intakeUrlPrefixes.some(function (intakeEndpoint) {
        return url.indexOf(intakeEndpoint) === 0;
      });
    },
    replica: replicaConfiguration,
    site: initConfiguration.site || _intakeSites__WEBPACK_IMPORTED_MODULE_2__.INTAKE_SITE_US1
  }, endpointBuilders);
}
function computeEndpointBuilders(initConfiguration, tags) {
  return {
    logsEndpointBuilder: (0,_endpointBuilder__WEBPACK_IMPORTED_MODULE_3__.createEndpointBuilder)(initConfiguration, 'logs', tags),
    rumEndpointBuilder: (0,_endpointBuilder__WEBPACK_IMPORTED_MODULE_3__.createEndpointBuilder)(initConfiguration, 'rum', tags),
    sessionReplayEndpointBuilder: (0,_endpointBuilder__WEBPACK_IMPORTED_MODULE_3__.createEndpointBuilder)(initConfiguration, 'sessionReplay', tags)
  };
}
function computeReplicaConfiguration(initConfiguration, intakeUrlPrefixes, tags) {
  if (!initConfiguration.replica) {
    return;
  }
  var replicaConfiguration = (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_1__.assign)({}, initConfiguration, {
    site: _intakeSites__WEBPACK_IMPORTED_MODULE_2__.INTAKE_SITE_US1,
    clientToken: initConfiguration.replica.clientToken
  });
  var replicaEndpointBuilders = {
    logsEndpointBuilder: (0,_endpointBuilder__WEBPACK_IMPORTED_MODULE_3__.createEndpointBuilder)(replicaConfiguration, 'logs', tags),
    rumEndpointBuilder: (0,_endpointBuilder__WEBPACK_IMPORTED_MODULE_3__.createEndpointBuilder)(replicaConfiguration, 'rum', tags)
  };
  intakeUrlPrefixes.push.apply(intakeUrlPrefixes, (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_1__.objectValues)(replicaEndpointBuilders).map(function (builder) {
    return builder.urlPrefix;
  }));
  return (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_1__.assign)({
    applicationId: initConfiguration.replica.applicationId
  }, replicaEndpointBuilders);
}
//# sourceMappingURL=transportConfiguration.js.map

/***/ }),

/***/ 254074:
/*!************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/console/consoleObservable.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initConsoleObservable": () => (/* binding */ initConsoleObservable)
/* harmony export */ });
/* harmony import */ var _tracekit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tracekit */ 976474);
/* harmony import */ var _error_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../error/error */ 803679);
/* harmony import */ var _tools_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/observable */ 32189);
/* harmony import */ var _tools_display__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/display */ 700959);
/* harmony import */ var _tools_monitor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/monitor */ 267830);
/* harmony import */ var _tools_serialisation_sanitize__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../tools/serialisation/sanitize */ 595530);
/* harmony import */ var _tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../tools/experimentalFeatures */ 393968);
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/utils/polyfills */ 777760);
/* harmony import */ var _tools_serialisation_jsonStringify__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../tools/serialisation/jsonStringify */ 226590);









var consoleObservablesByApi = {};
function initConsoleObservable(apis) {
  var consoleObservables = apis.map(function (api) {
    if (!consoleObservablesByApi[api]) {
      consoleObservablesByApi[api] = createConsoleObservable(api);
    }
    return consoleObservablesByApi[api];
  });
  return _tools_observable__WEBPACK_IMPORTED_MODULE_0__.mergeObservables.apply(void 0, consoleObservables);
}
/* eslint-disable no-console */
function createConsoleObservable(api) {
  var observable = new _tools_observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function () {
    var originalConsoleApi = console[api];
    console[api] = function () {
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      originalConsoleApi.apply(console, params);
      var handlingStack = (0,_error_error__WEBPACK_IMPORTED_MODULE_1__.createHandlingStack)();
      (0,_tools_monitor__WEBPACK_IMPORTED_MODULE_2__.callMonitored)(function () {
        observable.notify(buildConsoleLog(params, api, handlingStack));
      });
    };
    return function () {
      console[api] = originalConsoleApi;
    };
  });
  return observable;
}
function buildConsoleLog(params, api, handlingStack) {
  // Todo: remove console error prefix in the next major version
  var message = params.map(function (param) {
    return formatConsoleParameters(param);
  }).join(' ');
  var stack;
  if (api === _tools_display__WEBPACK_IMPORTED_MODULE_3__.ConsoleApiName.error) {
    var firstErrorParam = (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_4__.find)(params, function (param) {
      return param instanceof Error;
    });
    stack = firstErrorParam ? (0,_error_error__WEBPACK_IMPORTED_MODULE_1__.toStackTraceString)((0,_tracekit__WEBPACK_IMPORTED_MODULE_5__.computeStackTrace)(firstErrorParam)) : undefined;
    message = "console error: ".concat(message);
  }
  return {
    api: api,
    message: message,
    stack: stack,
    handlingStack: handlingStack
  };
}
function formatConsoleParameters(param) {
  if (typeof param === 'string') {
    return (0,_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_6__.isExperimentalFeatureEnabled)(_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_6__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_tools_serialisation_sanitize__WEBPACK_IMPORTED_MODULE_7__.sanitize)(param) : param;
  }
  if (param instanceof Error) {
    return (0,_error_error__WEBPACK_IMPORTED_MODULE_1__.formatErrorMessage)((0,_tracekit__WEBPACK_IMPORTED_MODULE_5__.computeStackTrace)(param));
  }
  return (0,_tools_serialisation_jsonStringify__WEBPACK_IMPORTED_MODULE_8__.jsonStringify)((0,_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_6__.isExperimentalFeatureEnabled)(_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_6__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_tools_serialisation_sanitize__WEBPACK_IMPORTED_MODULE_7__.sanitize)(param) : param, undefined, 2);
}
//# sourceMappingURL=consoleObservable.js.map

/***/ }),

/***/ 803679:
/*!**********************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/error/error.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorSource": () => (/* binding */ ErrorSource),
/* harmony export */   "NO_ERROR_STACK_PRESENT_MESSAGE": () => (/* binding */ NO_ERROR_STACK_PRESENT_MESSAGE),
/* harmony export */   "PROVIDED_ERROR_MESSAGE_PREFIX": () => (/* binding */ PROVIDED_ERROR_MESSAGE_PREFIX),
/* harmony export */   "computeRawError": () => (/* binding */ computeRawError),
/* harmony export */   "createHandlingStack": () => (/* binding */ createHandlingStack),
/* harmony export */   "flattenErrorCauses": () => (/* binding */ flattenErrorCauses),
/* harmony export */   "formatErrorMessage": () => (/* binding */ formatErrorMessage),
/* harmony export */   "getFileFromStackTraceString": () => (/* binding */ getFileFromStackTraceString),
/* harmony export */   "toStackTraceString": () => (/* binding */ toStackTraceString)
/* harmony export */ });
/* harmony import */ var _tracekit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tracekit */ 976474);
/* harmony import */ var _tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/experimentalFeatures */ 393968);
/* harmony import */ var _tools_monitor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/monitor */ 267830);
/* harmony import */ var _tools_serialisation_sanitize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/serialisation/sanitize */ 595530);
/* harmony import */ var _tools_utils_functionUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/utils/functionUtils */ 897826);
/* harmony import */ var _tools_serialisation_jsonStringify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/serialisation/jsonStringify */ 226590);






var NO_ERROR_STACK_PRESENT_MESSAGE = 'No stack, consider using an instance of Error';
var PROVIDED_ERROR_MESSAGE_PREFIX = 'Provided';
var ErrorSource = {
  AGENT: 'agent',
  CONSOLE: 'console',
  CUSTOM: 'custom',
  LOGGER: 'logger',
  NETWORK: 'network',
  SOURCE: 'source',
  REPORT: 'report'
};
function computeRawError(_a) {
  var stackTrace = _a.stackTrace,
    originalError = _a.originalError,
    handlingStack = _a.handlingStack,
    startClocks = _a.startClocks,
    nonErrorPrefix = _a.nonErrorPrefix,
    source = _a.source,
    handling = _a.handling;
  if (!stackTrace || stackTrace.message === undefined && !(originalError instanceof Error)) {
    var sanitizedError = (0,_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_0__.isExperimentalFeatureEnabled)(_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_0__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_tools_serialisation_sanitize__WEBPACK_IMPORTED_MODULE_1__.sanitize)(originalError) : originalError;
    return {
      startClocks: startClocks,
      source: source,
      handling: handling,
      originalError: sanitizedError,
      message: "".concat(nonErrorPrefix, " ").concat((0,_tools_serialisation_jsonStringify__WEBPACK_IMPORTED_MODULE_2__.jsonStringify)(sanitizedError)),
      stack: 'No stack, consider using an instance of Error',
      handlingStack: handlingStack,
      type: stackTrace && stackTrace.name
    };
  }
  return {
    startClocks: startClocks,
    source: source,
    handling: handling,
    originalError: originalError,
    message: stackTrace.message || 'Empty message',
    stack: toStackTraceString(stackTrace),
    handlingStack: handlingStack,
    type: stackTrace.name,
    causes: flattenErrorCauses(originalError, source)
  };
}
function toStackTraceString(stack) {
  var result = formatErrorMessage(stack);
  stack.stack.forEach(function (frame) {
    var func = frame.func === '?' ? '<anonymous>' : frame.func;
    var args = frame.args && frame.args.length > 0 ? "(".concat(frame.args.join(', '), ")") : '';
    var line = frame.line ? ":".concat(frame.line) : '';
    var column = frame.line && frame.column ? ":".concat(frame.column) : '';
    result += "\n  at ".concat(func).concat(args, " @ ").concat(frame.url).concat(line).concat(column);
  });
  return result;
}
function getFileFromStackTraceString(stack) {
  var _a;
  return (_a = /@ (.+)/.exec(stack)) === null || _a === void 0 ? void 0 : _a[1];
}
function formatErrorMessage(stack) {
  return "".concat(stack.name || 'Error', ": ").concat(stack.message);
}
/**
 Creates a stacktrace without SDK internal frames.
 
 Constraints:
 - Has to be called at the utmost position of the call stack.
 - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.
 */
function createHandlingStack() {
  /**
   * Skip the two internal frames:
   * - SDK API (console.error, ...)
   * - this function
   * in order to keep only the user calls
   */
  var internalFramesToSkip = 2;
  var error = new Error();
  var formattedStack;
  // IE needs to throw the error to fill in the stack trace
  if (!error.stack) {
    try {
      throw error;
    } catch (e) {
      (0,_tools_utils_functionUtils__WEBPACK_IMPORTED_MODULE_3__.noop)();
    }
  }
  (0,_tools_monitor__WEBPACK_IMPORTED_MODULE_4__.callMonitored)(function () {
    var stackTrace = (0,_tracekit__WEBPACK_IMPORTED_MODULE_5__.computeStackTrace)(error);
    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip);
    formattedStack = toStackTraceString(stackTrace);
  });
  return formattedStack;
}
function flattenErrorCauses(error, parentSource) {
  var currentError = error;
  var causes = [];
  while ((currentError === null || currentError === void 0 ? void 0 : currentError.cause) instanceof Error && causes.length < 10) {
    var stackTrace = (0,_tracekit__WEBPACK_IMPORTED_MODULE_5__.computeStackTrace)(currentError.cause);
    causes.push({
      message: currentError.cause.message,
      source: parentSource,
      type: stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name,
      stack: stackTrace && toStackTraceString(stackTrace)
    });
    currentError = currentError.cause;
  }
  return causes.length ? causes : undefined;
}
//# sourceMappingURL=error.js.map

/***/ }),

/***/ 210349:
/*!**********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/error/trackRuntimeError.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trackRuntimeError": () => (/* binding */ trackRuntimeError)
/* harmony export */ });
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/utils/timeUtils */ 573647);
/* harmony import */ var _tracekit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tracekit */ 355919);
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error */ 803679);



function trackRuntimeError(errorObservable) {
  return (0,_tracekit__WEBPACK_IMPORTED_MODULE_0__.startUnhandledErrorCollection)(function (stackTrace, originalError) {
    errorObservable.notify((0,_error__WEBPACK_IMPORTED_MODULE_1__.computeRawError)({
      stackTrace: stackTrace,
      originalError: originalError,
      startClocks: (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_2__.clocksNow)(),
      nonErrorPrefix: 'Uncaught',
      source: _error__WEBPACK_IMPORTED_MODULE_1__.ErrorSource.SOURCE,
      handling: "unhandled" /* ErrorHandling.UNHANDLED */
    }));
  });
}
//# sourceMappingURL=trackRuntimeError.js.map

/***/ }),

/***/ 853556:
/*!**************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/eventRateLimiter/createEventRateLimiter.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createEventRateLimiter": () => (/* binding */ createEventRateLimiter)
/* harmony export */ });
/* harmony import */ var _tools_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/timer */ 631128);
/* harmony import */ var _error_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../error/error */ 803679);
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/utils/timeUtils */ 573647);



function createEventRateLimiter(eventType, limit, onLimitReached) {
  var eventCount = 0;
  var allowNextEvent = false;
  return {
    isLimitReached: function () {
      if (eventCount === 0) {
        (0,_tools_timer__WEBPACK_IMPORTED_MODULE_0__.setTimeout)(function () {
          eventCount = 0;
        }, _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_1__.ONE_MINUTE);
      }
      eventCount += 1;
      if (eventCount <= limit || allowNextEvent) {
        allowNextEvent = false;
        return false;
      }
      if (eventCount === limit + 1) {
        allowNextEvent = true;
        try {
          onLimitReached({
            message: "Reached max number of ".concat(eventType, "s by minute: ").concat(limit),
            source: _error_error__WEBPACK_IMPORTED_MODULE_2__.ErrorSource.AGENT,
            startClocks: (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_1__.clocksNow)()
          });
        } finally {
          allowNextEvent = false;
        }
      }
      return true;
    }
  };
}
//# sourceMappingURL=createEventRateLimiter.js.map

/***/ }),

/***/ 888851:
/*!**********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/report/reportObservable.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RawReportType": () => (/* binding */ RawReportType),
/* harmony export */   "initReportObservable": () => (/* binding */ initReportObservable)
/* harmony export */ });
/* harmony import */ var _error_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../error/error */ 803679);
/* harmony import */ var _tools_monitor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/monitor */ 267830);
/* harmony import */ var _tools_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/observable */ 32189);
/* harmony import */ var _browser_addEventListener__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../browser/addEventListener */ 822006);
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/utils/polyfills */ 777760);
/* harmony import */ var _tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/utils/stringUtils */ 347666);






var RawReportType = {
  intervention: 'intervention',
  deprecation: 'deprecation',
  cspViolation: 'csp_violation'
};
function initReportObservable(apis) {
  var observables = [];
  if ((0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_0__.includes)(apis, RawReportType.cspViolation)) {
    observables.push(createCspViolationReportObservable());
  }
  var reportTypes = apis.filter(function (api) {
    return api !== RawReportType.cspViolation;
  });
  if (reportTypes.length) {
    observables.push(createReportObservable(reportTypes));
  }
  return _tools_observable__WEBPACK_IMPORTED_MODULE_1__.mergeObservables.apply(void 0, observables);
}
function createReportObservable(reportTypes) {
  var observable = new _tools_observable__WEBPACK_IMPORTED_MODULE_1__.Observable(function () {
    if (!window.ReportingObserver) {
      return;
    }
    var handleReports = (0,_tools_monitor__WEBPACK_IMPORTED_MODULE_2__.monitor)(function (reports) {
      return reports.forEach(function (report) {
        observable.notify(buildRawReportFromReport(report));
      });
    });
    var observer = new window.ReportingObserver(handleReports, {
      types: reportTypes,
      buffered: true
    });
    observer.observe();
    return function () {
      observer.disconnect();
    };
  });
  return observable;
}
function createCspViolationReportObservable() {
  var observable = new _tools_observable__WEBPACK_IMPORTED_MODULE_1__.Observable(function () {
    var stop = (0,_browser_addEventListener__WEBPACK_IMPORTED_MODULE_3__.addEventListener)(document, "securitypolicyviolation" /* DOM_EVENT.SECURITY_POLICY_VIOLATION */, function (event) {
      observable.notify(buildRawReportFromCspViolation(event));
    }).stop;
    return stop;
  });
  return observable;
}
function buildRawReportFromReport(_a) {
  var type = _a.type,
    body = _a.body;
  return {
    type: type,
    subtype: body.id,
    message: "".concat(type, ": ").concat(body.message),
    stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber)
  };
}
function buildRawReportFromCspViolation(event) {
  var type = RawReportType.cspViolation;
  var message = "'".concat(event.blockedURI, "' blocked by '").concat(event.effectiveDirective, "' directive");
  return {
    type: RawReportType.cspViolation,
    subtype: event.effectiveDirective,
    message: "".concat(type, ": ").concat(message),
    stack: buildStack(event.effectiveDirective, event.originalPolicy ? "".concat(message, " of the policy \"").concat((0,_tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_4__.safeTruncate)(event.originalPolicy, 100, '...'), "\"") : 'no policy', event.sourceFile, event.lineNumber, event.columnNumber)
  };
}
function buildStack(name, message, sourceFile, lineNumber, columnNumber) {
  return sourceFile && (0,_error_error__WEBPACK_IMPORTED_MODULE_5__.toStackTraceString)({
    name: name,
    message: message,
    stack: [{
      func: '?',
      url: sourceFile,
      line: lineNumber,
      column: columnNumber
    }]
  });
}
//# sourceMappingURL=reportObservable.js.map

/***/ }),

/***/ 211721:
/*!**************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/session/oldCookiesMigration.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LOGS_SESSION_KEY": () => (/* binding */ LOGS_SESSION_KEY),
/* harmony export */   "OLD_LOGS_COOKIE_NAME": () => (/* binding */ OLD_LOGS_COOKIE_NAME),
/* harmony export */   "OLD_RUM_COOKIE_NAME": () => (/* binding */ OLD_RUM_COOKIE_NAME),
/* harmony export */   "OLD_SESSION_COOKIE_NAME": () => (/* binding */ OLD_SESSION_COOKIE_NAME),
/* harmony export */   "RUM_SESSION_KEY": () => (/* binding */ RUM_SESSION_KEY),
/* harmony export */   "tryOldCookiesMigration": () => (/* binding */ tryOldCookiesMigration)
/* harmony export */ });
/* harmony import */ var _browser_cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../browser/cookie */ 665627);
/* harmony import */ var _sessionCookieStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sessionCookieStore */ 833623);


var OLD_SESSION_COOKIE_NAME = '_dd';
var OLD_RUM_COOKIE_NAME = '_dd_r';
var OLD_LOGS_COOKIE_NAME = '_dd_l';
// duplicate values to avoid dependency issues
var RUM_SESSION_KEY = 'rum';
var LOGS_SESSION_KEY = 'logs';
/**
 * This migration should remain in the codebase as long as older versions are available/live
 * to allow older sdk versions to be upgraded to newer versions without compatibility issues.
 */
function tryOldCookiesMigration(options) {
  var sessionString = (0,_browser_cookie__WEBPACK_IMPORTED_MODULE_0__.getCookie)(_sessionCookieStore__WEBPACK_IMPORTED_MODULE_1__.SESSION_COOKIE_NAME);
  var oldSessionId = (0,_browser_cookie__WEBPACK_IMPORTED_MODULE_0__.getCookie)(OLD_SESSION_COOKIE_NAME);
  var oldRumType = (0,_browser_cookie__WEBPACK_IMPORTED_MODULE_0__.getCookie)(OLD_RUM_COOKIE_NAME);
  var oldLogsType = (0,_browser_cookie__WEBPACK_IMPORTED_MODULE_0__.getCookie)(OLD_LOGS_COOKIE_NAME);
  if (!sessionString) {
    var session = {};
    if (oldSessionId) {
      session.id = oldSessionId;
    }
    if (oldLogsType && /^[01]$/.test(oldLogsType)) {
      session[LOGS_SESSION_KEY] = oldLogsType;
    }
    if (oldRumType && /^[012]$/.test(oldRumType)) {
      session[RUM_SESSION_KEY] = oldRumType;
    }
    (0,_sessionCookieStore__WEBPACK_IMPORTED_MODULE_1__.persistSessionCookie)(session, options);
  }
}
//# sourceMappingURL=oldCookiesMigration.js.map

/***/ }),

/***/ 212127:
/*!***********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/session/sessionConstants.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SESSION_EXPIRATION_DELAY": () => (/* binding */ SESSION_EXPIRATION_DELAY),
/* harmony export */   "SESSION_TIME_OUT_DELAY": () => (/* binding */ SESSION_TIME_OUT_DELAY)
/* harmony export */ });
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/utils/timeUtils */ 573647);

var SESSION_TIME_OUT_DELAY = 4 * _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_HOUR;
var SESSION_EXPIRATION_DELAY = 15 * _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_MINUTE;
//# sourceMappingURL=sessionConstants.js.map

/***/ }),

/***/ 833623:
/*!*************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/session/sessionCookieStore.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LOCK_RETRY_DELAY": () => (/* binding */ LOCK_RETRY_DELAY),
/* harmony export */   "MAX_NUMBER_OF_LOCK_RETRIES": () => (/* binding */ MAX_NUMBER_OF_LOCK_RETRIES),
/* harmony export */   "SESSION_COOKIE_NAME": () => (/* binding */ SESSION_COOKIE_NAME),
/* harmony export */   "deleteSessionCookie": () => (/* binding */ deleteSessionCookie),
/* harmony export */   "persistSessionCookie": () => (/* binding */ persistSessionCookie),
/* harmony export */   "retrieveSessionCookie": () => (/* binding */ retrieveSessionCookie),
/* harmony export */   "toSessionString": () => (/* binding */ toSessionString),
/* harmony export */   "withCookieLockAccess": () => (/* binding */ withCookieLockAccess)
/* harmony export */ });
/* harmony import */ var _browser_cookie__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../browser/cookie */ 665627);
/* harmony import */ var _tools_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/timer */ 631128);
/* harmony import */ var _tools_utils_browserDetection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/utils/browserDetection */ 64637);
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/utils/timeUtils */ 573647);
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../tools/utils/polyfills */ 777760);
/* harmony import */ var _tools_utils_objectUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../tools/utils/objectUtils */ 567934);
/* harmony import */ var _tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/utils/stringUtils */ 347666);
/* harmony import */ var _sessionConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sessionConstants */ 212127);








var SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/;
var SESSION_ENTRY_SEPARATOR = '&';
var SESSION_COOKIE_NAME = '_dd_s';
// arbitrary values
var LOCK_RETRY_DELAY = 10;
var MAX_NUMBER_OF_LOCK_RETRIES = 100;
var bufferedOperations = [];
var ongoingOperations;
function withCookieLockAccess(operations, numberOfRetries) {
  var _a;
  if (numberOfRetries === void 0) {
    numberOfRetries = 0;
  }
  if (!ongoingOperations) {
    ongoingOperations = operations;
  }
  if (operations !== ongoingOperations) {
    bufferedOperations.push(operations);
    return;
  }
  if (numberOfRetries >= MAX_NUMBER_OF_LOCK_RETRIES) {
    next();
    return;
  }
  var currentLock;
  var currentSession = retrieveSessionCookie();
  if (isCookieLockEnabled()) {
    // if someone has lock, retry later
    if (currentSession.lock) {
      retryLater(operations, numberOfRetries);
      return;
    }
    // acquire lock
    currentLock = (0,_tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_0__.generateUUID)();
    currentSession.lock = currentLock;
    setSessionCookie(currentSession, operations.options);
    // if lock is not acquired, retry later
    currentSession = retrieveSessionCookie();
    if (currentSession.lock !== currentLock) {
      retryLater(operations, numberOfRetries);
      return;
    }
  }
  var processedSession = operations.process(currentSession);
  if (isCookieLockEnabled()) {
    // if lock corrupted after process, retry later
    currentSession = retrieveSessionCookie();
    if (currentSession.lock !== currentLock) {
      retryLater(operations, numberOfRetries);
      return;
    }
  }
  if (processedSession) {
    persistSessionCookie(processedSession, operations.options);
  }
  if (isCookieLockEnabled()) {
    // correctly handle lock around expiration would require to handle this case properly at several levels
    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it
    if (!(processedSession && isExpiredState(processedSession))) {
      // if lock corrupted after persist, retry later
      currentSession = retrieveSessionCookie();
      if (currentSession.lock !== currentLock) {
        retryLater(operations, numberOfRetries);
        return;
      }
      delete currentSession.lock;
      setSessionCookie(currentSession, operations.options);
      processedSession = currentSession;
    }
  }
  // call after even if session is not persisted in order to perform operations on
  // up-to-date cookie value, the value could have been modified by another tab
  (_a = operations.after) === null || _a === void 0 ? void 0 : _a.call(operations, processedSession || currentSession);
  next();
}
/**
 * Cookie lock strategy allows mitigating issues due to concurrent access to cookie.
 * This issue concerns only chromium browsers and enabling this on firefox increase cookie write failures.
 */
function isCookieLockEnabled() {
  return (0,_tools_utils_browserDetection__WEBPACK_IMPORTED_MODULE_1__.isChromium)();
}
function retryLater(operations, currentNumberOfRetries) {
  (0,_tools_timer__WEBPACK_IMPORTED_MODULE_2__.setTimeout)(function () {
    withCookieLockAccess(operations, currentNumberOfRetries + 1);
  }, LOCK_RETRY_DELAY);
}
function next() {
  ongoingOperations = undefined;
  var nextOperations = bufferedOperations.shift();
  if (nextOperations) {
    withCookieLockAccess(nextOperations);
  }
}
function persistSessionCookie(session, options) {
  if (isExpiredState(session)) {
    deleteSessionCookie(options);
    return;
  }
  session.expire = String((0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_3__.dateNow)() + _sessionConstants__WEBPACK_IMPORTED_MODULE_4__.SESSION_EXPIRATION_DELAY);
  setSessionCookie(session, options);
}
function setSessionCookie(session, options) {
  (0,_browser_cookie__WEBPACK_IMPORTED_MODULE_5__.setCookie)(SESSION_COOKIE_NAME, toSessionString(session), _sessionConstants__WEBPACK_IMPORTED_MODULE_4__.SESSION_EXPIRATION_DELAY, options);
}
function toSessionString(session) {
  return (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_6__.objectEntries)(session).map(function (_a) {
    var key = _a[0],
      value = _a[1];
    return "".concat(key, "=").concat(value);
  }).join(SESSION_ENTRY_SEPARATOR);
}
function retrieveSessionCookie() {
  var sessionString = (0,_browser_cookie__WEBPACK_IMPORTED_MODULE_5__.getCookie)(SESSION_COOKIE_NAME);
  var session = {};
  if (isValidSessionString(sessionString)) {
    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach(function (entry) {
      var matches = SESSION_ENTRY_REGEXP.exec(entry);
      if (matches !== null) {
        var key = matches[1],
          value = matches[2];
        session[key] = value;
      }
    });
  }
  return session;
}
function deleteSessionCookie(options) {
  (0,_browser_cookie__WEBPACK_IMPORTED_MODULE_5__.deleteCookie)(SESSION_COOKIE_NAME, options);
}
function isValidSessionString(sessionString) {
  return sessionString !== undefined && (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString));
}
function isExpiredState(session) {
  return (0,_tools_utils_objectUtils__WEBPACK_IMPORTED_MODULE_7__.isEmptyObject)(session);
}
//# sourceMappingURL=sessionCookieStore.js.map

/***/ }),

/***/ 313031:
/*!*********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/session/sessionManager.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VISIBILITY_CHECK_DELAY": () => (/* binding */ VISIBILITY_CHECK_DELAY),
/* harmony export */   "startSessionManager": () => (/* binding */ startSessionManager),
/* harmony export */   "stopSessionManager": () => (/* binding */ stopSessionManager)
/* harmony export */ });
/* harmony import */ var _tools_valueHistory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/valueHistory */ 712530);
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/utils/timeUtils */ 573647);
/* harmony import */ var _browser_addEventListener__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../browser/addEventListener */ 822006);
/* harmony import */ var _tools_timer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../tools/timer */ 631128);
/* harmony import */ var _oldCookiesMigration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./oldCookiesMigration */ 211721);
/* harmony import */ var _sessionStore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sessionStore */ 377067);
/* harmony import */ var _sessionConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sessionConstants */ 212127);







var VISIBILITY_CHECK_DELAY = _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_MINUTE;
var SESSION_CONTEXT_TIMEOUT_DELAY = _sessionConstants__WEBPACK_IMPORTED_MODULE_1__.SESSION_TIME_OUT_DELAY;
var stopCallbacks = [];
function startSessionManager(options, productKey, computeSessionState) {
  (0,_oldCookiesMigration__WEBPACK_IMPORTED_MODULE_2__.tryOldCookiesMigration)(options);
  var sessionStore = (0,_sessionStore__WEBPACK_IMPORTED_MODULE_3__.startSessionStore)(options, productKey, computeSessionState);
  stopCallbacks.push(function () {
    return sessionStore.stop();
  });
  var sessionContextHistory = new _tools_valueHistory__WEBPACK_IMPORTED_MODULE_4__.ValueHistory(SESSION_CONTEXT_TIMEOUT_DELAY);
  stopCallbacks.push(function () {
    return sessionContextHistory.stop();
  });
  sessionStore.renewObservable.subscribe(function () {
    sessionContextHistory.add(buildSessionContext(), (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__.relativeNow)());
  });
  sessionStore.expireObservable.subscribe(function () {
    sessionContextHistory.closeActive((0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__.relativeNow)());
  });
  sessionStore.expandOrRenewSession();
  sessionContextHistory.add(buildSessionContext(), (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__.clocksOrigin)().relative);
  trackActivity(function () {
    return sessionStore.expandOrRenewSession();
  });
  trackVisibility(function () {
    return sessionStore.expandSession();
  });
  function buildSessionContext() {
    return {
      id: sessionStore.getSession().id,
      trackingType: sessionStore.getSession()[productKey]
    };
  }
  return {
    findActiveSession: function (startTime) {
      return sessionContextHistory.find(startTime);
    },
    renewObservable: sessionStore.renewObservable,
    expireObservable: sessionStore.expireObservable,
    expire: sessionStore.expire
  };
}
function stopSessionManager() {
  stopCallbacks.forEach(function (e) {
    return e();
  });
  stopCallbacks = [];
}
function trackActivity(expandOrRenewSession) {
  var stop = (0,_browser_addEventListener__WEBPACK_IMPORTED_MODULE_5__.addEventListeners)(window, ["click" /* DOM_EVENT.CLICK */, "touchstart" /* DOM_EVENT.TOUCH_START */, "keydown" /* DOM_EVENT.KEY_DOWN */, "scroll" /* DOM_EVENT.SCROLL */], expandOrRenewSession, {
    capture: true,
    passive: true
  }).stop;
  stopCallbacks.push(stop);
}
function trackVisibility(expandSession) {
  var expandSessionWhenVisible = function () {
    if (document.visibilityState === 'visible') {
      expandSession();
    }
  };
  var stop = (0,_browser_addEventListener__WEBPACK_IMPORTED_MODULE_5__.addEventListener)(document, "visibilitychange" /* DOM_EVENT.VISIBILITY_CHANGE */, expandSessionWhenVisible).stop;
  stopCallbacks.push(stop);
  var visibilityCheckInterval = (0,_tools_timer__WEBPACK_IMPORTED_MODULE_6__.setInterval)(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY);
  stopCallbacks.push(function () {
    (0,_tools_timer__WEBPACK_IMPORTED_MODULE_6__.clearInterval)(visibilityCheckInterval);
  });
}
//# sourceMappingURL=sessionManager.js.map

/***/ }),

/***/ 377067:
/*!*******************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/session/sessionStore.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startSessionStore": () => (/* binding */ startSessionStore)
/* harmony export */ });
/* harmony import */ var _browser_cookie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../browser/cookie */ 665627);
/* harmony import */ var _tools_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/timer */ 631128);
/* harmony import */ var _tools_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/observable */ 32189);
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tools/utils/timeUtils */ 573647);
/* harmony import */ var _tools_utils_functionUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../tools/utils/functionUtils */ 897826);
/* harmony import */ var _tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/utils/stringUtils */ 347666);
/* harmony import */ var _sessionConstants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sessionConstants */ 212127);
/* harmony import */ var _sessionCookieStore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sessionCookieStore */ 833623);








/**
 * Different session concepts:
 * - tracked, the session has an id and is updated along the user navigation
 * - not tracked, the session does not have an id but it is updated along the user navigation
 * - inactive, no session in store or session expired, waiting for a renew session
 */
function startSessionStore(options, productKey, computeSessionState) {
  var renewObservable = new _tools_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
  var expireObservable = new _tools_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
  var watchSessionTimeoutId = (0,_tools_timer__WEBPACK_IMPORTED_MODULE_1__.setInterval)(watchSession, _browser_cookie__WEBPACK_IMPORTED_MODULE_2__.COOKIE_ACCESS_DELAY);
  var sessionCache = retrieveActiveSession();
  function expandOrRenewSession() {
    var isTracked;
    (0,_sessionCookieStore__WEBPACK_IMPORTED_MODULE_3__.withCookieLockAccess)({
      options: options,
      process: function (cookieSession) {
        var synchronizedSession = synchronizeSession(cookieSession);
        isTracked = expandOrRenewCookie(synchronizedSession);
        return synchronizedSession;
      },
      after: function (cookieSession) {
        if (isTracked && !hasSessionInCache()) {
          renewSessionInCache(cookieSession);
        }
        sessionCache = cookieSession;
      }
    });
  }
  function expandSession() {
    (0,_sessionCookieStore__WEBPACK_IMPORTED_MODULE_3__.withCookieLockAccess)({
      options: options,
      process: function (cookieSession) {
        return hasSessionInCache() ? synchronizeSession(cookieSession) : undefined;
      }
    });
  }
  /**
   * allows two behaviors:
   * - if the session is active, synchronize the session cache without updating the session cookie
   * - if the session is not active, clear the session cookie and expire the session cache
   */
  function watchSession() {
    (0,_sessionCookieStore__WEBPACK_IMPORTED_MODULE_3__.withCookieLockAccess)({
      options: options,
      process: function (cookieSession) {
        return !isActiveSession(cookieSession) ? {} : undefined;
      },
      after: synchronizeSession
    });
  }
  function synchronizeSession(cookieSession) {
    if (!isActiveSession(cookieSession)) {
      cookieSession = {};
    }
    if (hasSessionInCache()) {
      if (isSessionInCacheOutdated(cookieSession)) {
        expireSessionInCache();
      } else {
        sessionCache = cookieSession;
      }
    }
    return cookieSession;
  }
  function expandOrRenewCookie(cookieSession) {
    var _a = computeSessionState(cookieSession[productKey]),
      trackingType = _a.trackingType,
      isTracked = _a.isTracked;
    cookieSession[productKey] = trackingType;
    if (isTracked && !cookieSession.id) {
      cookieSession.id = (0,_tools_utils_stringUtils__WEBPACK_IMPORTED_MODULE_4__.generateUUID)();
      cookieSession.created = String((0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_5__.dateNow)());
    }
    return isTracked;
  }
  function hasSessionInCache() {
    return sessionCache[productKey] !== undefined;
  }
  function isSessionInCacheOutdated(cookieSession) {
    return sessionCache.id !== cookieSession.id || sessionCache[productKey] !== cookieSession[productKey];
  }
  function expireSessionInCache() {
    sessionCache = {};
    expireObservable.notify();
  }
  function renewSessionInCache(cookieSession) {
    sessionCache = cookieSession;
    renewObservable.notify();
  }
  function retrieveActiveSession() {
    var session = (0,_sessionCookieStore__WEBPACK_IMPORTED_MODULE_3__.retrieveSessionCookie)();
    if (isActiveSession(session)) {
      return session;
    }
    return {};
  }
  function isActiveSession(session) {
    // created and expire can be undefined for versions which was not storing them
    // these checks could be removed when older versions will not be available/live anymore
    return (session.created === undefined || (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_5__.dateNow)() - Number(session.created) < _sessionConstants__WEBPACK_IMPORTED_MODULE_6__.SESSION_TIME_OUT_DELAY) && (session.expire === undefined || (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_5__.dateNow)() < Number(session.expire));
  }
  return {
    expandOrRenewSession: (0,_tools_utils_functionUtils__WEBPACK_IMPORTED_MODULE_7__.throttle)(expandOrRenewSession, _browser_cookie__WEBPACK_IMPORTED_MODULE_2__.COOKIE_ACCESS_DELAY).throttled,
    expandSession: expandSession,
    getSession: function () {
      return sessionCache;
    },
    renewObservable: renewObservable,
    expireObservable: expireObservable,
    expire: function () {
      (0,_sessionCookieStore__WEBPACK_IMPORTED_MODULE_3__.deleteSessionCookie)(options);
      synchronizeSession({});
    },
    stop: function () {
      (0,_tools_timer__WEBPACK_IMPORTED_MODULE_1__.clearInterval)(watchSessionTimeoutId);
    }
  };
}
//# sourceMappingURL=sessionStore.js.map

/***/ }),

/***/ 252492:
/*!********************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/synthetics/syntheticsWorkerValues.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SYNTHETICS_INJECTS_RUM_COOKIE_NAME": () => (/* binding */ SYNTHETICS_INJECTS_RUM_COOKIE_NAME),
/* harmony export */   "SYNTHETICS_RESULT_ID_COOKIE_NAME": () => (/* binding */ SYNTHETICS_RESULT_ID_COOKIE_NAME),
/* harmony export */   "SYNTHETICS_TEST_ID_COOKIE_NAME": () => (/* binding */ SYNTHETICS_TEST_ID_COOKIE_NAME),
/* harmony export */   "getSyntheticsResultId": () => (/* binding */ getSyntheticsResultId),
/* harmony export */   "getSyntheticsTestId": () => (/* binding */ getSyntheticsTestId),
/* harmony export */   "willSyntheticsInjectRum": () => (/* binding */ willSyntheticsInjectRum)
/* harmony export */ });
/* harmony import */ var _browser_cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../browser/cookie */ 665627);

var SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id';
var SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id';
var SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum';
function willSyntheticsInjectRum() {
  return Boolean(window._DATADOG_SYNTHETICS_INJECTS_RUM || (0,_browser_cookie__WEBPACK_IMPORTED_MODULE_0__.getCookie)(SYNTHETICS_INJECTS_RUM_COOKIE_NAME));
}
function getSyntheticsTestId() {
  var value = window._DATADOG_SYNTHETICS_PUBLIC_ID || (0,_browser_cookie__WEBPACK_IMPORTED_MODULE_0__.getCookie)(SYNTHETICS_TEST_ID_COOKIE_NAME);
  return typeof value === 'string' ? value : undefined;
}
function getSyntheticsResultId() {
  var value = window._DATADOG_SYNTHETICS_RESULT_ID || (0,_browser_cookie__WEBPACK_IMPORTED_MODULE_0__.getCookie)(SYNTHETICS_RESULT_ID_COOKIE_NAME);
  return typeof value === 'string' ? value : undefined;
}
//# sourceMappingURL=syntheticsWorkerValues.js.map

/***/ }),

/***/ 975786:
/*!********************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/telemetry/rawTelemetryEvent.types.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TelemetryType": () => (/* binding */ TelemetryType)
/* harmony export */ });
var TelemetryType = {
  log: 'log',
  configuration: 'configuration'
};
//# sourceMappingURL=rawTelemetryEvent.types.js.map

/***/ }),

/***/ 931942:
/*!******************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/telemetry/telemetry.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addTelemetryConfiguration": () => (/* binding */ addTelemetryConfiguration),
/* harmony export */   "addTelemetryDebug": () => (/* binding */ addTelemetryDebug),
/* harmony export */   "addTelemetryError": () => (/* binding */ addTelemetryError),
/* harmony export */   "formatError": () => (/* binding */ formatError),
/* harmony export */   "isTelemetryReplicationAllowed": () => (/* binding */ isTelemetryReplicationAllowed),
/* harmony export */   "resetTelemetry": () => (/* binding */ resetTelemetry),
/* harmony export */   "scrubCustomerFrames": () => (/* binding */ scrubCustomerFrames),
/* harmony export */   "startFakeTelemetry": () => (/* binding */ startFakeTelemetry),
/* harmony export */   "startTelemetry": () => (/* binding */ startTelemetry)
/* harmony export */ });
/* harmony import */ var _tools_display__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../tools/display */ 700959);
/* harmony import */ var _error_error__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../error/error */ 803679);
/* harmony import */ var _tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../tools/experimentalFeatures */ 393968);
/* harmony import */ var _configuration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../configuration */ 713312);
/* harmony import */ var _tracekit__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../tracekit */ 976474);
/* harmony import */ var _tools_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/observable */ 32189);
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../tools/utils/timeUtils */ 573647);
/* harmony import */ var _tools_monitor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tools/monitor */ 267830);
/* harmony import */ var _tools_sendToExtension__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/sendToExtension */ 413464);
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/utils/polyfills */ 777760);
/* harmony import */ var _tools_utils_numberUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/utils/numberUtils */ 159127);
/* harmony import */ var _tools_serialisation_jsonStringify__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../tools/serialisation/jsonStringify */ 226590);
/* harmony import */ var _tools_mergeInto__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../tools/mergeInto */ 307529);
/* harmony import */ var _rawTelemetryEvent_types__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rawTelemetryEvent.types */ 975786);














var ALLOWED_FRAME_URLS = ['https://www.datadoghq-browser-agent.com', 'https://www.datad0g-browser-agent.com', 'http://localhost', '<anonymous>'];
var TELEMETRY_EXCLUDED_SITES = [_configuration__WEBPACK_IMPORTED_MODULE_0__.INTAKE_SITE_US1_FED];
var telemetryConfiguration = {
  maxEventsPerPage: 0,
  sentEventCount: 0,
  telemetryEnabled: false,
  telemetryConfigurationEnabled: false
};
var onRawTelemetryEventCollected;
function startTelemetry(telemetryService, configuration) {
  var contextProvider;
  var observable = new _tools_observable__WEBPACK_IMPORTED_MODULE_1__.Observable();
  telemetryConfiguration.telemetryEnabled = !(0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_2__.includes)(TELEMETRY_EXCLUDED_SITES, configuration.site) && (0,_tools_utils_numberUtils__WEBPACK_IMPORTED_MODULE_3__.performDraw)(configuration.telemetrySampleRate);
  telemetryConfiguration.telemetryConfigurationEnabled = telemetryConfiguration.telemetryEnabled && (0,_tools_utils_numberUtils__WEBPACK_IMPORTED_MODULE_3__.performDraw)(configuration.telemetryConfigurationSampleRate);
  onRawTelemetryEventCollected = function (rawEvent) {
    if (telemetryConfiguration.telemetryEnabled) {
      var event_1 = toTelemetryEvent(telemetryService, rawEvent);
      observable.notify(event_1);
      (0,_tools_sendToExtension__WEBPACK_IMPORTED_MODULE_4__.sendToExtension)('telemetry', event_1);
    }
  };
  (0,_tools_monitor__WEBPACK_IMPORTED_MODULE_5__.startMonitorErrorCollection)(addTelemetryError);
  (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_2__.assign)(telemetryConfiguration, {
    maxEventsPerPage: configuration.maxTelemetryEventsPerPage,
    sentEventCount: 0
  });
  function toTelemetryEvent(telemetryService, event) {
    return (0,_tools_mergeInto__WEBPACK_IMPORTED_MODULE_6__.combine)({
      type: 'telemetry',
      date: (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_7__.timeStampNow)(),
      service: telemetryService,
      version: "4.39.0",
      source: 'browser',
      _dd: {
        format_version: 2
      },
      telemetry: event,
      experimental_features: (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_2__.arrayFrom)((0,_tools_experimentalFeatures__WEBPACK_IMPORTED_MODULE_8__.getExperimentalFeatures)())
    }, contextProvider !== undefined ? contextProvider() : {});
  }
  return {
    setContextProvider: function (provider) {
      contextProvider = provider;
    },
    observable: observable,
    enabled: telemetryConfiguration.telemetryEnabled
  };
}
function startFakeTelemetry() {
  var events = [];
  (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_2__.assign)(telemetryConfiguration, {
    maxEventsPerPage: Infinity,
    sentEventCount: 0
  });
  onRawTelemetryEventCollected = function (event) {
    events.push(event);
  };
  return events;
}
function resetTelemetry() {
  onRawTelemetryEventCollected = undefined;
}
/**
 * Avoid mixing telemetry events from different data centers
 * but keep replicating staging events for reliability
 */
function isTelemetryReplicationAllowed(configuration) {
  return configuration.site === _configuration__WEBPACK_IMPORTED_MODULE_0__.INTAKE_SITE_STAGING;
}
function addTelemetryDebug(message, context) {
  (0,_tools_monitor__WEBPACK_IMPORTED_MODULE_5__.displayIfDebugEnabled)(_tools_display__WEBPACK_IMPORTED_MODULE_9__.ConsoleApiName.debug, message, context);
  addTelemetry((0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_2__.assign)({
    type: _rawTelemetryEvent_types__WEBPACK_IMPORTED_MODULE_10__.TelemetryType.log,
    message: message,
    status: "debug" /* StatusType.debug */
  }, context));
}
function addTelemetryError(e) {
  addTelemetry((0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_2__.assign)({
    type: _rawTelemetryEvent_types__WEBPACK_IMPORTED_MODULE_10__.TelemetryType.log,
    status: "error" /* StatusType.error */
  }, formatError(e)));
}
function addTelemetryConfiguration(configuration) {
  if (telemetryConfiguration.telemetryConfigurationEnabled) {
    addTelemetry({
      type: _rawTelemetryEvent_types__WEBPACK_IMPORTED_MODULE_10__.TelemetryType.configuration,
      configuration: configuration
    });
  }
}
function addTelemetry(event) {
  if (onRawTelemetryEventCollected && telemetryConfiguration.sentEventCount < telemetryConfiguration.maxEventsPerPage) {
    telemetryConfiguration.sentEventCount += 1;
    onRawTelemetryEventCollected(event);
  }
}
function formatError(e) {
  if (e instanceof Error) {
    var stackTrace = (0,_tracekit__WEBPACK_IMPORTED_MODULE_11__.computeStackTrace)(e);
    return {
      error: {
        kind: stackTrace.name,
        stack: (0,_error_error__WEBPACK_IMPORTED_MODULE_12__.toStackTraceString)(scrubCustomerFrames(stackTrace))
      },
      message: stackTrace.message
    };
  }
  return {
    error: {
      stack: 'Not an instance of error'
    },
    message: "Uncaught ".concat((0,_tools_serialisation_jsonStringify__WEBPACK_IMPORTED_MODULE_13__.jsonStringify)(e))
  };
}
function scrubCustomerFrames(stackTrace) {
  stackTrace.stack = stackTrace.stack.filter(function (frame) {
    return !frame.url || ALLOWED_FRAME_URLS.some(function (allowedFrameUrl) {
      return (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_2__.startsWith)(frame.url, allowedFrameUrl);
    });
  });
  return stackTrace;
}
//# sourceMappingURL=telemetry.js.map

/***/ }),

/***/ 976474:
/*!*************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/tracekit/computeStackTrace.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "computeStackTrace": () => (/* binding */ computeStackTrace)
/* harmony export */ });
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/utils/polyfills */ 777760);

var UNKNOWN_FUNCTION = '?';
/**
 * Computes a stack trace for an exception.
 */
function computeStackTrace(ex) {
  var stack = [];
  var stackProperty = tryToGetString(ex, 'stack');
  var exString = String(ex);
  if (stackProperty && (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_0__.startsWith)(stackProperty, exString)) {
    stackProperty = stackProperty.slice(exString.length);
  }
  if (stackProperty) {
    stackProperty.split('\n').forEach(function (line) {
      var stackFrame = parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line);
      if (stackFrame) {
        if (!stackFrame.func && stackFrame.line) {
          stackFrame.func = UNKNOWN_FUNCTION;
        }
        stack.push(stackFrame);
      }
    });
  }
  return {
    message: tryToGetString(ex, 'message'),
    name: tryToGetString(ex, 'name'),
    stack: stack
  };
}
var fileUrl = '((?:file|https?|blob|chrome-extension|native|eval|webpack|snippet|<anonymous>|\\w+\\.|\\/).*?)';
var filePosition = '(?::(\\d+))';
var CHROME_LINE_RE = new RegExp("^\\s*at (.*?) ?\\(".concat(fileUrl).concat(filePosition, "?").concat(filePosition, "?\\)?\\s*$"), 'i');
var CHROME_EVAL_RE = new RegExp("\\((\\S*)".concat(filePosition).concat(filePosition, "\\)"));
function parseChromeLine(line) {
  var parts = CHROME_LINE_RE.exec(line);
  if (!parts) {
    return;
  }
  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
  var submatch = CHROME_EVAL_RE.exec(parts[2]);
  if (isEval && submatch) {
    // throw out eval line/column and use top-most line/column number
    parts[2] = submatch[1]; // url
    parts[3] = submatch[2]; // line
    parts[4] = submatch[3]; // column
  }

  return {
    args: isNative ? [parts[2]] : [],
    column: parts[4] ? +parts[4] : undefined,
    func: parts[1] || UNKNOWN_FUNCTION,
    line: parts[3] ? +parts[3] : undefined,
    url: !isNative ? parts[2] : undefined
  };
}
var CHROME_ANONYMOUS_FUNCTION_RE = new RegExp("^\\s*at ?".concat(fileUrl).concat(filePosition, "?").concat(filePosition, "??\\s*$"), 'i');
function parseChromeAnonymousLine(line) {
  var parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line);
  if (!parts) {
    return;
  }
  return {
    args: [],
    column: parts[3] ? +parts[3] : undefined,
    func: UNKNOWN_FUNCTION,
    line: parts[2] ? +parts[2] : undefined,
    url: parts[1]
  };
}
var WINJS_LINE_RE = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseWinLine(line) {
  var parts = WINJS_LINE_RE.exec(line);
  if (!parts) {
    return;
  }
  return {
    args: [],
    column: parts[4] ? +parts[4] : undefined,
    func: parts[1] || UNKNOWN_FUNCTION,
    line: +parts[3],
    url: parts[2]
  };
}
var GECKO_LINE_RE = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var GECKO_EVAL_RE = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
function parseGeckoLine(line) {
  var parts = GECKO_LINE_RE.exec(line);
  if (!parts) {
    return;
  }
  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
  var submatch = GECKO_EVAL_RE.exec(parts[3]);
  if (isEval && submatch) {
    // throw out eval line/column and use top-most line number
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = undefined; // no column when eval
  }

  return {
    args: parts[2] ? parts[2].split(',') : [],
    column: parts[5] ? +parts[5] : undefined,
    func: parts[1] || UNKNOWN_FUNCTION,
    line: parts[4] ? +parts[4] : undefined,
    url: parts[3]
  };
}
function tryToGetString(candidate, property) {
  if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {
    return undefined;
  }
  var value = candidate[property];
  return typeof value === 'string' ? value : undefined;
}
//# sourceMappingURL=computeStackTrace.js.map

/***/ }),

/***/ 355919:
/*!****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/tracekit/tracekit.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startUnhandledErrorCollection": () => (/* binding */ startUnhandledErrorCollection)
/* harmony export */ });
/* harmony import */ var _tools_instrumentMethod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/instrumentMethod */ 101280);
/* harmony import */ var _computeStackTrace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./computeStackTrace */ 976474);


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;
/**
 * Cross-browser collection of unhandled errors
 *
 * Supports:
 * - Firefox: full stack trace with line numbers, plus column number
 * on top frame; column number is not guaranteed
 * - Opera: full stack trace with line and column numbers
 * - Chrome: full stack trace with line and column numbers
 * - Safari: line and column number for the top frame only; some frames
 * may be missing, and column number is not guaranteed
 * - IE: line and column number for the top frame only; some frames
 * may be missing, and column number is not guaranteed
 *
 * In theory, TraceKit should work on all of the following versions:
 * - IE5.5+ (only 8.0 tested)
 * - Firefox 0.9+ (only 3.5+ tested)
 * - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
 * Exceptions Have Stacktrace to be enabled in opera:config)
 * - Safari 3+ (only 4+ tested)
 * - Chrome 1+ (only 5+ tested)
 * - Konqueror 3.5+ (untested)
 *
 * Tries to catch all unhandled errors and report them to the
 * callback.
 *
 * Callbacks receive a StackTrace object as described in the
 * computeStackTrace docs.
 *
 * @memberof TraceKit
 * @namespace
 */
function startUnhandledErrorCollection(callback) {
  var stopInstrumentingOnError = instrumentOnError(callback).stop;
  var stopInstrumentingOnUnhandledRejection = instrumentUnhandledRejection(callback).stop;
  return {
    stop: function () {
      stopInstrumentingOnError();
      stopInstrumentingOnUnhandledRejection();
    }
  };
}
/**
 * Install a global onerror handler
 */
function instrumentOnError(callback) {
  return (0,_tools_instrumentMethod__WEBPACK_IMPORTED_MODULE_0__.instrumentMethodAndCallOriginal)(window, 'onerror', {
    before: function (message, url, lineNo, columnNo, errorObj) {
      var stack;
      if (errorObj) {
        stack = (0,_computeStackTrace__WEBPACK_IMPORTED_MODULE_1__.computeStackTrace)(errorObj);
        callback(stack, errorObj);
      } else {
        var location_1 = {
          url: url,
          column: columnNo,
          line: lineNo
        };
        var name_1;
        var msg = message;
        if ({}.toString.call(message) === '[object String]') {
          var groups = ERROR_TYPES_RE.exec(msg);
          if (groups) {
            name_1 = groups[1];
            msg = groups[2];
          }
        }
        stack = {
          name: name_1,
          message: typeof msg === 'string' ? msg : undefined,
          stack: [location_1]
        };
        callback(stack, message);
      }
    }
  });
}
/**
 * Install a global onunhandledrejection handler
 */
function instrumentUnhandledRejection(callback) {
  return (0,_tools_instrumentMethod__WEBPACK_IMPORTED_MODULE_0__.instrumentMethodAndCallOriginal)(window, 'onunhandledrejection', {
    before: function (e) {
      var reason = e.reason || 'Empty reason';
      var stack = (0,_computeStackTrace__WEBPACK_IMPORTED_MODULE_1__.computeStackTrace)(reason);
      callback(stack, reason);
    }
  });
}
//# sourceMappingURL=tracekit.js.map

/***/ }),

/***/ 18000:
/*!********************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/domain/user/user.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkUser": () => (/* binding */ checkUser),
/* harmony export */   "sanitizeUser": () => (/* binding */ sanitizeUser)
/* harmony export */ });
/* harmony import */ var _tools_display__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/display */ 700959);
/* harmony import */ var _tools_utils_typeUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/utils/typeUtils */ 938993);
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/utils/polyfills */ 777760);



/**
 * Clone input data and ensure known user properties (id, name, email)
 * are strings, as defined here:
 * https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#user-related-attributes
 */
function sanitizeUser(newUser) {
  // We shallow clone only to prevent mutation of user data.
  var user = (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_0__.assign)({}, newUser);
  var keys = ['id', 'name', 'email'];
  keys.forEach(function (key) {
    if (key in user) {
      user[key] = String(user[key]);
    }
  });
  return user;
}
/**
 * Simple check to ensure user is valid
 */
function checkUser(newUser) {
  var isValid = (0,_tools_utils_typeUtils__WEBPACK_IMPORTED_MODULE_1__.getType)(newUser) === 'object';
  if (!isValid) {
    _tools_display__WEBPACK_IMPORTED_MODULE_2__.display.error('Unsupported user:', newUser);
  }
  return isValid;
}
//# sourceMappingURL=user.js.map

/***/ }),

/***/ 685776:
/*!***********************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/boundedBuffer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BoundedBuffer": () => (/* binding */ BoundedBuffer)
/* harmony export */ });
var BUFFER_LIMIT = 500;
var BoundedBuffer = /** @class */function () {
  function BoundedBuffer() {
    this.buffer = [];
  }
  BoundedBuffer.prototype.add = function (callback) {
    var length = this.buffer.push(callback);
    if (length > BUFFER_LIMIT) {
      this.buffer.splice(0, 1);
    }
  };
  BoundedBuffer.prototype.drain = function () {
    this.buffer.forEach(function (callback) {
      return callback();
    });
    this.buffer.length = 0;
  };
  return BoundedBuffer;
}();

//# sourceMappingURL=boundedBuffer.js.map

/***/ }),

/***/ 648755:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/catchUserErrors.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "catchUserErrors": () => (/* binding */ catchUserErrors)
/* harmony export */ });
/* harmony import */ var _display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./display */ 700959);

function catchUserErrors(fn, errorMsg) {
  return function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    try {
      return fn.apply(void 0, args);
    } catch (err) {
      _display__WEBPACK_IMPORTED_MODULE_0__.display.error(errorMsg, err);
    }
  };
}
//# sourceMappingURL=catchUserErrors.js.map

/***/ }),

/***/ 700959:
/*!*****************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/display.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConsoleApiName": () => (/* binding */ ConsoleApiName),
/* harmony export */   "display": () => (/* binding */ display)
/* harmony export */ });
/* eslint-disable no-console, local-rules/disallow-side-effects */
/**
 * Keep references on console methods to avoid triggering patched behaviors
 *
 * NB: in some setup, console could already be patched by another SDK.
 * In this case, some display messages can be sent by the other SDK
 * but we should be safe from infinite loop nonetheless.
 */
var ConsoleApiName = {
  log: 'log',
  debug: 'debug',
  info: 'info',
  warn: 'warn',
  error: 'error'
};
var display = function (api) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (!Object.prototype.hasOwnProperty.call(ConsoleApiName, api)) {
    api = ConsoleApiName.log;
  }
  display[api].apply(display, args);
};
display.debug = console.debug.bind(console);
display.log = console.log.bind(console);
display.info = console.info.bind(console);
display.warn = console.warn.bind(console);
display.error = console.error.bind(console);
//# sourceMappingURL=display.js.map

/***/ }),

/***/ 393968:
/*!******************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/experimentalFeatures.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExperimentalFeature": () => (/* binding */ ExperimentalFeature),
/* harmony export */   "addExperimentalFeatures": () => (/* binding */ addExperimentalFeatures),
/* harmony export */   "getExperimentalFeatures": () => (/* binding */ getExperimentalFeatures),
/* harmony export */   "isExperimentalFeatureEnabled": () => (/* binding */ isExperimentalFeatureEnabled),
/* harmony export */   "resetExperimentalFeatures": () => (/* binding */ resetExperimentalFeatures)
/* harmony export */ });
/**
 * LIMITATION:
 * For NPM setup, this feature flag singleton is shared between RUM and Logs product.
 * This means that an experimental flag set on the RUM product will be set on the Logs product.
 * So keep in mind that in certain configurations, your experimental feature flag may affect other products.
 *
 * FORMAT:
 * All feature flags should be snake_cased
 */
// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary
// string is an expected feature flag
// eslint-disable-next-line no-restricted-syntax
var ExperimentalFeature;
(function (ExperimentalFeature) {
  ExperimentalFeature["PAGEHIDE"] = "pagehide";
  ExperimentalFeature["FEATURE_FLAGS"] = "feature_flags";
  ExperimentalFeature["RESOURCE_PAGE_STATES"] = "resource_page_states";
  ExperimentalFeature["CLICKMAP"] = "clickmap";
  ExperimentalFeature["COLLECT_FLUSH_REASON"] = "collect_flush_reason";
  ExperimentalFeature["SANITIZE_INPUTS"] = "sanitize_inputs";
})(ExperimentalFeature || (ExperimentalFeature = {}));
var enabledExperimentalFeatures = new Set();
function addExperimentalFeatures(enabledFeatures) {
  enabledFeatures.forEach(function (flag) {
    enabledExperimentalFeatures.add(flag);
  });
}
function isExperimentalFeatureEnabled(featureName) {
  return enabledExperimentalFeatures.has(featureName);
}
function resetExperimentalFeatures() {
  enabledExperimentalFeatures.clear();
}
function getExperimentalFeatures() {
  return enabledExperimentalFeatures;
}
//# sourceMappingURL=experimentalFeatures.js.map

/***/ }),

/***/ 909428:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/getGlobalObject.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getGlobalObject": () => (/* binding */ getGlobalObject)
/* harmony export */ });
/**
 * inspired by https://mathiasbynens.be/notes/globalthis
 */
function getGlobalObject() {
  if (typeof globalThis === 'object') {
    return globalThis;
  }
  Object.defineProperty(Object.prototype, '_dd_temp_', {
    get: function () {
      return this;
    },
    configurable: true
  });
  // @ts-ignore _dd_temp is defined using defineProperty
  var globalObject = _dd_temp_;
  // @ts-ignore _dd_temp is defined using defineProperty
  delete Object.prototype._dd_temp_;
  if (typeof globalObject !== 'object') {
    // on safari _dd_temp_ is available on window but not globally
    // fallback on other browser globals check
    if (typeof self === 'object') {
      globalObject = self;
    } else if (typeof window === 'object') {
      globalObject = window;
    } else {
      globalObject = {};
    }
  }
  return globalObject;
}
//# sourceMappingURL=getGlobalObject.js.map

/***/ }),

/***/ 129107:
/*!********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/getZoneJsOriginalValue.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getZoneJsOriginalValue": () => (/* binding */ getZoneJsOriginalValue)
/* harmony export */ });
/* harmony import */ var _getGlobalObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getGlobalObject */ 909428);

/**
 * Gets the original value for a DOM API that was potentially patched by Zone.js.
 *
 * Zone.js[1] is a library that patches a bunch of JS and DOM APIs. It usually stores the original
 * value of the patched functions/constructors/methods in a hidden property prefixed by
 * __zone_symbol__.
 *
 * In multiple occasions, we observed that Zone.js is the culprit of important issues leading to
 * browser resource exhaustion (memory leak, high CPU usage). This method is used as a workaround to
 * use the original DOM API instead of the one patched by Zone.js.
 *
 * [1]: https://github.com/angular/angular/tree/main/packages/zone.js
 */
function getZoneJsOriginalValue(target, name) {
  var browserWindow = (0,_getGlobalObject__WEBPACK_IMPORTED_MODULE_0__.getGlobalObject)();
  var original;
  if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === 'function') {
    original = target[browserWindow.Zone.__symbol__(name)];
  }
  if (!original) {
    original = target[name];
  }
  return original;
}
//# sourceMappingURL=getZoneJsOriginalValue.js.map

/***/ }),

/***/ 101280:
/*!**************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/instrumentMethod.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "instrumentMethod": () => (/* binding */ instrumentMethod),
/* harmony export */   "instrumentMethodAndCallOriginal": () => (/* binding */ instrumentMethodAndCallOriginal),
/* harmony export */   "instrumentSetter": () => (/* binding */ instrumentSetter)
/* harmony export */ });
/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./timer */ 631128);
/* harmony import */ var _monitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./monitor */ 267830);
/* harmony import */ var _utils_functionUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/functionUtils */ 897826);



function instrumentMethod(object, method, instrumentationFactory) {
  var original = object[method];
  var instrumentation = instrumentationFactory(original);
  var instrumentationWrapper = function () {
    if (typeof instrumentation !== 'function') {
      return undefined;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return instrumentation.apply(this, arguments);
  };
  object[method] = instrumentationWrapper;
  return {
    stop: function () {
      if (object[method] === instrumentationWrapper) {
        object[method] = original;
      } else {
        instrumentation = original;
      }
    }
  };
}
function instrumentMethodAndCallOriginal(object, method, _a) {
  var before = _a.before,
    after = _a.after;
  return instrumentMethod(object, method, function (original) {
    return function () {
      var args = arguments;
      var result;
      if (before) {
        (0,_monitor__WEBPACK_IMPORTED_MODULE_0__.callMonitored)(before, this, args);
      }
      if (typeof original === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        result = original.apply(this, args);
      }
      if (after) {
        (0,_monitor__WEBPACK_IMPORTED_MODULE_0__.callMonitored)(after, this, args);
      }
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      return result;
    };
  });
}
function instrumentSetter(object, property, after) {
  var originalDescriptor = Object.getOwnPropertyDescriptor(object, property);
  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {
    return {
      stop: _utils_functionUtils__WEBPACK_IMPORTED_MODULE_1__.noop
    };
  }
  var instrumentation = function (thisObject, value) {
    // put hooked setter into event loop to avoid of set latency
    (0,_timer__WEBPACK_IMPORTED_MODULE_2__.setTimeout)(function () {
      after(thisObject, value);
    }, 0);
  };
  var instrumentationWrapper = function (value) {
    originalDescriptor.set.call(this, value);
    instrumentation(this, value);
  };
  Object.defineProperty(object, property, {
    set: instrumentationWrapper
  });
  return {
    stop: function () {
      var _a;
      if (((_a = Object.getOwnPropertyDescriptor(object, property)) === null || _a === void 0 ? void 0 : _a.set) === instrumentationWrapper) {
        Object.defineProperty(object, property, originalDescriptor);
      } else {
        instrumentation = _utils_functionUtils__WEBPACK_IMPORTED_MODULE_1__.noop;
      }
    }
  };
}
//# sourceMappingURL=instrumentMethod.js.map

/***/ }),

/***/ 484336:
/*!*********************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/matchOption.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isMatchOption": () => (/* binding */ isMatchOption),
/* harmony export */   "matchList": () => (/* binding */ matchList)
/* harmony export */ });
/* harmony import */ var _utils_polyfills__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/polyfills */ 777760);
/* harmony import */ var _display__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./display */ 700959);
/* harmony import */ var _utils_typeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/typeUtils */ 938993);



function isMatchOption(item) {
  var itemType = (0,_utils_typeUtils__WEBPACK_IMPORTED_MODULE_0__.getType)(item);
  return itemType === 'string' || itemType === 'function' || item instanceof RegExp;
}
/**
 * Returns true if value can be matched by at least one of the provided MatchOptions.
 * When comparing strings, setting useStartsWith to true will compare the value with the start of
 * the option, instead of requiring an exact match.
 */
function matchList(list, value, useStartsWith) {
  if (useStartsWith === void 0) {
    useStartsWith = false;
  }
  return list.some(function (item) {
    try {
      if (typeof item === 'function') {
        return item(value);
      } else if (item instanceof RegExp) {
        return item.test(value);
      } else if (typeof item === 'string') {
        return useStartsWith ? (0,_utils_polyfills__WEBPACK_IMPORTED_MODULE_1__.startsWith)(value, item) : item === value;
      }
    } catch (e) {
      _display__WEBPACK_IMPORTED_MODULE_2__.display.error(e);
    }
    return false;
  });
}
//# sourceMappingURL=matchOption.js.map

/***/ }),

/***/ 307529:
/*!*******************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/mergeInto.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "combine": () => (/* binding */ combine),
/* harmony export */   "deepClone": () => (/* binding */ deepClone),
/* harmony export */   "mergeInto": () => (/* binding */ mergeInto)
/* harmony export */ });
/* harmony import */ var _utils_typeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/typeUtils */ 938993);

/**
 * Iterate over source and affect its sub values into destination, recursively.
 * If the source and destination can't be merged, return source.
 */
function mergeInto(destination, source, circularReferenceChecker) {
  if (circularReferenceChecker === void 0) {
    circularReferenceChecker = createCircularReferenceChecker();
  }
  // ignore the source if it is undefined
  if (source === undefined) {
    return destination;
  }
  if (typeof source !== 'object' || source === null) {
    // primitive values - just return source
    return source;
  } else if (source instanceof Date) {
    return new Date(source.getTime());
  } else if (source instanceof RegExp) {
    var flags = source.flags ||
    // old browsers compatibility
    [source.global ? 'g' : '', source.ignoreCase ? 'i' : '', source.multiline ? 'm' : '', source.sticky ? 'y' : '', source.unicode ? 'u' : ''].join('');
    return new RegExp(source.source, flags);
  }
  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {
    // remove circular references
    return undefined;
  } else if (Array.isArray(source)) {
    var merged_1 = Array.isArray(destination) ? destination : [];
    for (var i = 0; i < source.length; ++i) {
      merged_1[i] = mergeInto(merged_1[i], source[i], circularReferenceChecker);
    }
    return merged_1;
  }
  var merged = (0,_utils_typeUtils__WEBPACK_IMPORTED_MODULE_0__.getType)(destination) === 'object' ? destination : {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker);
    }
  }
  return merged;
}
/**
 * A simplistic implementation of a deep clone algorithm.
 * Caveats:
 * - It doesn't maintain prototype chains - don't use with instances of custom classes.
 * - It doesn't handle Map and Set
 */
function deepClone(value) {
  return mergeInto(undefined, value);
}
function combine() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  var destination;
  for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
    var source = sources_1[_a];
    // Ignore any undefined or null sources.
    if (source === undefined || source === null) {
      continue;
    }
    destination = mergeInto(destination, source);
  }
  return destination;
}
function createCircularReferenceChecker() {
  if (typeof WeakSet !== 'undefined') {
    var set_1 = new WeakSet();
    return {
      hasAlreadyBeenSeen: function (value) {
        var has = set_1.has(value);
        if (!has) {
          set_1.add(value);
        }
        return has;
      }
    };
  }
  var array = [];
  return {
    hasAlreadyBeenSeen: function (value) {
      var has = array.indexOf(value) >= 0;
      if (!has) {
        array.push(value);
      }
      return has;
    }
  };
}
//# sourceMappingURL=mergeInto.js.map

/***/ }),

/***/ 267830:
/*!*****************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/monitor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callMonitored": () => (/* binding */ callMonitored),
/* harmony export */   "displayIfDebugEnabled": () => (/* binding */ displayIfDebugEnabled),
/* harmony export */   "monitor": () => (/* binding */ monitor),
/* harmony export */   "monitored": () => (/* binding */ monitored),
/* harmony export */   "resetMonitor": () => (/* binding */ resetMonitor),
/* harmony export */   "setDebugMode": () => (/* binding */ setDebugMode),
/* harmony export */   "startMonitorErrorCollection": () => (/* binding */ startMonitorErrorCollection)
/* harmony export */ });
/* harmony import */ var _display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./display */ 700959);
var __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};

var onMonitorErrorCollected;
var debugMode = false;
function startMonitorErrorCollection(newOnMonitorErrorCollected) {
  onMonitorErrorCollected = newOnMonitorErrorCollected;
}
function setDebugMode(newDebugMode) {
  debugMode = newDebugMode;
}
function resetMonitor() {
  onMonitorErrorCollected = undefined;
  debugMode = false;
}
function monitored(_, __, descriptor) {
  var originalMethod = descriptor.value;
  descriptor.value = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod;
    return decorated.apply(this, args);
  };
}
function monitor(fn) {
  return function () {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return callMonitored(fn, this, arguments);
  }; // consider output type has input type
}

function callMonitored(fn, context, args) {
  try {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return fn.apply(context, args);
  } catch (e) {
    displayIfDebugEnabled(_display__WEBPACK_IMPORTED_MODULE_0__.ConsoleApiName.error, e);
    if (onMonitorErrorCollected) {
      try {
        onMonitorErrorCollected(e);
      } catch (e) {
        displayIfDebugEnabled(_display__WEBPACK_IMPORTED_MODULE_0__.ConsoleApiName.error, e);
      }
    }
  }
}
function displayIfDebugEnabled(api) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (debugMode) {
    _display__WEBPACK_IMPORTED_MODULE_0__.display.apply(void 0, __spreadArray([api, '[MONITOR]'], args, false));
  }
}
//# sourceMappingURL=monitor.js.map

/***/ }),

/***/ 32189:
/*!********************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/observable.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Observable": () => (/* binding */ Observable),
/* harmony export */   "mergeObservables": () => (/* binding */ mergeObservables)
/* harmony export */ });
var Observable = /** @class */function () {
  function Observable(onFirstSubscribe) {
    this.onFirstSubscribe = onFirstSubscribe;
    this.observers = [];
  }
  Observable.prototype.subscribe = function (f) {
    var _this = this;
    if (!this.observers.length && this.onFirstSubscribe) {
      this.onLastUnsubscribe = this.onFirstSubscribe() || undefined;
    }
    this.observers.push(f);
    return {
      unsubscribe: function () {
        _this.observers = _this.observers.filter(function (other) {
          return f !== other;
        });
        if (!_this.observers.length && _this.onLastUnsubscribe) {
          _this.onLastUnsubscribe();
        }
      }
    };
  };
  Observable.prototype.notify = function (data) {
    this.observers.forEach(function (observer) {
      return observer(data);
    });
  };
  return Observable;
}();

function mergeObservables() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var globalObservable = new Observable(function () {
    var subscriptions = observables.map(function (observable) {
      return observable.subscribe(function (data) {
        return globalObservable.notify(data);
      });
    });
    return function () {
      return subscriptions.forEach(function (subscription) {
        return subscription.unsubscribe();
      });
    };
  });
  return globalObservable;
}
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ 271048:
/*!*****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/readBytesFromStream.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "readBytesFromStream": () => (/* binding */ readBytesFromStream)
/* harmony export */ });
/* harmony import */ var _monitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./monitor */ 267830);
/* harmony import */ var _utils_functionUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/functionUtils */ 897826);


/**
 * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of
 * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit
 * has been exceeded if more bytes were available.
 */
function readBytesFromStream(stream, callback, options) {
  var reader = stream.getReader();
  var chunks = [];
  var readBytesCount = 0;
  readMore();
  function readMore() {
    reader.read().then((0,_monitor__WEBPACK_IMPORTED_MODULE_0__.monitor)(function (result) {
      if (result.done) {
        onDone();
        return;
      }
      if (options.collectStreamBody) {
        chunks.push(result.value);
      }
      readBytesCount += result.value.length;
      if (readBytesCount > options.bytesLimit) {
        onDone();
      } else {
        readMore();
      }
    }), (0,_monitor__WEBPACK_IMPORTED_MODULE_0__.monitor)(function (error) {
      return callback(error);
    }));
  }
  function onDone() {
    reader.cancel().catch(
    // we don't care if cancel fails, but we still need to catch the error to avoid reporting it
    // as an unhandled rejection
    _utils_functionUtils__WEBPACK_IMPORTED_MODULE_1__.noop);
    var bytes;
    var limitExceeded;
    if (options.collectStreamBody) {
      var completeBuffer_1;
      if (chunks.length === 1) {
        // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just
        // use it directly.
        completeBuffer_1 = chunks[0];
      } else {
        // else, we need to copy buffers into a larger buffer to concatenate them.
        completeBuffer_1 = new Uint8Array(readBytesCount);
        var offset_1 = 0;
        chunks.forEach(function (chunk) {
          completeBuffer_1.set(chunk, offset_1);
          offset_1 += chunk.length;
        });
      }
      bytes = completeBuffer_1.slice(0, options.bytesLimit);
      limitExceeded = completeBuffer_1.length > options.bytesLimit;
    }
    callback(undefined, bytes, limitExceeded);
  }
}
//# sourceMappingURL=readBytesFromStream.js.map

/***/ }),

/***/ 413464:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/sendToExtension.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sendToExtension": () => (/* binding */ sendToExtension)
/* harmony export */ });
function sendToExtension(type, payload) {
  var callback = window.__ddBrowserSdkExtensionCallback;
  if (callback) {
    callback({
      type: type,
      payload: payload
    });
  }
}
//# sourceMappingURL=sendToExtension.js.map

/***/ }),

/***/ 238490:
/*!**************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/serialisation/contextManager.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BYTES_COMPUTATION_THROTTLING_DELAY": () => (/* binding */ BYTES_COMPUTATION_THROTTLING_DELAY),
/* harmony export */   "createContextManager": () => (/* binding */ createContextManager)
/* harmony export */ });
/* harmony import */ var _experimentalFeatures__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../experimentalFeatures */ 393968);
/* harmony import */ var _utils_byteUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/byteUtils */ 85010);
/* harmony import */ var _utils_functionUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/functionUtils */ 897826);
/* harmony import */ var _mergeInto__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mergeInto */ 307529);
/* harmony import */ var _jsonStringify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jsonStringify */ 226590);
/* harmony import */ var _sanitize__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sanitize */ 595530);
/* harmony import */ var _heavyCustomerDataWarning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./heavyCustomerDataWarning */ 837585);







var BYTES_COMPUTATION_THROTTLING_DELAY = 200;
function createContextManager(customerDataType, computeBytesCountImpl) {
  if (computeBytesCountImpl === void 0) {
    computeBytesCountImpl = _utils_byteUtils__WEBPACK_IMPORTED_MODULE_0__.computeBytesCount;
  }
  var context = {};
  var bytesCountCache;
  var alreadyWarned = false;
  // Throttle the bytes computation to minimize the impact on performance.
  // Especially useful if the user call context APIs synchronously multiple times in a row
  var computeBytesCountThrottled = (0,_utils_functionUtils__WEBPACK_IMPORTED_MODULE_1__.throttle)(function (context) {
    bytesCountCache = computeBytesCountImpl((0,_jsonStringify__WEBPACK_IMPORTED_MODULE_2__.jsonStringify)(context));
    if (!alreadyWarned) {
      alreadyWarned = (0,_heavyCustomerDataWarning__WEBPACK_IMPORTED_MODULE_3__.warnIfCustomerDataLimitReached)(bytesCountCache, customerDataType);
    }
  }, BYTES_COMPUTATION_THROTTLING_DELAY).throttled;
  return {
    getBytesCount: function () {
      return bytesCountCache;
    },
    /** @deprecated use getContext instead */
    get: function () {
      return context;
    },
    /** @deprecated use setContextProperty instead */
    add: function (key, value) {
      context[key] = value;
      computeBytesCountThrottled(context);
    },
    /** @deprecated renamed to removeContextProperty */
    remove: function (key) {
      delete context[key];
      computeBytesCountThrottled(context);
    },
    /** @deprecated use setContext instead */
    set: function (newContext) {
      context = newContext;
      computeBytesCountThrottled(context);
    },
    getContext: function () {
      return (0,_mergeInto__WEBPACK_IMPORTED_MODULE_4__.deepClone)(context);
    },
    setContext: function (newContext) {
      context = (0,_experimentalFeatures__WEBPACK_IMPORTED_MODULE_5__.isExperimentalFeatureEnabled)(_experimentalFeatures__WEBPACK_IMPORTED_MODULE_5__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_sanitize__WEBPACK_IMPORTED_MODULE_6__.sanitize)(newContext) : (0,_mergeInto__WEBPACK_IMPORTED_MODULE_4__.deepClone)(newContext);
      computeBytesCountThrottled(context);
    },
    setContextProperty: function (key, property) {
      context[key] = (0,_experimentalFeatures__WEBPACK_IMPORTED_MODULE_5__.isExperimentalFeatureEnabled)(_experimentalFeatures__WEBPACK_IMPORTED_MODULE_5__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_sanitize__WEBPACK_IMPORTED_MODULE_6__.sanitize)(property) : (0,_mergeInto__WEBPACK_IMPORTED_MODULE_4__.deepClone)(property);
      computeBytesCountThrottled(context);
    },
    removeContextProperty: function (key) {
      delete context[key];
      computeBytesCountThrottled(context);
    },
    clearContext: function () {
      context = {};
      bytesCountCache = 0;
    }
  };
}
//# sourceMappingURL=contextManager.js.map

/***/ }),

/***/ 837585:
/*!************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/serialisation/heavyCustomerDataWarning.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CUSTOMER_DATA_BYTES_LIMIT": () => (/* binding */ CUSTOMER_DATA_BYTES_LIMIT),
/* harmony export */   "warnIfCustomerDataLimitReached": () => (/* binding */ warnIfCustomerDataLimitReached)
/* harmony export */ });
/* harmony import */ var _utils_byteUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/byteUtils */ 85010);
/* harmony import */ var _display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../display */ 700959);


// RUM and logs batch bytes limit is 16KB
// ensure that we leave room for other event attributes and maintain a decent amount of event per batch
// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB
var CUSTOMER_DATA_BYTES_LIMIT = 3 * _utils_byteUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_KIBI_BYTE;
function warnIfCustomerDataLimitReached(bytesCount, customerDataType) {
  if (bytesCount > CUSTOMER_DATA_BYTES_LIMIT) {
    _display__WEBPACK_IMPORTED_MODULE_1__.display.warn("The ".concat(customerDataType, " data is over ").concat(CUSTOMER_DATA_BYTES_LIMIT / _utils_byteUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_KIBI_BYTE, "KiB. On low connectivity, the SDK has the potential to exhaust the user's upload bandwidth."));
    return true;
  }
  return false;
}
//# sourceMappingURL=heavyCustomerDataWarning.js.map

/***/ }),

/***/ 226590:
/*!*************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/serialisation/jsonStringify.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "detachToJsonMethod": () => (/* binding */ detachToJsonMethod),
/* harmony export */   "jsonStringify": () => (/* binding */ jsonStringify)
/* harmony export */ });
/* harmony import */ var _utils_functionUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/functionUtils */ 897826);

/**
 * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that
 * because some sites badly override toJSON on certain objects. Removing all toJSON methods from
 * nested values would be too costly, so we just detach them from the root value, and native classes
 * used to build JSON values (Array and Object).
 *
 * Note: this still assumes that JSON.stringify is correct.
 */
function jsonStringify(value, replacer, space) {
  if (typeof value !== 'object' || value === null) {
    return JSON.stringify(value);
  }
  // Note: The order matter here. We need to detach toJSON methods on parent classes before their
  // subclasses.
  var restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);
  var restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);
  var restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value));
  var restoreValueToJson = detachToJsonMethod(value);
  try {
    return JSON.stringify(value, replacer, space);
  } catch (_a) {
    return '<error: unable to serialize object>';
  } finally {
    restoreObjectPrototypeToJson();
    restoreArrayPrototypeToJson();
    restoreValuePrototypeToJson();
    restoreValueToJson();
  }
}
function detachToJsonMethod(value) {
  var object = value;
  var objectToJson = object.toJSON;
  if (objectToJson) {
    delete object.toJSON;
    return function () {
      object.toJSON = objectToJson;
    };
  }
  return _utils_functionUtils__WEBPACK_IMPORTED_MODULE_0__.noop;
}
//# sourceMappingURL=jsonStringify.js.map

/***/ }),

/***/ 595530:
/*!********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/serialisation/sanitize.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sanitize": () => (/* binding */ sanitize)
/* harmony export */ });
/* harmony import */ var _display__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../display */ 700959);
/* harmony import */ var _utils_byteUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/byteUtils */ 85010);
/* harmony import */ var _jsonStringify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jsonStringify */ 226590);



// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data
// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...
var SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * _utils_byteUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_KIBI_BYTE;
// Symbol for the root element of the JSONPath used for visited objects
var JSON_PATH_ROOT_ELEMENT = '$';
// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as "key".
// With the separator (:), we need to add 3 characters to the count.
var KEY_DECORATION_LENGTH = 3;
function sanitize(source, maxCharacterCount) {
  var _a;
  if (maxCharacterCount === void 0) {
    maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT;
  }
  // Unbind any toJSON function we may have on [] or {} prototypes
  var restoreObjectPrototypeToJson = (0,_jsonStringify__WEBPACK_IMPORTED_MODULE_1__.detachToJsonMethod)(Object.prototype);
  var restoreArrayPrototypeToJson = (0,_jsonStringify__WEBPACK_IMPORTED_MODULE_1__.detachToJsonMethod)(Array.prototype);
  // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object
  var containerQueue = [];
  var visitedObjectsWithPath = new WeakMap();
  var sanitizedData = sanitizeProcessor(source, JSON_PATH_ROOT_ELEMENT, undefined, containerQueue, visitedObjectsWithPath);
  var accumulatedCharacterCount = ((_a = JSON.stringify(sanitizedData)) === null || _a === void 0 ? void 0 : _a.length) || 0;
  if (accumulatedCharacterCount > maxCharacterCount) {
    warnOverCharacterLimit(maxCharacterCount, 'discarded', source);
    return undefined;
  }
  while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {
    var containerToProcess = containerQueue.shift();
    var separatorLength = 0; // 0 for the first element, 1 for subsequent elements
    // Arrays and Objects have to be handled distinctly to ensure
    // we do not pick up non-numerical properties from Arrays
    if (Array.isArray(containerToProcess.source)) {
      for (var key = 0; key < containerToProcess.source.length; key++) {
        var targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);
        if (targetData !== undefined) {
          accumulatedCharacterCount += JSON.stringify(targetData).length;
        } else {
          // When an element of an Array (targetData) is undefined, it is serialized as null:
          // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters
          accumulatedCharacterCount += 4;
        }
        accumulatedCharacterCount += separatorLength;
        separatorLength = 1;
        if (accumulatedCharacterCount > maxCharacterCount) {
          warnOverCharacterLimit(maxCharacterCount, 'truncated', source);
          break;
        }
        ;
        containerToProcess.target[key] = targetData;
      }
    } else {
      for (var key in containerToProcess.source) {
        if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {
          var targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);
          // When a property of an object has an undefined value, it will be dropped during serialization:
          // JSON.stringify({a:undefined}) => '{}'
          if (targetData !== undefined) {
            accumulatedCharacterCount += JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH;
            separatorLength = 1;
          }
          if (accumulatedCharacterCount > maxCharacterCount) {
            warnOverCharacterLimit(maxCharacterCount, 'truncated', source);
            break;
          }
          ;
          containerToProcess.target[key] = targetData;
        }
      }
    }
  }
  // Rebind detached toJSON functions
  restoreObjectPrototypeToJson();
  restoreArrayPrototypeToJson();
  return sanitizedData;
}
/**
 * Internal function to factorize the process common to the
 * initial call to sanitize, and iterations for Arrays and Objects
 *
 */
function sanitizeProcessor(source, parentPath, key, queue, visitedObjectsWithPath) {
  // Start by handling toJSON, as we want to sanitize its output
  var sourceToSanitize = tryToApplyToJSON(source);
  if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {
    return sanitizePrimitivesAndFunctions(sourceToSanitize);
  }
  var sanitizedSource = sanitizeObjects(sourceToSanitize);
  if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]') {
    return sanitizedSource;
  }
  // Handle potential cyclic references
  // We need to use source as sourceToSanitize could be a reference to a new object
  // At this stage, we know the source is an object type
  var sourceAsObject = source;
  if (visitedObjectsWithPath.has(sourceAsObject)) {
    return "[Reference seen at ".concat(visitedObjectsWithPath.get(sourceAsObject), "]");
  }
  // Add processed source to queue
  var currentPath = key !== undefined ? "".concat(parentPath, ".").concat(key) : parentPath;
  var target = Array.isArray(sourceToSanitize) ? [] : {};
  visitedObjectsWithPath.set(sourceAsObject, currentPath);
  queue.push({
    source: sourceToSanitize,
    target: target,
    path: currentPath
  });
  return target;
}
/**
 * Handles sanitization of simple, non-object types
 *
 */
function sanitizePrimitivesAndFunctions(value) {
  // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation
  if (typeof value === 'bigint') {
    return "[BigInt] ".concat(value.toString());
  }
  // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted
  // so it won't prevent stringify from serializing later
  if (typeof value === 'function') {
    return "[Function] ".concat(value.name || 'unknown');
  }
  // JSON.stringify() does not serialize symbols.
  if (typeof value === 'symbol') {
    return "[Symbol] ".concat(value.description || value.toString());
  }
  return value;
}
/**
 * Handles sanitization of object types
 *
 * LIMITATIONS
 * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.
 * To avoid this, a toJSON method can be defined.
 * - IE11 does not return a distinct type for objects such as Map, WeakMap, ... These objects will pass through and their
 * properties enumerated if any.
 *
 */
function sanitizeObjects(value) {
  try {
    // Handle events - Keep a simple implementation to avoid breaking changes
    if (value instanceof Event) {
      return {
        isTrusted: value.isTrusted
      };
    }
    // Handle all remaining object types in a generic way
    var result = Object.prototype.toString.call(value);
    var match = result.match(/\[object (.*)\]/);
    if (match && match[1]) {
      return "[".concat(match[1], "]");
    }
  } catch (_a) {
    // If the previous serialization attempts failed, and we cannot convert using
    // Object.prototype.toString, declare the value unserializable
  }
  return '[Unserializable]';
}
/**
 * Checks if a toJSON function exists and tries to execute it
 *
 */
function tryToApplyToJSON(value) {
  var object = value;
  if (object && typeof object.toJSON === 'function') {
    try {
      return object.toJSON();
    } catch (_a) {
      // If toJSON fails, we continue by trying to serialize the value manually
    }
  }
  return value;
}
/**
 * Helper function to display the warning when the accumulated character count is over the limit
 */
function warnOverCharacterLimit(maxCharacterCount, changeType, source) {
  _display__WEBPACK_IMPORTED_MODULE_2__.display.warn("The data provided has been ".concat(changeType, " as it is over the limit of ").concat(maxCharacterCount, " characters:"), source);
}
//# sourceMappingURL=sanitize.js.map

/***/ }),

/***/ 631128:
/*!***************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/timer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearInterval": () => (/* binding */ clearInterval),
/* harmony export */   "clearTimeout": () => (/* binding */ clearTimeout),
/* harmony export */   "setInterval": () => (/* binding */ setInterval),
/* harmony export */   "setTimeout": () => (/* binding */ setTimeout)
/* harmony export */ });
/* harmony import */ var _getZoneJsOriginalValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getZoneJsOriginalValue */ 129107);
/* harmony import */ var _monitor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./monitor */ 267830);
/* harmony import */ var _getGlobalObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getGlobalObject */ 909428);



function setTimeout(callback, delay) {
  return (0,_getZoneJsOriginalValue__WEBPACK_IMPORTED_MODULE_0__.getZoneJsOriginalValue)((0,_getGlobalObject__WEBPACK_IMPORTED_MODULE_1__.getGlobalObject)(), 'setTimeout')((0,_monitor__WEBPACK_IMPORTED_MODULE_2__.monitor)(callback), delay);
}
function clearTimeout(timeoutId) {
  (0,_getZoneJsOriginalValue__WEBPACK_IMPORTED_MODULE_0__.getZoneJsOriginalValue)((0,_getGlobalObject__WEBPACK_IMPORTED_MODULE_1__.getGlobalObject)(), 'clearTimeout')(timeoutId);
}
function setInterval(callback, delay) {
  return (0,_getZoneJsOriginalValue__WEBPACK_IMPORTED_MODULE_0__.getZoneJsOriginalValue)(window, 'setInterval')((0,_monitor__WEBPACK_IMPORTED_MODULE_2__.monitor)(callback), delay);
}
function clearInterval(timeoutId) {
  (0,_getZoneJsOriginalValue__WEBPACK_IMPORTED_MODULE_0__.getZoneJsOriginalValue)(window, 'clearInterval')(timeoutId);
}
//# sourceMappingURL=timer.js.map

/***/ }),

/***/ 731920:
/*!**************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/arrayUtils.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "removeDuplicates": () => (/* binding */ removeDuplicates)
/* harmony export */ });
/* harmony import */ var _polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfills */ 777760);

function removeDuplicates(array) {
  var set = new Set();
  array.forEach(function (item) {
    return set.add(item);
  });
  return (0,_polyfills__WEBPACK_IMPORTED_MODULE_0__.arrayFrom)(set);
}
//# sourceMappingURL=arrayUtils.js.map

/***/ }),

/***/ 64637:
/*!********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/browserDetection.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isChromium": () => (/* binding */ isChromium),
/* harmony export */   "isIE": () => (/* binding */ isIE)
/* harmony export */ });
function isIE() {
  return Boolean(document.documentMode);
}
function isChromium() {
  return !!window.chrome || /HeadlessChrome/.test(window.navigator.userAgent);
}
//# sourceMappingURL=browserDetection.js.map

/***/ }),

/***/ 85010:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/byteUtils.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ONE_KIBI_BYTE": () => (/* binding */ ONE_KIBI_BYTE),
/* harmony export */   "ONE_MEBI_BYTE": () => (/* binding */ ONE_MEBI_BYTE),
/* harmony export */   "computeBytesCount": () => (/* binding */ computeBytesCount)
/* harmony export */ });
var ONE_KIBI_BYTE = 1024;
var ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE;
// eslint-disable-next-line no-control-regex
var HAS_MULTI_BYTES_CHARACTERS = /[^\u0000-\u007F]/;
function computeBytesCount(candidate) {
  // Accurate bytes count computations can degrade performances when there is a lot of events to process
  if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {
    return candidate.length;
  }
  if (window.TextEncoder !== undefined) {
    return new TextEncoder().encode(candidate).length;
  }
  return new Blob([candidate]).size;
}
//# sourceMappingURL=byteUtils.js.map

/***/ }),

/***/ 897826:
/*!*****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/functionUtils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "noop": () => (/* binding */ noop),
/* harmony export */   "throttle": () => (/* binding */ throttle)
/* harmony export */ });
/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../timer */ 631128);

// use lodash API
function throttle(fn, wait, options) {
  var needLeadingExecution = options && options.leading !== undefined ? options.leading : true;
  var needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true;
  var inWaitPeriod = false;
  var pendingExecutionWithParameters;
  var pendingTimeoutId;
  return {
    throttled: function () {
      var parameters = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        parameters[_i] = arguments[_i];
      }
      if (inWaitPeriod) {
        pendingExecutionWithParameters = parameters;
        return;
      }
      if (needLeadingExecution) {
        fn.apply(void 0, parameters);
      } else {
        pendingExecutionWithParameters = parameters;
      }
      inWaitPeriod = true;
      pendingTimeoutId = (0,_timer__WEBPACK_IMPORTED_MODULE_0__.setTimeout)(function () {
        if (needTrailingExecution && pendingExecutionWithParameters) {
          fn.apply(void 0, pendingExecutionWithParameters);
        }
        inWaitPeriod = false;
        pendingExecutionWithParameters = undefined;
      }, wait);
    },
    cancel: function () {
      (0,_timer__WEBPACK_IMPORTED_MODULE_0__.clearTimeout)(pendingTimeoutId);
      inWaitPeriod = false;
      pendingExecutionWithParameters = undefined;
    }
  };
}
// eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() {}
//# sourceMappingURL=functionUtils.js.map

/***/ }),

/***/ 159127:
/*!***************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/numberUtils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isPercentage": () => (/* binding */ isPercentage),
/* harmony export */   "performDraw": () => (/* binding */ performDraw),
/* harmony export */   "round": () => (/* binding */ round)
/* harmony export */ });
/**
 * Return true if the draw is successful
 * @param threshold between 0 and 100
 */
function performDraw(threshold) {
  return threshold !== 0 && Math.random() * 100 <= threshold;
}
function round(num, decimals) {
  return +num.toFixed(decimals);
}
function isPercentage(value) {
  return isNumber(value) && value >= 0 && value <= 100;
}
function isNumber(value) {
  return typeof value === 'number';
}
//# sourceMappingURL=numberUtils.js.map

/***/ }),

/***/ 567934:
/*!***************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/objectUtils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isEmptyObject": () => (/* binding */ isEmptyObject),
/* harmony export */   "mapValues": () => (/* binding */ mapValues),
/* harmony export */   "objectHasValue": () => (/* binding */ objectHasValue),
/* harmony export */   "shallowClone": () => (/* binding */ shallowClone)
/* harmony export */ });
/* harmony import */ var _polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfills */ 777760);

function shallowClone(object) {
  return (0,_polyfills__WEBPACK_IMPORTED_MODULE_0__.assign)({}, object);
}
function objectHasValue(object, value) {
  return Object.keys(object).some(function (key) {
    return object[key] === value;
  });
}
function isEmptyObject(object) {
  return Object.keys(object).length === 0;
}
function mapValues(object, fn) {
  var newObject = {};
  for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
    var key = _a[_i];
    newObject[key] = fn(object[key]);
  }
  return newObject;
}
//# sourceMappingURL=objectUtils.js.map

/***/ }),

/***/ 777760:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/polyfills.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayFrom": () => (/* binding */ arrayFrom),
/* harmony export */   "assign": () => (/* binding */ assign),
/* harmony export */   "cssEscape": () => (/* binding */ cssEscape),
/* harmony export */   "elementMatches": () => (/* binding */ elementMatches),
/* harmony export */   "endsWith": () => (/* binding */ endsWith),
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "findLast": () => (/* binding */ findLast),
/* harmony export */   "forEach": () => (/* binding */ forEach),
/* harmony export */   "includes": () => (/* binding */ includes),
/* harmony export */   "objectEntries": () => (/* binding */ objectEntries),
/* harmony export */   "objectValues": () => (/* binding */ objectValues),
/* harmony export */   "startsWith": () => (/* binding */ startsWith)
/* harmony export */ });
function includes(candidate, search) {
  return candidate.indexOf(search) !== -1;
}
function arrayFrom(arrayLike) {
  if (Array.from) {
    return Array.from(arrayLike);
  }
  var array = [];
  if (arrayLike instanceof Set) {
    arrayLike.forEach(function (item) {
      return array.push(item);
    });
  } else {
    for (var i = 0; i < arrayLike.length; i++) {
      array.push(arrayLike[i]);
    }
  }
  return array;
}
function find(array, predicate) {
  for (var i = 0; i < array.length; i += 1) {
    var item = array[i];
    if (predicate(item, i)) {
      return item;
    }
  }
  return undefined;
}
function findLast(array, predicate) {
  for (var i = array.length - 1; i >= 0; i -= 1) {
    var item = array[i];
    if (predicate(item, i, array)) {
      return item;
    }
  }
  return undefined;
}
function forEach(list, callback) {
  Array.prototype.forEach.call(list, callback);
}
function objectValues(object) {
  return Object.keys(object).map(function (key) {
    return object[key];
  });
}
function objectEntries(object) {
  return Object.keys(object).map(function (key) {
    return [key, object[key]];
  });
}
function startsWith(candidate, search) {
  return candidate.slice(0, search.length) === search;
}
function endsWith(candidate, search) {
  return candidate.slice(-search.length) === search;
}
function elementMatches(element, selector) {
  if (element.matches) {
    return element.matches(selector);
  }
  // IE11 support
  if (element.msMatchesSelector) {
    return element.msMatchesSelector(selector);
  }
  return false;
}
// https://github.com/jquery/jquery/blob/a684e6ba836f7c553968d7d026ed7941e1a612d8/src/selector/escapeSelector.js
function cssEscape(str) {
  if (window.CSS && window.CSS.escape) {
    return window.CSS.escape(str);
  }
  // eslint-disable-next-line no-control-regex
  return str.replace(/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g, function (ch, asCodePoint) {
    if (asCodePoint) {
      // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
      if (ch === '\0') {
        return '\uFFFD';
      }
      // Control characters and (dependent upon position) numbers get escaped as code points
      return "".concat(ch.slice(0, -1), "\\").concat(ch.charCodeAt(ch.length - 1).toString(16), " ");
    }
    // Other potentially-special ASCII characters get backslash-escaped
    return "\\".concat(ch);
  });
}
function assign(target) {
  var toAssign = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    toAssign[_i - 1] = arguments[_i];
  }
  toAssign.forEach(function (source) {
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  });
  return target;
}
//# sourceMappingURL=polyfills.js.map

/***/ }),

/***/ 908493:
/*!*****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/responseUtils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isServerError": () => (/* binding */ isServerError),
/* harmony export */   "tryToClone": () => (/* binding */ tryToClone)
/* harmony export */ });
function isServerError(status) {
  return status >= 500;
}
function tryToClone(response) {
  try {
    return response.clone();
  } catch (e) {
    // clone can throw if the response has already been used by another instrumentation or is disturbed
    return;
  }
}
//# sourceMappingURL=responseUtils.js.map

/***/ }),

/***/ 347666:
/*!***************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/stringUtils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "findCommaSeparatedValue": () => (/* binding */ findCommaSeparatedValue),
/* harmony export */   "generateUUID": () => (/* binding */ generateUUID),
/* harmony export */   "safeTruncate": () => (/* binding */ safeTruncate)
/* harmony export */ });
/**
 * UUID v4
 * from https://gist.github.com/jed/982883
 */
function generateUUID(placeholder) {
  return placeholder ?
  // eslint-disable-next-line  no-bitwise
  (parseInt(placeholder, 10) ^ Math.random() * 16 >> parseInt(placeholder, 10) / 4).toString(16) : "".concat(1e7, "-").concat(1e3, "-").concat(4e3, "-").concat(8e3, "-").concat(1e11).replace(/[018]/g, generateUUID);
}
function findCommaSeparatedValue(rawString, name) {
  var regex = new RegExp("(?:^|;)\\s*".concat(name, "\\s*=\\s*([^;]+)"));
  var matches = regex.exec(rawString);
  return matches ? matches[1] : undefined;
}
function safeTruncate(candidate, length, suffix) {
  if (suffix === void 0) {
    suffix = '';
  }
  var lastChar = candidate.charCodeAt(length - 1);
  var isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff;
  var correctedLength = isLastCharSurrogatePair ? length + 1 : length;
  if (candidate.length <= correctedLength) {
    return candidate;
  }
  return "".concat(candidate.slice(0, correctedLength)).concat(suffix);
}
//# sourceMappingURL=stringUtils.js.map

/***/ }),

/***/ 573647:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/timeUtils.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ONE_DAY": () => (/* binding */ ONE_DAY),
/* harmony export */   "ONE_HOUR": () => (/* binding */ ONE_HOUR),
/* harmony export */   "ONE_MINUTE": () => (/* binding */ ONE_MINUTE),
/* harmony export */   "ONE_SECOND": () => (/* binding */ ONE_SECOND),
/* harmony export */   "ONE_YEAR": () => (/* binding */ ONE_YEAR),
/* harmony export */   "addDuration": () => (/* binding */ addDuration),
/* harmony export */   "clocksNow": () => (/* binding */ clocksNow),
/* harmony export */   "clocksOrigin": () => (/* binding */ clocksOrigin),
/* harmony export */   "currentDrift": () => (/* binding */ currentDrift),
/* harmony export */   "dateNow": () => (/* binding */ dateNow),
/* harmony export */   "elapsed": () => (/* binding */ elapsed),
/* harmony export */   "getRelativeTime": () => (/* binding */ getRelativeTime),
/* harmony export */   "getTimeStamp": () => (/* binding */ getTimeStamp),
/* harmony export */   "looksLikeRelativeTime": () => (/* binding */ looksLikeRelativeTime),
/* harmony export */   "relativeNow": () => (/* binding */ relativeNow),
/* harmony export */   "relativeToClocks": () => (/* binding */ relativeToClocks),
/* harmony export */   "resetNavigationStart": () => (/* binding */ resetNavigationStart),
/* harmony export */   "timeStampNow": () => (/* binding */ timeStampNow),
/* harmony export */   "toServerDuration": () => (/* binding */ toServerDuration)
/* harmony export */ });
/* harmony import */ var _numberUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberUtils */ 159127);

var ONE_SECOND = 1000;
var ONE_MINUTE = 60 * ONE_SECOND;
var ONE_HOUR = 60 * ONE_MINUTE;
var ONE_DAY = 24 * ONE_HOUR;
var ONE_YEAR = 365 * ONE_DAY;
function relativeToClocks(relative) {
  return {
    relative: relative,
    timeStamp: getCorrectedTimeStamp(relative)
  };
}
function getCorrectedTimeStamp(relativeTime) {
  var correctedOrigin = dateNow() - performance.now();
  // apply correction only for positive drift
  if (correctedOrigin > getNavigationStart()) {
    return Math.round(addDuration(correctedOrigin, relativeTime));
  }
  return getTimeStamp(relativeTime);
}
function currentDrift() {
  return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now()));
}
function toServerDuration(duration) {
  if (!(0,_numberUtils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(duration)) {
    return duration;
  }
  return (0,_numberUtils__WEBPACK_IMPORTED_MODULE_0__.round)(duration * 1e6, 0);
}
function dateNow() {
  // Do not use `Date.now` because sometimes websites are wrongly "polyfilling" it. For example, we
  // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date
  // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this
  // case ourselves.
  // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16
  return new Date().getTime();
}
function timeStampNow() {
  return dateNow();
}
function relativeNow() {
  return performance.now();
}
function clocksNow() {
  return {
    relative: relativeNow(),
    timeStamp: timeStampNow()
  };
}
function clocksOrigin() {
  return {
    relative: 0,
    timeStamp: getNavigationStart()
  };
}
function elapsed(start, end) {
  return end - start;
}
function addDuration(a, b) {
  return a + b;
}
/**
 * Get the time since the navigation was started.
 *
 * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual
 * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.
 * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926
 */
function getRelativeTime(timestamp) {
  return timestamp - getNavigationStart();
}
function getTimeStamp(relativeTime) {
  return Math.round(addDuration(getNavigationStart(), relativeTime));
}
function looksLikeRelativeTime(time) {
  return time < ONE_YEAR;
}
/**
 * Navigation start slightly change on some rare cases
 */
var navigationStart;
function getNavigationStart() {
  if (navigationStart === undefined) {
    navigationStart = performance.timing.navigationStart;
  }
  return navigationStart;
}
function resetNavigationStart() {
  navigationStart = undefined;
}
//# sourceMappingURL=timeUtils.js.map

/***/ }),

/***/ 938993:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/typeUtils.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getType": () => (/* binding */ getType)
/* harmony export */ });
/**
 * Similar to `typeof`, but distinguish plain objects from `null` and arrays
 */
function getType(value) {
  if (value === null) {
    return 'null';
  }
  if (Array.isArray(value)) {
    return 'array';
  }
  return typeof value;
}
//# sourceMappingURL=typeUtils.js.map

/***/ }),

/***/ 77615:
/*!***************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/utils/urlPolyfill.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildUrl": () => (/* binding */ buildUrl),
/* harmony export */   "getHash": () => (/* binding */ getHash),
/* harmony export */   "getLinkElementOrigin": () => (/* binding */ getLinkElementOrigin),
/* harmony export */   "getLocationOrigin": () => (/* binding */ getLocationOrigin),
/* harmony export */   "getOrigin": () => (/* binding */ getOrigin),
/* harmony export */   "getPathName": () => (/* binding */ getPathName),
/* harmony export */   "getSearch": () => (/* binding */ getSearch),
/* harmony export */   "haveSameOrigin": () => (/* binding */ haveSameOrigin),
/* harmony export */   "isValidUrl": () => (/* binding */ isValidUrl),
/* harmony export */   "normalizeUrl": () => (/* binding */ normalizeUrl)
/* harmony export */ });
/* harmony import */ var _serialisation_jsonStringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../serialisation/jsonStringify */ 226590);

function normalizeUrl(url) {
  return buildUrl(url, getLocationOrigin()).href;
}
function isValidUrl(url) {
  try {
    return !!buildUrl(url);
  } catch (_a) {
    return false;
  }
}
function haveSameOrigin(url1, url2) {
  return getOrigin(url1) === getOrigin(url2);
}
function getOrigin(url) {
  return getLinkElementOrigin(buildUrl(url));
}
function getPathName(url) {
  var pathname = buildUrl(url).pathname;
  return pathname[0] === '/' ? pathname : "/".concat(pathname);
}
function getSearch(url) {
  return buildUrl(url).search;
}
function getHash(url) {
  return buildUrl(url).hash;
}
function buildUrl(url, base) {
  var supportedURL = getSupportedUrl();
  if (supportedURL) {
    try {
      return base !== undefined ? new supportedURL(url, base) : new supportedURL(url);
    } catch (error) {
      throw new Error("Failed to construct URL: ".concat(String(error), " ").concat((0,_serialisation_jsonStringify__WEBPACK_IMPORTED_MODULE_0__.jsonStringify)({
        url: url,
        base: base
      })));
    }
  }
  if (base === undefined && !/:/.test(url)) {
    throw new Error("Invalid URL: '".concat(url, "'"));
  }
  var doc = document;
  var anchorElement = doc.createElement('a');
  if (base !== undefined) {
    doc = document.implementation.createHTMLDocument('');
    var baseElement = doc.createElement('base');
    baseElement.href = base;
    doc.head.appendChild(baseElement);
    doc.body.appendChild(anchorElement);
  }
  anchorElement.href = url;
  return anchorElement;
}
var originalURL = URL;
var isURLSupported;
function getSupportedUrl() {
  if (isURLSupported === undefined) {
    try {
      var url = new originalURL('http://test/path');
      isURLSupported = url.href === 'http://test/path';
    } catch (_a) {
      isURLSupported = false;
    }
  }
  return isURLSupported ? originalURL : undefined;
}
function getLocationOrigin() {
  return getLinkElementOrigin(window.location);
}
/**
 * IE fallback
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/origin
 */
function getLinkElementOrigin(element) {
  if (element.origin) {
    return element.origin;
  }
  var sanitizedHost = element.host.replace(/(:80|:443)$/, '');
  return "".concat(element.protocol, "//").concat(sanitizedHost);
}
//# sourceMappingURL=urlPolyfill.js.map

/***/ }),

/***/ 712530:
/*!**********************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/tools/valueHistory.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CLEAR_OLD_VALUES_INTERVAL": () => (/* binding */ CLEAR_OLD_VALUES_INTERVAL),
/* harmony export */   "ValueHistory": () => (/* binding */ ValueHistory)
/* harmony export */ });
/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timer */ 631128);
/* harmony import */ var _utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/timeUtils */ 573647);


var END_OF_TIMES = Infinity;
var CLEAR_OLD_VALUES_INTERVAL = _utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_MINUTE;
/**
 * Store and keep track of values spans. This whole class assumes that values are added in
 * chronological order (i.e. all entries have an increasing start time).
 */
var ValueHistory = /** @class */function () {
  function ValueHistory(expireDelay) {
    var _this = this;
    this.expireDelay = expireDelay;
    this.entries = [];
    this.clearOldValuesInterval = (0,_timer__WEBPACK_IMPORTED_MODULE_1__.setInterval)(function () {
      return _this.clearOldValues();
    }, CLEAR_OLD_VALUES_INTERVAL);
  }
  /**
   * Add a value to the history associated with a start time. Returns a reference to this newly
   * added entry that can be removed or closed.
   */
  ValueHistory.prototype.add = function (value, startTime) {
    var _this = this;
    var entry = {
      value: value,
      startTime: startTime,
      endTime: END_OF_TIMES,
      remove: function () {
        var index = _this.entries.indexOf(entry);
        if (index >= 0) {
          _this.entries.splice(index, 1);
        }
      },
      close: function (endTime) {
        entry.endTime = endTime;
      }
    };
    this.entries.unshift(entry);
    return entry;
  };
  /**
   * Return the latest value that was active during `startTime`, or the currently active value
   * if no `startTime` is provided. This method assumes that entries are not overlapping.
   */
  ValueHistory.prototype.find = function (startTime) {
    if (startTime === void 0) {
      startTime = END_OF_TIMES;
    }
    for (var _i = 0, _a = this.entries; _i < _a.length; _i++) {
      var entry = _a[_i];
      if (entry.startTime <= startTime) {
        if (startTime <= entry.endTime) {
          return entry.value;
        }
        break;
      }
    }
  };
  /**
   * Helper function to close the currently active value, if any. This method assumes that entries
   * are not overlapping.
   */
  ValueHistory.prototype.closeActive = function (endTime) {
    var latestEntry = this.entries[0];
    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {
      latestEntry.close(endTime);
    }
  };
  /**
   * Return all values that were active during `startTime`, or all currently active values if no
   * `startTime` is provided.
   */
  ValueHistory.prototype.findAll = function (startTime) {
    if (startTime === void 0) {
      startTime = END_OF_TIMES;
    }
    return this.entries.filter(function (entry) {
      return entry.startTime <= startTime && startTime <= entry.endTime;
    }).map(function (entry) {
      return entry.value;
    });
  };
  /**
   * Remove all entries from this collection.
   */
  ValueHistory.prototype.reset = function () {
    this.entries = [];
  };
  /**
   * Stop internal garbage collection of past entries.
   */
  ValueHistory.prototype.stop = function () {
    (0,_timer__WEBPACK_IMPORTED_MODULE_1__.clearInterval)(this.clearOldValuesInterval);
  };
  ValueHistory.prototype.clearOldValues = function () {
    var oldTimeThreshold = (0,_utils_timeUtils__WEBPACK_IMPORTED_MODULE_0__.relativeNow)() - this.expireDelay;
    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {
      this.entries.pop();
    }
  };
  return ValueHistory;
}();

//# sourceMappingURL=valueHistory.js.map

/***/ }),

/***/ 290223:
/*!*******************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/transport/batch.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Batch": () => (/* binding */ Batch)
/* harmony export */ });
/* harmony import */ var _tools_display__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/display */ 700959);
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/utils/polyfills */ 777760);
/* harmony import */ var _browser_pageExitObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../browser/pageExitObservable */ 37215);
/* harmony import */ var _tools_utils_byteUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/utils/byteUtils */ 85010);
/* harmony import */ var _tools_serialisation_jsonStringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tools/serialisation/jsonStringify */ 226590);





var Batch = /** @class */function () {
  function Batch(request, flushController, messageBytesLimit) {
    var _this = this;
    this.request = request;
    this.flushController = flushController;
    this.messageBytesLimit = messageBytesLimit;
    this.pushOnlyBuffer = [];
    this.upsertBuffer = {};
    this.flushController.flushObservable.subscribe(function (event) {
      return _this.flush(event);
    });
  }
  Batch.prototype.add = function (message) {
    this.addOrUpdate(message);
  };
  Batch.prototype.upsert = function (message, key) {
    this.addOrUpdate(message, key);
  };
  Batch.prototype.flush = function (event) {
    var messages = this.pushOnlyBuffer.concat((0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_0__.objectValues)(this.upsertBuffer));
    this.pushOnlyBuffer = [];
    this.upsertBuffer = {};
    var payload = {
      data: messages.join('\n'),
      bytesCount: event.bytesCount,
      flushReason: event.reason
    };
    if ((0,_browser_pageExitObservable__WEBPACK_IMPORTED_MODULE_1__.isPageExitReason)(event.reason)) {
      this.request.sendOnExit(payload);
    } else {
      this.request.send(payload);
    }
  };
  Batch.prototype.addOrUpdate = function (message, key) {
    var _a = this.process(message),
      processedMessage = _a.processedMessage,
      messageBytesCount = _a.messageBytesCount;
    if (messageBytesCount >= this.messageBytesLimit) {
      _tools_display__WEBPACK_IMPORTED_MODULE_2__.display.warn("Discarded a message whose size was bigger than the maximum allowed size ".concat(this.messageBytesLimit, "KB."));
      return;
    }
    if (this.hasMessageFor(key)) {
      this.remove(key);
    }
    this.push(processedMessage, messageBytesCount, key);
  };
  Batch.prototype.process = function (message) {
    var processedMessage = (0,_tools_serialisation_jsonStringify__WEBPACK_IMPORTED_MODULE_3__.jsonStringify)(message);
    var messageBytesCount = (0,_tools_utils_byteUtils__WEBPACK_IMPORTED_MODULE_4__.computeBytesCount)(processedMessage);
    return {
      processedMessage: processedMessage,
      messageBytesCount: messageBytesCount
    };
  };
  Batch.prototype.push = function (processedMessage, messageBytesCount, key) {
    // If there are other messages, a '\n' will be added at serialization
    var separatorBytesCount = this.flushController.messagesCount > 0 ? 1 : 0;
    this.flushController.notifyBeforeAddMessage(messageBytesCount + separatorBytesCount);
    if (key !== undefined) {
      this.upsertBuffer[key] = processedMessage;
    } else {
      this.pushOnlyBuffer.push(processedMessage);
    }
    this.flushController.notifyAfterAddMessage();
  };
  Batch.prototype.remove = function (key) {
    var removedMessage = this.upsertBuffer[key];
    delete this.upsertBuffer[key];
    var messageBytesCount = (0,_tools_utils_byteUtils__WEBPACK_IMPORTED_MODULE_4__.computeBytesCount)(removedMessage);
    // If there are other messages, a '\n' will be added at serialization
    var separatorBytesCount = this.flushController.messagesCount > 1 ? 1 : 0;
    this.flushController.notifyAfterRemoveMessage(messageBytesCount + separatorBytesCount);
  };
  Batch.prototype.hasMessageFor = function (key) {
    return key !== undefined && this.upsertBuffer[key] !== undefined;
  };
  return Batch;
}();

//# sourceMappingURL=batch.js.map

/***/ }),

/***/ 146903:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/transport/eventBridge.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "canUseEventBridge": () => (/* binding */ canUseEventBridge),
/* harmony export */   "getEventBridge": () => (/* binding */ getEventBridge)
/* harmony export */ });
/* harmony import */ var _tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/utils/polyfills */ 777760);
/* harmony import */ var _tools_getGlobalObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/getGlobalObject */ 909428);


function getEventBridge() {
  var eventBridgeGlobal = getEventBridgeGlobal();
  if (!eventBridgeGlobal) {
    return;
  }
  return {
    getAllowedWebViewHosts: function () {
      return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts());
    },
    send: function (eventType, event) {
      eventBridgeGlobal.send(JSON.stringify({
        eventType: eventType,
        event: event
      }));
    }
  };
}
function canUseEventBridge(currentHost) {
  var _a;
  if (currentHost === void 0) {
    currentHost = (_a = (0,_tools_getGlobalObject__WEBPACK_IMPORTED_MODULE_0__.getGlobalObject)().location) === null || _a === void 0 ? void 0 : _a.hostname;
  }
  var bridge = getEventBridge();
  return !!bridge && bridge.getAllowedWebViewHosts().some(function (allowedHost) {
    return currentHost === allowedHost || (0,_tools_utils_polyfills__WEBPACK_IMPORTED_MODULE_1__.endsWith)(currentHost, ".".concat(allowedHost));
  });
}
function getEventBridgeGlobal() {
  return (0,_tools_getGlobalObject__WEBPACK_IMPORTED_MODULE_0__.getGlobalObject)().DatadogEventBridge;
}
//# sourceMappingURL=eventBridge.js.map

/***/ }),

/***/ 886794:
/*!*****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/transport/flushController.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFlushController": () => (/* binding */ createFlushController)
/* harmony export */ });
/* harmony import */ var _tools_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/observable */ 32189);
/* harmony import */ var _tools_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/timer */ 631128);


function createFlushController(_a) {
  var messagesLimit = _a.messagesLimit,
    bytesLimit = _a.bytesLimit,
    durationLimit = _a.durationLimit,
    pageExitObservable = _a.pageExitObservable;
  var flushObservable = new _tools_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
  pageExitObservable.subscribe(function (event) {
    return flush(event.reason);
  });
  var currentBytesCount = 0;
  var currentMessagesCount = 0;
  function flush(flushReason) {
    if (currentMessagesCount === 0) {
      return;
    }
    var messagesCount = currentMessagesCount;
    var bytesCount = currentBytesCount;
    currentMessagesCount = 0;
    currentBytesCount = 0;
    cancelDurationLimitTimeout();
    flushObservable.notify({
      reason: flushReason,
      messagesCount: messagesCount,
      bytesCount: bytesCount
    });
  }
  var durationLimitTimeoutId;
  function scheduleDurationLimitTimeout() {
    if (durationLimitTimeoutId === undefined) {
      durationLimitTimeoutId = (0,_tools_timer__WEBPACK_IMPORTED_MODULE_1__.setTimeout)(function () {
        flush('duration_limit');
      }, durationLimit);
    }
  }
  function cancelDurationLimitTimeout() {
    (0,_tools_timer__WEBPACK_IMPORTED_MODULE_1__.clearTimeout)(durationLimitTimeoutId);
    durationLimitTimeoutId = undefined;
  }
  return {
    flushObservable: flushObservable,
    get messagesCount() {
      return currentMessagesCount;
    },
    notifyBeforeAddMessage: function (messageBytesCount) {
      if (currentBytesCount + messageBytesCount >= bytesLimit) {
        flush('bytes_limit');
      }
      // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no message
      // was added yet and `notifyAfterAddMessage` is called asynchronously, we still want to notify when a
      // flush is needed (for example on page exit).
      currentMessagesCount += 1;
      currentBytesCount += messageBytesCount;
      scheduleDurationLimitTimeout();
    },
    notifyAfterAddMessage: function () {
      if (currentMessagesCount >= messagesLimit) {
        flush('messages_limit');
      } else if (currentBytesCount >= bytesLimit) {
        flush('bytes_limit');
      }
    },
    notifyAfterRemoveMessage: function (messageBytesCount) {
      currentBytesCount -= messageBytesCount;
      currentMessagesCount -= 1;
      if (currentMessagesCount === 0) {
        cancelDurationLimitTimeout();
      }
    }
  };
}
//# sourceMappingURL=flushController.js.map

/***/ }),

/***/ 445260:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/transport/httpRequest.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createHttpRequest": () => (/* binding */ createHttpRequest),
/* harmony export */   "fetchKeepAliveStrategy": () => (/* binding */ fetchKeepAliveStrategy),
/* harmony export */   "sendXHR": () => (/* binding */ sendXHR)
/* harmony export */ });
/* harmony import */ var _domain_telemetry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domain/telemetry */ 931942);
/* harmony import */ var _tools_monitor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/monitor */ 267830);
/* harmony import */ var _browser_addEventListener__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../browser/addEventListener */ 822006);
/* harmony import */ var _sendWithRetryStrategy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sendWithRetryStrategy */ 433683);




function createHttpRequest(endpointBuilder, bytesLimit, reportError) {
  var retryState = (0,_sendWithRetryStrategy__WEBPACK_IMPORTED_MODULE_0__.newRetryState)();
  var sendStrategyForRetry = function (payload, onResponse) {
    return fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse);
  };
  return {
    send: function (payload) {
      (0,_sendWithRetryStrategy__WEBPACK_IMPORTED_MODULE_0__.sendWithRetryStrategy)(payload, retryState, sendStrategyForRetry, endpointBuilder.endpointType, reportError);
    },
    /**
     * Since fetch keepalive behaves like regular fetch on Firefox,
     * keep using sendBeaconStrategy on exit
     */
    sendOnExit: function (payload) {
      sendBeaconStrategy(endpointBuilder, bytesLimit, payload);
    }
  };
}
function sendBeaconStrategy(endpointBuilder, bytesLimit, _a) {
  var data = _a.data,
    bytesCount = _a.bytesCount,
    flushReason = _a.flushReason;
  var canUseBeacon = !!navigator.sendBeacon && bytesCount < bytesLimit;
  if (canUseBeacon) {
    try {
      var beaconUrl = endpointBuilder.build('beacon', flushReason);
      var isQueued = navigator.sendBeacon(beaconUrl, data);
      if (isQueued) {
        return;
      }
    } catch (e) {
      reportBeaconError(e);
    }
  }
  var xhrUrl = endpointBuilder.build('xhr', flushReason);
  sendXHR(xhrUrl, data);
}
var hasReportedBeaconError = false;
function reportBeaconError(e) {
  if (!hasReportedBeaconError) {
    hasReportedBeaconError = true;
    (0,_domain_telemetry__WEBPACK_IMPORTED_MODULE_1__.addTelemetryError)(e);
  }
}
function fetchKeepAliveStrategy(endpointBuilder, bytesLimit, _a, onResponse) {
  var data = _a.data,
    bytesCount = _a.bytesCount,
    flushReason = _a.flushReason,
    retry = _a.retry;
  var canUseKeepAlive = isKeepAliveSupported() && bytesCount < bytesLimit;
  if (canUseKeepAlive) {
    var fetchUrl = endpointBuilder.build('fetch', flushReason, retry);
    fetch(fetchUrl, {
      method: 'POST',
      body: data,
      keepalive: true,
      mode: 'cors'
    }).then((0,_tools_monitor__WEBPACK_IMPORTED_MODULE_2__.monitor)(function (response) {
      return onResponse === null || onResponse === void 0 ? void 0 : onResponse({
        status: response.status,
        type: response.type
      });
    }), (0,_tools_monitor__WEBPACK_IMPORTED_MODULE_2__.monitor)(function () {
      var xhrUrl = endpointBuilder.build('xhr', flushReason, retry);
      // failed to queue the request
      sendXHR(xhrUrl, data, onResponse);
    }));
  } else {
    var xhrUrl = endpointBuilder.build('xhr', flushReason, retry);
    sendXHR(xhrUrl, data, onResponse);
  }
}
function isKeepAliveSupported() {
  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors
  try {
    return window.Request && 'keepalive' in new Request('http://a');
  } catch (_a) {
    return false;
  }
}
function sendXHR(url, data, onResponse) {
  var request = new XMLHttpRequest();
  request.open('POST', url, true);
  (0,_browser_addEventListener__WEBPACK_IMPORTED_MODULE_3__.addEventListener)(request, 'loadend', function () {
    onResponse === null || onResponse === void 0 ? void 0 : onResponse({
      status: request.status
    });
  }, {
    // prevent multiple onResponse callbacks
    // if the xhr instance is reused by a third party
    once: true
  });
  request.send(data);
}
//# sourceMappingURL=httpRequest.js.map

/***/ }),

/***/ 433683:
/*!***********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/transport/sendWithRetryStrategy.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "INITIAL_BACKOFF_TIME": () => (/* binding */ INITIAL_BACKOFF_TIME),
/* harmony export */   "MAX_BACKOFF_TIME": () => (/* binding */ MAX_BACKOFF_TIME),
/* harmony export */   "MAX_ONGOING_BYTES_COUNT": () => (/* binding */ MAX_ONGOING_BYTES_COUNT),
/* harmony export */   "MAX_ONGOING_REQUESTS": () => (/* binding */ MAX_ONGOING_REQUESTS),
/* harmony export */   "MAX_QUEUE_BYTES_COUNT": () => (/* binding */ MAX_QUEUE_BYTES_COUNT),
/* harmony export */   "newRetryState": () => (/* binding */ newRetryState),
/* harmony export */   "sendWithRetryStrategy": () => (/* binding */ sendWithRetryStrategy)
/* harmony export */ });
/* harmony import */ var _tools_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/timer */ 631128);
/* harmony import */ var _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/utils/timeUtils */ 573647);
/* harmony import */ var _domain_error_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../domain/error/error */ 803679);
/* harmony import */ var _tools_utils_byteUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/utils/byteUtils */ 85010);
/* harmony import */ var _tools_utils_responseUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/utils/responseUtils */ 908493);





var MAX_ONGOING_BYTES_COUNT = 80 * _tools_utils_byteUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_KIBI_BYTE;
var MAX_ONGOING_REQUESTS = 32;
var MAX_QUEUE_BYTES_COUNT = 3 * _tools_utils_byteUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_MEBI_BYTE;
var MAX_BACKOFF_TIME = _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_1__.ONE_MINUTE;
var INITIAL_BACKOFF_TIME = _tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_1__.ONE_SECOND;
function sendWithRetryStrategy(payload, state, sendStrategy, endpointType, reportError) {
  if (state.transportStatus === 0 /* TransportStatus.UP */ && state.queuedPayloads.size() === 0 && state.bandwidthMonitor.canHandle(payload)) {
    send(payload, state, sendStrategy, {
      onSuccess: function () {
        return retryQueuedPayloads(0 /* RetryReason.AFTER_SUCCESS */, state, sendStrategy, endpointType, reportError);
      },
      onFailure: function () {
        state.queuedPayloads.enqueue(payload);
        scheduleRetry(state, sendStrategy, endpointType, reportError);
      }
    });
  } else {
    state.queuedPayloads.enqueue(payload);
  }
}
function scheduleRetry(state, sendStrategy, endpointType, reportError) {
  if (state.transportStatus !== 2 /* TransportStatus.DOWN */) {
    return;
  }
  (0,_tools_timer__WEBPACK_IMPORTED_MODULE_2__.setTimeout)(function () {
    var payload = state.queuedPayloads.first();
    send(payload, state, sendStrategy, {
      onSuccess: function () {
        state.queuedPayloads.dequeue();
        state.currentBackoffTime = INITIAL_BACKOFF_TIME;
        retryQueuedPayloads(1 /* RetryReason.AFTER_RESUME */, state, sendStrategy, endpointType, reportError);
      },
      onFailure: function () {
        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2);
        scheduleRetry(state, sendStrategy, endpointType, reportError);
      }
    });
  }, state.currentBackoffTime);
}
function send(payload, state, sendStrategy, _a) {
  var onSuccess = _a.onSuccess,
    onFailure = _a.onFailure;
  state.bandwidthMonitor.add(payload);
  sendStrategy(payload, function (response) {
    state.bandwidthMonitor.remove(payload);
    if (!shouldRetryRequest(response)) {
      state.transportStatus = 0 /* TransportStatus.UP */;
      onSuccess();
    } else {
      // do not consider transport down if another ongoing request could succeed
      state.transportStatus = state.bandwidthMonitor.ongoingRequestCount > 0 ? 1 /* TransportStatus.FAILURE_DETECTED */ : 2 /* TransportStatus.DOWN */;
      payload.retry = {
        count: payload.retry ? payload.retry.count + 1 : 1,
        lastFailureStatus: response.status
      };
      onFailure();
    }
  });
}
function retryQueuedPayloads(reason, state, sendStrategy, endpointType, reportError) {
  if (reason === 0 /* RetryReason.AFTER_SUCCESS */ && state.queuedPayloads.isFull() && !state.queueFullReported) {
    reportError({
      message: "Reached max ".concat(endpointType, " events size queued for upload: ").concat(MAX_QUEUE_BYTES_COUNT / _tools_utils_byteUtils__WEBPACK_IMPORTED_MODULE_0__.ONE_MEBI_BYTE, "MiB"),
      source: _domain_error_error__WEBPACK_IMPORTED_MODULE_3__.ErrorSource.AGENT,
      startClocks: (0,_tools_utils_timeUtils__WEBPACK_IMPORTED_MODULE_1__.clocksNow)()
    });
    state.queueFullReported = true;
  }
  var previousQueue = state.queuedPayloads;
  state.queuedPayloads = newPayloadQueue();
  while (previousQueue.size() > 0) {
    sendWithRetryStrategy(previousQueue.dequeue(), state, sendStrategy, endpointType, reportError);
  }
}
function shouldRetryRequest(response) {
  return response.type !== 'opaque' && (response.status === 0 && !navigator.onLine || response.status === 408 || response.status === 429 || (0,_tools_utils_responseUtils__WEBPACK_IMPORTED_MODULE_4__.isServerError)(response.status));
}
function newRetryState() {
  return {
    transportStatus: 0 /* TransportStatus.UP */,
    currentBackoffTime: INITIAL_BACKOFF_TIME,
    bandwidthMonitor: newBandwidthMonitor(),
    queuedPayloads: newPayloadQueue(),
    queueFullReported: false
  };
}
function newPayloadQueue() {
  var queue = [];
  return {
    bytesCount: 0,
    enqueue: function (payload) {
      if (this.isFull()) {
        return;
      }
      queue.push(payload);
      this.bytesCount += payload.bytesCount;
    },
    first: function () {
      return queue[0];
    },
    dequeue: function () {
      var payload = queue.shift();
      if (payload) {
        this.bytesCount -= payload.bytesCount;
      }
      return payload;
    },
    size: function () {
      return queue.length;
    },
    isFull: function () {
      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT;
    }
  };
}
function newBandwidthMonitor() {
  return {
    ongoingRequestCount: 0,
    ongoingByteCount: 0,
    canHandle: function (payload) {
      return this.ongoingRequestCount === 0 || this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT && this.ongoingRequestCount < MAX_ONGOING_REQUESTS;
    },
    add: function (payload) {
      this.ongoingRequestCount += 1;
      this.ongoingByteCount += payload.bytesCount;
    },
    remove: function (payload) {
      this.ongoingRequestCount -= 1;
      this.ongoingByteCount -= payload.bytesCount;
    }
  };
}
//# sourceMappingURL=sendWithRetryStrategy.js.map

/***/ }),

/***/ 504771:
/*!***********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-core/esm/transport/startBatchWithReplica.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startBatchWithReplica": () => (/* binding */ startBatchWithReplica)
/* harmony export */ });
/* harmony import */ var _batch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./batch */ 290223);
/* harmony import */ var _httpRequest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./httpRequest */ 445260);
/* harmony import */ var _flushController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flushController */ 886794);



function startBatchWithReplica(configuration, endpoint, reportError, pageExitObservable, replicaEndpoint) {
  var primaryBatch = createBatch(endpoint);
  var replicaBatch;
  if (replicaEndpoint) {
    replicaBatch = createBatch(replicaEndpoint);
  }
  function createBatch(endpointBuilder) {
    return new _batch__WEBPACK_IMPORTED_MODULE_0__.Batch((0,_httpRequest__WEBPACK_IMPORTED_MODULE_1__.createHttpRequest)(endpointBuilder, configuration.batchBytesLimit, reportError), (0,_flushController__WEBPACK_IMPORTED_MODULE_2__.createFlushController)({
      messagesLimit: configuration.batchMessagesLimit,
      bytesLimit: configuration.batchBytesLimit,
      durationLimit: configuration.flushTimeout,
      pageExitObservable: pageExitObservable
    }), configuration.messageBytesLimit);
  }
  return {
    add: function (message, replicated) {
      if (replicated === void 0) {
        replicated = true;
      }
      primaryBatch.add(message);
      if (replicaBatch && replicated) {
        replicaBatch.add(message);
      }
    }
  };
}
//# sourceMappingURL=startBatchWithReplica.js.map

/***/ }),

/***/ 941093:
/*!**********************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/boot/logsPublicApi.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeLogsPublicApi": () => (/* binding */ makeLogsPublicApi)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 238490);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 685776);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 307529);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 464929);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 267830);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 146903);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @datadog/browser-core */ 393968);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @datadog/browser-core */ 595530);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @datadog/browser-core */ 18000);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @datadog/browser-core */ 700959);
/* harmony import */ var _domain_configuration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../domain/configuration */ 528820);
/* harmony import */ var _domain_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domain/logger */ 659604);



function makeLogsPublicApi(startLogsImpl) {
  var isAlreadyInitialized = false;
  var globalContextManager = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.createContextManager)("global context" /* CustomerDataType.GlobalContext */);
  var userContextManager = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.createContextManager)("user" /* CustomerDataType.User */);
  var customLoggers = {};
  var getInternalContextStrategy = function () {
    return undefined;
  };
  var beforeInitLoggerLog = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.BoundedBuffer();
  var handleLogStrategy = function (logsMessage, logger, savedCommonContext, date) {
    if (savedCommonContext === void 0) {
      savedCommonContext = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.deepClone)(buildCommonContext());
    }
    if (date === void 0) {
      date = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.timeStampNow)();
    }
    beforeInitLoggerLog.add(function () {
      return handleLogStrategy(logsMessage, logger, savedCommonContext, date);
    });
  };
  var getInitConfigurationStrategy = function () {
    return undefined;
  };
  var mainLogger = new _domain_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(function () {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    return handleLogStrategy.apply(void 0, params);
  });
  function buildCommonContext() {
    return {
      view: {
        referrer: document.referrer,
        url: window.location.href
      },
      context: globalContextManager.getContext(),
      user: userContextManager.getContext()
    };
  }
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.makePublicApi)({
    logger: mainLogger,
    init: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(function (initConfiguration) {
      var _a;
      // This function should be available, regardless of initialization success.
      getInitConfigurationStrategy = function () {
        return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.deepClone)(initConfiguration);
      };
      if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.canUseEventBridge)()) {
        initConfiguration = overrideInitConfigurationForBridge(initConfiguration);
      }
      if (!canInitLogs(initConfiguration)) {
        return;
      }
      var configuration = (0,_domain_configuration__WEBPACK_IMPORTED_MODULE_0__.validateAndBuildLogsConfiguration)(initConfiguration);
      if (!configuration) {
        return;
      }
      ;
      _a = startLogsImpl(initConfiguration, configuration, buildCommonContext, mainLogger), handleLogStrategy = _a.handleLog, getInternalContextStrategy = _a.getInternalContext;
      beforeInitLoggerLog.drain();
      isAlreadyInitialized = true;
    }),
    /** @deprecated: use getGlobalContext instead */
    getLoggerGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(globalContextManager.get),
    getGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(globalContextManager.getContext),
    /** @deprecated: use setGlobalContext instead */
    setLoggerGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(globalContextManager.set),
    setGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(globalContextManager.setContext),
    /** @deprecated: use setGlobalContextProperty instead */
    addLoggerGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(globalContextManager.add),
    setGlobalContextProperty: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(globalContextManager.setContextProperty),
    /** @deprecated: use removeGlobalContextProperty instead */
    removeLoggerGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(globalContextManager.remove),
    removeGlobalContextProperty: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(globalContextManager.removeContextProperty),
    clearGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(globalContextManager.clearContext),
    createLogger: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(function (name, conf) {
      if (conf === void 0) {
        conf = {};
      }
      customLoggers[name] = new _domain_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          params[_i] = arguments[_i];
        }
        return handleLogStrategy.apply(void 0, params);
      }, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_10__.sanitize)(name) : name, conf.handler, conf.level, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_10__.sanitize)(conf.context) : conf.context);
      return customLoggers[name];
    }),
    getLogger: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(function (name) {
      return customLoggers[name];
    }),
    getInitConfiguration: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(function () {
      return getInitConfigurationStrategy();
    }),
    getInternalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(function (startTime) {
      return getInternalContextStrategy(startTime);
    }),
    setUser: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(function (newUser) {
      if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.checkUser)(newUser)) {
        userContextManager.setContext((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.sanitizeUser)(newUser));
      }
    }),
    getUser: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(userContextManager.getContext),
    setUserProperty: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(function (key, property) {
      var _a;
      var sanitizedProperty = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.sanitizeUser)((_a = {}, _a[key] = property, _a))[key];
      userContextManager.setContextProperty(key, sanitizedProperty);
    }),
    removeUserProperty: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(userContextManager.removeContextProperty),
    clearUser: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(userContextManager.clearContext)
  });
  function overrideInitConfigurationForBridge(initConfiguration) {
    return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__.assign)({}, initConfiguration, {
      clientToken: 'empty'
    });
  }
  function canInitLogs(initConfiguration) {
    if (isAlreadyInitialized) {
      if (!initConfiguration.silentMultipleInit) {
        _datadog_browser_core__WEBPACK_IMPORTED_MODULE_13__.display.error('DD_LOGS is already initialized.');
      }
      return false;
    }
    return true;
  }
}
//# sourceMappingURL=logsPublicApi.js.map

/***/ }),

/***/ 10789:
/*!******************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/boot/startLogs.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startLogs": () => (/* binding */ startLogs)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @datadog/browser-core */ 413464);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @datadog/browser-core */ 803679);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @datadog/browser-core */ 37215);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @datadog/browser-core */ 665627);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @datadog/browser-core */ 146903);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @datadog/browser-core */ 252492);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @datadog/browser-core */ 931942);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @datadog/browser-core */ 504771);
/* harmony import */ var _domain_logsSessionManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../domain/logsSessionManager */ 470315);
/* harmony import */ var _domain_configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domain/configuration */ 528820);
/* harmony import */ var _domain_assembly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../domain/assembly */ 895933);
/* harmony import */ var _domain_logsCollection_console_consoleCollection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../domain/logsCollection/console/consoleCollection */ 316997);
/* harmony import */ var _domain_logsCollection_report_reportCollection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../domain/logsCollection/report/reportCollection */ 150237);
/* harmony import */ var _domain_logsCollection_networkError_networkErrorCollection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../domain/logsCollection/networkError/networkErrorCollection */ 703807);
/* harmony import */ var _domain_logsCollection_runtimeError_runtimeErrorCollection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../domain/logsCollection/runtimeError/runtimeErrorCollection */ 944144);
/* harmony import */ var _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../domain/lifeCycle */ 394456);
/* harmony import */ var _domain_logsCollection_logger_loggerCollection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../domain/logsCollection/logger/loggerCollection */ 950740);
/* harmony import */ var _transport_startLogsBatch__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../transport/startLogsBatch */ 309712);
/* harmony import */ var _transport_startLogsBridge__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../transport/startLogsBridge */ 171482);
/* harmony import */ var _domain_logger__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../domain/logger */ 659604);
/* harmony import */ var _domain_internalContext__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../domain/internalContext */ 720783);














function startLogs(initConfiguration, configuration, buildCommonContext, mainLogger) {
  var lifeCycle = new _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_7__.LifeCycle();
  lifeCycle.subscribe(1 /* LifeCycleEventType.LOG_COLLECTED */, function (log) {
    return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_13__.sendToExtension)('logs', log);
  });
  var reportError = function (error) {
    return lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, {
      rawLogsEvent: {
        message: error.message,
        date: error.startClocks.timeStamp,
        error: {
          origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_14__.ErrorSource.AGENT // Todo: Remove in the next major release
        },

        origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_14__.ErrorSource.AGENT,
        status: _domain_logger__WEBPACK_IMPORTED_MODULE_11__.StatusType.error
      }
    });
  };
  var pageExitObservable = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_15__.createPageExitObservable)();
  var telemetry = startLogsTelemetry(configuration, reportError, pageExitObservable);
  telemetry.setContextProvider(function () {
    var _a, _b, _c, _d, _e, _f;
    return {
      application: {
        id: (_a = (0,_domain_assembly__WEBPACK_IMPORTED_MODULE_2__.getRUMInternalContext)()) === null || _a === void 0 ? void 0 : _a.application_id
      },
      session: {
        id: (_b = session.findTrackedSession()) === null || _b === void 0 ? void 0 : _b.id
      },
      view: {
        id: (_d = (_c = (0,_domain_assembly__WEBPACK_IMPORTED_MODULE_2__.getRUMInternalContext)()) === null || _c === void 0 ? void 0 : _c.view) === null || _d === void 0 ? void 0 : _d.id
      },
      action: {
        id: (_f = (_e = (0,_domain_assembly__WEBPACK_IMPORTED_MODULE_2__.getRUMInternalContext)()) === null || _e === void 0 ? void 0 : _e.user_action) === null || _f === void 0 ? void 0 : _f.id
      }
    };
  });
  (0,_domain_logsCollection_networkError_networkErrorCollection__WEBPACK_IMPORTED_MODULE_5__.startNetworkErrorCollection)(configuration, lifeCycle);
  (0,_domain_logsCollection_runtimeError_runtimeErrorCollection__WEBPACK_IMPORTED_MODULE_6__.startRuntimeErrorCollection)(configuration, lifeCycle);
  (0,_domain_logsCollection_console_consoleCollection__WEBPACK_IMPORTED_MODULE_3__.startConsoleCollection)(configuration, lifeCycle);
  (0,_domain_logsCollection_report_reportCollection__WEBPACK_IMPORTED_MODULE_4__.startReportCollection)(configuration, lifeCycle);
  var handleLog = (0,_domain_logsCollection_logger_loggerCollection__WEBPACK_IMPORTED_MODULE_8__.startLoggerCollection)(lifeCycle).handleLog;
  var session = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_16__.areCookiesAuthorized)(configuration.cookieOptions) && !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_17__.canUseEventBridge)() && !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_18__.willSyntheticsInjectRum)() ? (0,_domain_logsSessionManager__WEBPACK_IMPORTED_MODULE_0__.startLogsSessionManager)(configuration) : (0,_domain_logsSessionManager__WEBPACK_IMPORTED_MODULE_0__.startLogsSessionManagerStub)(configuration);
  (0,_domain_assembly__WEBPACK_IMPORTED_MODULE_2__.startLogsAssembly)(session, configuration, lifeCycle, buildCommonContext, mainLogger, reportError);
  if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_17__.canUseEventBridge)()) {
    (0,_transport_startLogsBatch__WEBPACK_IMPORTED_MODULE_9__.startLogsBatch)(configuration, lifeCycle, reportError, pageExitObservable);
  } else {
    (0,_transport_startLogsBridge__WEBPACK_IMPORTED_MODULE_10__.startLogsBridge)(lifeCycle);
  }
  (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_19__.addTelemetryConfiguration)((0,_domain_configuration__WEBPACK_IMPORTED_MODULE_1__.serializeLogsConfiguration)(initConfiguration));
  var internalContext = (0,_domain_internalContext__WEBPACK_IMPORTED_MODULE_12__.startInternalContext)(session);
  return {
    handleLog: handleLog,
    getInternalContext: internalContext.get
  };
}
function startLogsTelemetry(configuration, reportError, pageExitObservable) {
  var _a;
  var telemetry = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_19__.startTelemetry)("browser-logs-sdk" /* TelemetryService.LOGS */, configuration);
  if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_17__.canUseEventBridge)()) {
    var bridge_1 = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_17__.getEventBridge)();
    telemetry.observable.subscribe(function (event) {
      return bridge_1.send('internal_telemetry', event);
    });
  } else {
    var telemetryBatch_1 = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_20__.startBatchWithReplica)(configuration, configuration.rumEndpointBuilder, reportError, pageExitObservable, (_a = configuration.replica) === null || _a === void 0 ? void 0 : _a.rumEndpointBuilder);
    telemetry.observable.subscribe(function (event) {
      return telemetryBatch_1.add(event, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_19__.isTelemetryReplicationAllowed)(configuration));
    });
  }
  return telemetry;
}
//# sourceMappingURL=startLogs.js.map

/***/ }),

/***/ 895933:
/*!*******************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/domain/assembly.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getRUMInternalContext": () => (/* binding */ getRUMInternalContext),
/* harmony export */   "resetRUMInternalContext": () => (/* binding */ resetRUMInternalContext),
/* harmony export */   "startLogsAssembly": () => (/* binding */ startLogsAssembly)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 853556);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 307529);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 567934);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 803679);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 252492);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 931942);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ 659604);
/* harmony import */ var _logsCollection_logger_loggerCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logsCollection/logger/loggerCollection */ 950740);



function startLogsAssembly(sessionManager, configuration, lifeCycle, buildCommonContext, mainLogger,
// Todo: [RUMF-1230] Remove this parameter in the next major release
reportError) {
  var statusWithCustom = _logger__WEBPACK_IMPORTED_MODULE_0__.STATUSES.concat(['custom']);
  var logRateLimiters = {};
  statusWithCustom.forEach(function (status) {
    logRateLimiters[status] = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.createEventRateLimiter)(status, configuration.eventRateLimiterThreshold, reportError);
  });
  lifeCycle.subscribe(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, function (_a) {
    var _b, _c, _d;
    var rawLogsEvent = _a.rawLogsEvent,
      _e = _a.messageContext,
      messageContext = _e === void 0 ? undefined : _e,
      _f = _a.savedCommonContext,
      savedCommonContext = _f === void 0 ? undefined : _f,
      _g = _a.logger,
      logger = _g === void 0 ? mainLogger : _g;
    var startTime = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.getRelativeTime)(rawLogsEvent.date);
    var session = sessionManager.findTrackedSession(startTime);
    if (!session) {
      return;
    }
    var commonContext = savedCommonContext || buildCommonContext();
    var log = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.combine)({
      service: configuration.service,
      session_id: session.id,
      // Insert user first to allow overrides from global context
      usr: !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.isEmptyObject)(commonContext.user) ? commonContext.user : undefined,
      view: commonContext.view
    }, commonContext.context, getRUMInternalContext(startTime), rawLogsEvent, logger.getContext(), messageContext);
    if (
    // Todo: [RUMF-1230] Move this check to the logger collection in the next major release
    !(0,_logsCollection_logger_loggerCollection__WEBPACK_IMPORTED_MODULE_1__.isAuthorized)(rawLogsEvent.status, _logger__WEBPACK_IMPORTED_MODULE_0__.HandlerType.http, logger) || ((_b = configuration.beforeSend) === null || _b === void 0 ? void 0 : _b.call(configuration, log)) === false || ((_c = log.error) === null || _c === void 0 ? void 0 : _c.origin) !== _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.ErrorSource.AGENT && ((_d = logRateLimiters[log.status]) !== null && _d !== void 0 ? _d : logRateLimiters['custom']).isLimitReached()) {
      return;
    }
    lifeCycle.notify(1 /* LifeCycleEventType.LOG_COLLECTED */, log);
  });
}
var logsSentBeforeRumInjectionTelemetryAdded = false;
function getRUMInternalContext(startTime) {
  var browserWindow = window;
  if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.willSyntheticsInjectRum)()) {
    var context = getInternalContextFromRumGlobal(browserWindow.DD_RUM_SYNTHETICS);
    if (!context && !logsSentBeforeRumInjectionTelemetryAdded) {
      logsSentBeforeRumInjectionTelemetryAdded = true;
      (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.addTelemetryDebug)('Logs sent before RUM is injected by the synthetics worker', {
        testId: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.getSyntheticsTestId)(),
        resultId: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.getSyntheticsResultId)()
      });
    }
    return context;
  }
  return getInternalContextFromRumGlobal(browserWindow.DD_RUM);
  function getInternalContextFromRumGlobal(rumGlobal) {
    if (rumGlobal && rumGlobal.getInternalContext) {
      return rumGlobal.getInternalContext(startTime);
    }
  }
}
function resetRUMInternalContext() {
  logsSentBeforeRumInjectionTelemetryAdded = false;
}
//# sourceMappingURL=assembly.js.map

/***/ }),

/***/ 528820:
/*!************************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/domain/configuration.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT": () => (/* binding */ DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT),
/* harmony export */   "serializeLogsConfiguration": () => (/* binding */ serializeLogsConfiguration),
/* harmony export */   "validateAndBuildForwardOption": () => (/* binding */ validateAndBuildForwardOption),
/* harmony export */   "validateAndBuildLogsConfiguration": () => (/* binding */ validateAndBuildLogsConfiguration)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 85010);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 351540);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 700959);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 888851);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 731920);

/**
 * arbitrary value, byte precision not needed
 */
var DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT = 32 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.ONE_KIBI_BYTE;
function validateAndBuildLogsConfiguration(initConfiguration) {
  var baseConfiguration = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.validateAndBuildConfiguration)(initConfiguration);
  var forwardConsoleLogs = validateAndBuildForwardOption(initConfiguration.forwardConsoleLogs, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.objectValues)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.ConsoleApiName), 'Forward Console Logs');
  var forwardReports = validateAndBuildForwardOption(initConfiguration.forwardReports, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.objectValues)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.RawReportType), 'Forward Reports');
  if (!baseConfiguration || !forwardConsoleLogs || !forwardReports) {
    return;
  }
  if (initConfiguration.forwardErrorsToLogs && !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.includes)(forwardConsoleLogs, _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.ConsoleApiName.error)) {
    forwardConsoleLogs.push(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.ConsoleApiName.error);
  }
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.assign)({
    forwardErrorsToLogs: initConfiguration.forwardErrorsToLogs !== false,
    forwardConsoleLogs: forwardConsoleLogs,
    forwardReports: forwardReports,
    requestErrorResponseLengthLimit: DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT
  }, baseConfiguration);
}
function validateAndBuildForwardOption(option, allowedValues, label) {
  if (option === undefined) {
    return [];
  }
  if (!(option === 'all' || Array.isArray(option) && option.every(function (api) {
    return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.includes)(allowedValues, api);
  }))) {
    _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.display.error("".concat(label, " should be \"all\" or an array with allowed values \"").concat(allowedValues.join('", "'), "\""));
    return;
  }
  return option === 'all' ? allowedValues : (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.removeDuplicates)(option);
}
function serializeLogsConfiguration(configuration) {
  var baseSerializedInitConfiguration = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.serializeConfiguration)(configuration);
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.assign)({
    forward_errors_to_logs: configuration.forwardErrorsToLogs,
    forward_console_logs: configuration.forwardConsoleLogs,
    forward_reports: configuration.forwardReports
  }, baseSerializedInitConfiguration);
}
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ 720783:
/*!**************************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/domain/internalContext.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startInternalContext": () => (/* binding */ startInternalContext)
/* harmony export */ });
function startInternalContext(sessionManager) {
  return {
    get: function (startTime) {
      var trackedSession = sessionManager.findTrackedSession(startTime);
      if (trackedSession) {
        return {
          session_id: trackedSession.id
        };
      }
    }
  };
}
//# sourceMappingURL=internalContext.js.map

/***/ }),

/***/ 394456:
/*!********************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/domain/lifeCycle.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LifeCycle": () => (/* binding */ LifeCycle)
/* harmony export */ });
var LifeCycle = /** @class */function () {
  function LifeCycle() {
    this.callbacks = {};
  }
  LifeCycle.prototype.notify = function (eventType, data) {
    var eventCallbacks = this.callbacks[eventType];
    if (eventCallbacks) {
      eventCallbacks.forEach(function (callback) {
        return callback(data);
      });
    }
  };
  LifeCycle.prototype.subscribe = function (eventType, callback) {
    var _this = this;
    if (!this.callbacks[eventType]) {
      this.callbacks[eventType] = [];
    }
    this.callbacks[eventType].push(callback);
    return {
      unsubscribe: function () {
        _this.callbacks[eventType] = _this.callbacks[eventType].filter(function (other) {
          return callback !== other;
        });
      }
    };
  };
  return LifeCycle;
}();

//# sourceMappingURL=lifeCycle.js.map

/***/ }),

/***/ 659604:
/*!*****************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/domain/logger.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HandlerType": () => (/* binding */ HandlerType),
/* harmony export */   "Logger": () => (/* binding */ Logger),
/* harmony export */   "STATUSES": () => (/* binding */ STATUSES),
/* harmony export */   "StatusType": () => (/* binding */ StatusType)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 238490);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 803679);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 976474);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 393968);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 595530);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 307529);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 267830);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var StatusType = {
  debug: 'debug',
  error: 'error',
  info: 'info',
  warn: 'warn'
};
var HandlerType = {
  console: 'console',
  http: 'http',
  silent: 'silent'
};
var STATUSES = Object.keys(StatusType);
var Logger = /** @class */function () {
  function Logger(handleLogStrategy, name, handlerType, level, loggerContext) {
    if (handlerType === void 0) {
      handlerType = HandlerType.http;
    }
    if (level === void 0) {
      level = StatusType.debug;
    }
    if (loggerContext === void 0) {
      loggerContext = {};
    }
    this.handleLogStrategy = handleLogStrategy;
    this.handlerType = handlerType;
    this.level = level;
    this.contextManager = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.createContextManager)("logger context" /* CustomerDataType.LoggerContext */);
    this.contextManager.set((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.assign)({}, loggerContext, name ? {
      logger: {
        name: name
      }
    } : undefined));
  }
  Logger.prototype.log = function (message, messageContext, status, error) {
    if (status === void 0) {
      status = StatusType.info;
    }
    var errorContext;
    if (status === StatusType.error) {
      // Always add origin if status is error (backward compatibility - Remove in next major)
      errorContext = {
        origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.ErrorSource.LOGGER
      };
    }
    if (error !== undefined && error !== null) {
      var stackTrace = error instanceof Error ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.computeStackTrace)(error) : undefined;
      var rawError = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.computeRawError)({
        stackTrace: stackTrace,
        originalError: error,
        nonErrorPrefix: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.PROVIDED_ERROR_MESSAGE_PREFIX,
        source: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.ErrorSource.LOGGER,
        handling: "handled" /* ErrorHandling.HANDLED */,
        startClocks: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.clocksNow)()
      });
      errorContext = {
        origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.ErrorSource.LOGGER,
        stack: rawError.stack,
        kind: rawError.type,
        message: rawError.message
      };
    }
    var sanitizedMessageContext = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.sanitize)(messageContext) : (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.deepClone)(messageContext);
    var context = errorContext ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.combine)({
      error: errorContext
    }, sanitizedMessageContext) : sanitizedMessageContext;
    this.handleLogStrategy({
      message: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.sanitize)(message) : message,
      context: context,
      status: status
    }, this);
  };
  Logger.prototype.debug = function (message, messageContext, error) {
    this.log(message, messageContext, StatusType.debug, error);
  };
  Logger.prototype.info = function (message, messageContext, error) {
    this.log(message, messageContext, StatusType.info, error);
  };
  Logger.prototype.warn = function (message, messageContext, error) {
    this.log(message, messageContext, StatusType.warn, error);
  };
  Logger.prototype.error = function (message, messageContext, error) {
    this.log(message, messageContext, StatusType.error, error);
  };
  Logger.prototype.setContext = function (context) {
    this.contextManager.set(context);
  };
  Logger.prototype.getContext = function () {
    return this.contextManager.get();
  };
  Logger.prototype.addContext = function (key, value) {
    this.contextManager.add(key, value);
  };
  Logger.prototype.removeContext = function (key) {
    this.contextManager.remove(key);
  };
  Logger.prototype.setHandler = function (handler) {
    this.handlerType = handler;
  };
  Logger.prototype.getHandler = function () {
    return this.handlerType;
  };
  Logger.prototype.setLevel = function (level) {
    this.level = level;
  };
  Logger.prototype.getLevel = function () {
    return this.level;
  };
  __decorate([_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.monitored], Logger.prototype, "log", null);
  return Logger;
}();

//# sourceMappingURL=logger.js.map

/***/ }),

/***/ 316997:
/*!***************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/domain/logsCollection/console/consoleCollection.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startConsoleCollection": () => (/* binding */ startConsoleCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 700959);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 254074);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 803679);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../logger */ 659604);
var _a;


var LogStatusForApi = (_a = {}, _a[_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleApiName.log] = _logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.info, _a[_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleApiName.debug] = _logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.debug, _a[_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleApiName.info] = _logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.info, _a[_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleApiName.warn] = _logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.warn, _a[_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleApiName.error] = _logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.error, _a);
function startConsoleCollection(configuration, lifeCycle) {
  var consoleSubscription = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.initConsoleObservable)(configuration.forwardConsoleLogs).subscribe(function (log) {
    lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, {
      rawLogsEvent: {
        date: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.timeStampNow)(),
        message: log.message,
        origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.ErrorSource.CONSOLE,
        error: log.api === _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleApiName.error ? {
          origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.ErrorSource.CONSOLE,
          stack: log.stack
        } : undefined,
        status: LogStatusForApi[log.api]
      }
    });
  });
  return {
    stop: function () {
      consoleSubscription.unsubscribe();
    }
  };
}
//# sourceMappingURL=consoleCollection.js.map

/***/ }),

/***/ 950740:
/*!*************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/domain/logsCollection/logger/loggerCollection.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "STATUS_PRIORITIES": () => (/* binding */ STATUS_PRIORITIES),
/* harmony export */   "isAuthorized": () => (/* binding */ isAuthorized),
/* harmony export */   "startLoggerCollection": () => (/* binding */ startLoggerCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 700959);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 307529);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 803679);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../logger */ 659604);
var _a;


var STATUS_PRIORITIES = (_a = {}, _a[_logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.debug] = 0, _a[_logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.info] = 1, _a[_logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.warn] = 2, _a[_logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.error] = 3, _a);
function startLoggerCollection(lifeCycle) {
  function handleLog(logsMessage, logger, savedCommonContext, savedDate) {
    var messageContext = logsMessage.context;
    if (isAuthorized(logsMessage.status, _logger__WEBPACK_IMPORTED_MODULE_0__.HandlerType.console, logger)) {
      (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display)(logsMessage.status, logsMessage.message, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.combine)(logger.getContext(), messageContext));
    }
    lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, {
      rawLogsEvent: {
        date: savedDate || (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.timeStampNow)(),
        message: logsMessage.message,
        status: logsMessage.status,
        origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.ErrorSource.LOGGER
      },
      messageContext: messageContext,
      savedCommonContext: savedCommonContext,
      logger: logger
    });
  }
  return {
    handleLog: handleLog
  };
}
function isAuthorized(status, handlerType, logger) {
  var loggerHandler = logger.getHandler();
  var sanitizedHandlerType = Array.isArray(loggerHandler) ? loggerHandler : [loggerHandler];
  return STATUS_PRIORITIES[status] >= STATUS_PRIORITIES[logger.getLevel()] && (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.includes)(sanitizedHandlerType, handlerType);
}
//# sourceMappingURL=loggerCollection.js.map

/***/ }),

/***/ 703807:
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/domain/logsCollection/networkError/networkErrorCollection.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "computeFetchErrorText": () => (/* binding */ computeFetchErrorText),
/* harmony export */   "computeFetchResponseText": () => (/* binding */ computeFetchResponseText),
/* harmony export */   "computeXhrResponseData": () => (/* binding */ computeXhrResponseData),
/* harmony export */   "startNetworkErrorCollection": () => (/* binding */ startNetworkErrorCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 995176);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 847357);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 908493);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 803679);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 976474);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 267830);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 271048);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../logger */ 659604);


function startNetworkErrorCollection(configuration, lifeCycle) {
  if (!configuration.forwardErrorsToLogs) {
    return {
      stop: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.noop
    };
  }
  var xhrSubscription = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.initXhrObservable)().subscribe(function (context) {
    if (context.state === 'complete') {
      handleResponse("xhr" /* RequestType.XHR */, context);
    }
  });
  var fetchSubscription = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.initFetchObservable)().subscribe(function (context) {
    if (context.state === 'resolve') {
      handleResponse("fetch" /* RequestType.FETCH */, context);
    }
  });
  function handleResponse(type, request) {
    if (!configuration.isIntakeUrl(request.url) && (isRejected(request) || (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.isServerError)(request.status))) {
      if ('xhr' in request) {
        computeXhrResponseData(request.xhr, configuration, onResponseDataAvailable);
      } else if (request.response) {
        computeFetchResponseText(request.response, configuration, onResponseDataAvailable);
      } else if (request.error) {
        computeFetchErrorText(request.error, configuration, onResponseDataAvailable);
      }
    }
    function onResponseDataAvailable(responseData) {
      lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, {
        rawLogsEvent: {
          message: "".concat(format(type), " error ").concat(request.method, " ").concat(request.url),
          date: request.startClocks.timeStamp,
          error: {
            origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.ErrorSource.NETWORK,
            stack: responseData || 'Failed to load'
          },
          http: {
            method: request.method,
            status_code: request.status,
            url: request.url
          },
          status: _logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.error,
          origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.ErrorSource.NETWORK
        }
      });
    }
  }
  return {
    stop: function () {
      xhrSubscription.unsubscribe();
      fetchSubscription.unsubscribe();
    }
  };
}
// TODO: ideally, computeXhrResponseData should always call the callback with a string instead of
// `unknown`. But to keep backward compatibility, in the case of XHR with a `responseType` different
// than "text", the response data should be whatever `xhr.response` is. This is a bit confusing as
// Logs event 'stack' is expected to be a string. This should be changed in a future major version
// as it could be a breaking change.
function computeXhrResponseData(xhr, configuration, callback) {
  if (typeof xhr.response === 'string') {
    callback(truncateResponseText(xhr.response, configuration));
  } else {
    callback(xhr.response);
  }
}
function computeFetchErrorText(error, configuration, callback) {
  callback(truncateResponseText((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.toStackTraceString)((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.computeStackTrace)(error)), configuration));
}
function computeFetchResponseText(response, configuration, callback) {
  var clonedResponse = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.tryToClone)(response);
  if (!clonedResponse || !clonedResponse.body) {
    // if the clone failed or if the body is null, let's not try to read it.
    callback();
  } else if (!window.TextDecoder) {
    // If the browser doesn't support TextDecoder, let's read the whole response then truncate it.
    //
    // This should only be the case on early versions of Edge (before they migrated to Chromium).
    // Even if it could be possible to implement a workaround for the missing TextDecoder API (using
    // a Blob and FileReader), we found another issue preventing us from reading only the first
    // bytes from the response: contrary to other browsers, when reading from the cloned response,
    // if the original response gets canceled, the cloned response is also canceled and we can't
    // know about it.  In the following illustration, the promise returned by `reader.read()` may
    // never be fulfilled:
    //
    // fetch('/').then((response) => {
    //   const reader = response.clone().body.getReader()
    //   readMore()
    //   function readMore() {
    //     reader.read().then(
    //       (result) => {
    //         if (result.done) {
    //           console.log('done')
    //         } else {
    //           readMore()
    //         }
    //       },
    //       () => console.log('error')
    //     )
    //   }
    //   response.body.getReader().cancel()
    // })
    clonedResponse.text().then((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(function (text) {
      return callback(truncateResponseText(text, configuration));
    }), (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.monitor)(function (error) {
      return callback("Unable to retrieve response: ".concat(error));
    }));
  } else {
    truncateResponseStream(clonedResponse.body, configuration.requestErrorResponseLengthLimit, function (error, responseText) {
      if (error) {
        callback("Unable to retrieve response: ".concat(error));
      } else {
        callback(responseText);
      }
    });
  }
}
function isRejected(request) {
  return request.status === 0 && request.responseType !== 'opaque';
}
function truncateResponseText(responseText, configuration) {
  if (responseText.length > configuration.requestErrorResponseLengthLimit) {
    return "".concat(responseText.substring(0, configuration.requestErrorResponseLengthLimit), "...");
  }
  return responseText;
}
function format(type) {
  if ("xhr" /* RequestType.XHR */ === type) {
    return 'XHR';
  }
  return 'Fetch';
}
function truncateResponseStream(stream, bytesLimit, callback) {
  (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.readBytesFromStream)(stream, function (error, bytes, limitExceeded) {
    if (error) {
      callback(error);
    } else {
      var responseText = new TextDecoder().decode(bytes);
      if (limitExceeded) {
        responseText += '...';
      }
      callback(undefined, responseText);
    }
  }, {
    bytesLimit: bytesLimit,
    collectStreamBody: true
  });
}
//# sourceMappingURL=networkErrorCollection.js.map

/***/ }),

/***/ 150237:
/*!*************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/domain/logsCollection/report/reportCollection.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startReportCollection": () => (/* binding */ startReportCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 888851);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 803679);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../logger */ 659604);
var _a;


var LogStatusForReport = (_a = {}, _a[_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.RawReportType.cspViolation] = _logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.error, _a[_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.RawReportType.intervention] = _logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.error, _a[_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.RawReportType.deprecation] = _logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.warn, _a);
function startReportCollection(configuration, lifeCycle) {
  var reportSubscription = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.initReportObservable)(configuration.forwardReports).subscribe(function (report) {
    var message = report.message;
    var status = LogStatusForReport[report.type];
    var error;
    if (status === _logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.error) {
      error = {
        kind: report.subtype,
        origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.ErrorSource.REPORT,
        stack: report.stack
      };
    } else if (report.stack) {
      message += " Found in ".concat((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.getFileFromStackTraceString)(report.stack));
    }
    lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, {
      rawLogsEvent: {
        date: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.timeStampNow)(),
        message: message,
        origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.ErrorSource.REPORT,
        error: error,
        status: status
      }
    });
  });
  return {
    stop: function () {
      reportSubscription.unsubscribe();
    }
  };
}
//# sourceMappingURL=reportCollection.js.map

/***/ }),

/***/ 944144:
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/domain/logsCollection/runtimeError/runtimeErrorCollection.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startRuntimeErrorCollection": () => (/* binding */ startRuntimeErrorCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 32189);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 210349);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 803679);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../logger */ 659604);


function startRuntimeErrorCollection(configuration, lifeCycle) {
  if (!configuration.forwardErrorsToLogs) {
    return {
      stop: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.noop
    };
  }
  var rawErrorObservable = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.Observable();
  var stopRuntimeErrorTracking = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.trackRuntimeError)(rawErrorObservable).stop;
  var rawErrorSubscription = rawErrorObservable.subscribe(function (rawError) {
    lifeCycle.notify(0 /* LifeCycleEventType.RAW_LOG_COLLECTED */, {
      rawLogsEvent: {
        message: rawError.message,
        date: rawError.startClocks.timeStamp,
        error: {
          kind: rawError.type,
          origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.ErrorSource.SOURCE,
          stack: rawError.stack
        },
        origin: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.ErrorSource.SOURCE,
        status: _logger__WEBPACK_IMPORTED_MODULE_0__.StatusType.error
      }
    });
  });
  return {
    stop: function () {
      stopRuntimeErrorTracking();
      rawErrorSubscription.unsubscribe();
    }
  };
}
//# sourceMappingURL=runtimeErrorCollection.js.map

/***/ }),

/***/ 470315:
/*!*****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/domain/logsSessionManager.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LOGS_SESSION_KEY": () => (/* binding */ LOGS_SESSION_KEY),
/* harmony export */   "startLogsSessionManager": () => (/* binding */ startLogsSessionManager),
/* harmony export */   "startLogsSessionManagerStub": () => (/* binding */ startLogsSessionManagerStub)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 313031);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 159127);

var LOGS_SESSION_KEY = 'logs';
function startLogsSessionManager(configuration) {
  var sessionManager = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.startSessionManager)(configuration.cookieOptions, LOGS_SESSION_KEY, function (rawTrackingType) {
    return computeSessionState(configuration, rawTrackingType);
  });
  return {
    findTrackedSession: function (startTime) {
      var session = sessionManager.findActiveSession(startTime);
      return session && session.trackingType === "1" /* LoggerTrackingType.TRACKED */ ? {
        id: session.id
      } : undefined;
    }
  };
}
function startLogsSessionManagerStub(configuration) {
  var isTracked = computeTrackingType(configuration) === "1" /* LoggerTrackingType.TRACKED */;
  var session = isTracked ? {} : undefined;
  return {
    findTrackedSession: function () {
      return session;
    }
  };
}
function computeTrackingType(configuration) {
  if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.performDraw)(configuration.sessionSampleRate)) {
    return "0" /* LoggerTrackingType.NOT_TRACKED */;
  }

  return "1" /* LoggerTrackingType.TRACKED */;
}

function computeSessionState(configuration, rawSessionType) {
  var trackingType = hasValidLoggerSession(rawSessionType) ? rawSessionType : computeTrackingType(configuration);
  return {
    trackingType: trackingType,
    isTracked: trackingType === "1" /* LoggerTrackingType.TRACKED */
  };
}

function hasValidLoggerSession(trackingType) {
  return trackingType === "0" /* LoggerTrackingType.NOT_TRACKED */ || trackingType === "1" /* LoggerTrackingType.TRACKED */;
}
//# sourceMappingURL=logsSessionManager.js.map

/***/ }),

/***/ 377480:
/*!****************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/entries/main.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HandlerType": () => (/* reexport safe */ _domain_logger__WEBPACK_IMPORTED_MODULE_2__.HandlerType),
/* harmony export */   "Logger": () => (/* reexport safe */ _domain_logger__WEBPACK_IMPORTED_MODULE_2__.Logger),
/* harmony export */   "StatusType": () => (/* reexport safe */ _domain_logger__WEBPACK_IMPORTED_MODULE_2__.StatusType),
/* harmony export */   "datadogLogs": () => (/* binding */ datadogLogs)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 464929);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 909428);
/* harmony import */ var _boot_logsPublicApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../boot/logsPublicApi */ 941093);
/* harmony import */ var _boot_startLogs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../boot/startLogs */ 10789);
/* harmony import */ var _domain_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../domain/logger */ 659604);




var datadogLogs = (0,_boot_logsPublicApi__WEBPACK_IMPORTED_MODULE_0__.makeLogsPublicApi)(_boot_startLogs__WEBPACK_IMPORTED_MODULE_1__.startLogs);
(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.defineGlobal)((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.getGlobalObject)(), 'DD_LOGS', datadogLogs);
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 309712:
/*!****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/transport/startLogsBatch.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startLogsBatch": () => (/* binding */ startLogsBatch)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 504771);

function startLogsBatch(configuration, lifeCycle, reportError, pageExitObservable) {
  var _a;
  var batch = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.startBatchWithReplica)(configuration, configuration.logsEndpointBuilder, reportError, pageExitObservable, (_a = configuration.replica) === null || _a === void 0 ? void 0 : _a.logsEndpointBuilder);
  lifeCycle.subscribe(1 /* LifeCycleEventType.LOG_COLLECTED */, function (serverLogsEvent) {
    batch.add(serverLogsEvent);
  });
}
//# sourceMappingURL=startLogsBatch.js.map

/***/ }),

/***/ 171482:
/*!*****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-logs/esm/transport/startLogsBridge.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startLogsBridge": () => (/* binding */ startLogsBridge)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 146903);

function startLogsBridge(lifeCycle) {
  var bridge = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.getEventBridge)();
  lifeCycle.subscribe(1 /* LifeCycleEventType.LOG_COLLECTED */, function (serverLogsEvent) {
    bridge.send('log', serverLogsEvent);
  });
}
//# sourceMappingURL=startLogsBridge.js.map

/***/ }),

/***/ 71092:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/boot/rumPublicApi.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeRumPublicApi": () => (/* binding */ makeRumPublicApi)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 238490);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 685776);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 307529);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 252492);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 146903);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @datadog/browser-core */ 267830);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @datadog/browser-core */ 464929);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @datadog/browser-core */ 393968);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @datadog/browser-core */ 595530);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @datadog/browser-core */ 803679);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @datadog/browser-core */ 18000);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @datadog/browser-core */ 665627);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @datadog/browser-core */ 351540);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @datadog/browser-core */ 700959);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _domain_configuration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../domain/configuration */ 471564);
/* harmony import */ var _domain_contexts_commonContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domain/contexts/commonContext */ 459300);



function makeRumPublicApi(startRumImpl, recorderApi, _a) {
  var _b = _a === void 0 ? {} : _a,
    _c = _b.ignoreInitIfSyntheticsWillInjectRum,
    ignoreInitIfSyntheticsWillInjectRum = _c === void 0 ? true : _c;
  var isAlreadyInitialized = false;
  var globalContextManager = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.createContextManager)("global context" /* CustomerDataType.GlobalContext */);
  var userContextManager = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.createContextManager)("user" /* CustomerDataType.User */);
  var getInternalContextStrategy = function () {
    return undefined;
  };
  var getInitConfigurationStrategy = function () {
    return undefined;
  };
  var stopSessionStrategy = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.noop;
  var getSessionReplayLinkStrategy = function () {
    return undefined;
  };
  var bufferApiCalls = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.BoundedBuffer();
  var addTimingStrategy = function (name, time) {
    if (time === void 0) {
      time = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.timeStampNow)();
    }
    bufferApiCalls.add(function () {
      return addTimingStrategy(name, time);
    });
  };
  var startViewStrategy = function (options, startClocks) {
    if (startClocks === void 0) {
      startClocks = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.clocksNow)();
    }
    bufferApiCalls.add(function () {
      return startViewStrategy(options, startClocks);
    });
  };
  var addActionStrategy = function (action, commonContext) {
    if (commonContext === void 0) {
      commonContext = (0,_domain_contexts_commonContext__WEBPACK_IMPORTED_MODULE_1__.buildCommonContext)(globalContextManager, userContextManager, recorderApi);
    }
    bufferApiCalls.add(function () {
      return addActionStrategy(action, commonContext);
    });
  };
  var addErrorStrategy = function (providedError, commonContext) {
    if (commonContext === void 0) {
      commonContext = (0,_domain_contexts_commonContext__WEBPACK_IMPORTED_MODULE_1__.buildCommonContext)(globalContextManager, userContextManager, recorderApi);
    }
    bufferApiCalls.add(function () {
      return addErrorStrategy(providedError, commonContext);
    });
  };
  var addFeatureFlagEvaluationStrategy = function (key, value) {
    bufferApiCalls.add(function () {
      return addFeatureFlagEvaluationStrategy(key, value);
    });
  };
  function initRum(initConfiguration) {
    // This function should be available, regardless of initialization success.
    getInitConfigurationStrategy = function () {
      return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.deepClone)(initConfiguration);
    };
    // If we are in a Synthetics test configured to automatically inject a RUM instance, we want to
    // completely discard the customer application RUM instance by ignoring their init() call.  But,
    // we should not ignore the init() call from the Synthetics-injected RUM instance, so the
    // internal `ignoreInitIfSyntheticsWillInjectRum` option is here to bypass this condition.
    if (ignoreInitIfSyntheticsWillInjectRum && (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.willSyntheticsInjectRum)()) {
      return;
    }
    if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.canUseEventBridge)()) {
      initConfiguration = overrideInitConfigurationForBridge(initConfiguration);
    } else if (!canHandleSession(initConfiguration)) {
      return;
    }
    if (!canInitRum(initConfiguration)) {
      return;
    }
    var configuration = (0,_domain_configuration__WEBPACK_IMPORTED_MODULE_0__.validateAndBuildRumConfiguration)(initConfiguration);
    if (!configuration) {
      return;
    }
    if (!configuration.trackViewsManually) {
      doStartRum(initConfiguration, configuration);
    } else {
      // drain beforeInitCalls by buffering them until we start RUM
      // if we get a startView, drain re-buffered calls before continuing to drain beforeInitCalls
      // in order to ensure that calls are processed in order
      var beforeInitCalls = bufferApiCalls;
      bufferApiCalls = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.BoundedBuffer();
      startViewStrategy = function (options) {
        doStartRum(initConfiguration, configuration, options);
      };
      beforeInitCalls.drain();
    }
    isAlreadyInitialized = true;
  }
  function doStartRum(initConfiguration, configuration, initialViewOptions) {
    var startRumResults = startRumImpl(initConfiguration, configuration, recorderApi, globalContextManager, userContextManager, initialViewOptions);
    getSessionReplayLinkStrategy = function () {
      return recorderApi.getSessionReplayLink(configuration, startRumResults.session, startRumResults.viewContexts);
    };
    startViewStrategy = startRumResults.startView, addActionStrategy = startRumResults.addAction, addErrorStrategy = startRumResults.addError, addTimingStrategy = startRumResults.addTiming, addFeatureFlagEvaluationStrategy = startRumResults.addFeatureFlagEvaluation, getInternalContextStrategy = startRumResults.getInternalContext, stopSessionStrategy = startRumResults.stopSession;
    bufferApiCalls.drain();
    recorderApi.onRumStart(startRumResults.lifeCycle, configuration, startRumResults.session, startRumResults.viewContexts);
  }
  var startView = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(function (options) {
    var sanitizedOptions = typeof options === 'object' ? options : {
      name: options
    };
    startViewStrategy(sanitizedOptions);
  });
  var rumPublicApi = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_10__.makePublicApi)({
    init: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(initRum),
    /** @deprecated: use setGlobalContextProperty instead */
    addRumGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(globalContextManager.add),
    setGlobalContextProperty: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(globalContextManager.setContextProperty),
    /** @deprecated: use removeGlobalContextProperty instead */
    removeRumGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(globalContextManager.remove),
    removeGlobalContextProperty: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(globalContextManager.removeContextProperty),
    /** @deprecated: use getGlobalContext instead */
    getRumGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(globalContextManager.get),
    getGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(globalContextManager.getContext),
    /** @deprecated: use setGlobalContext instead */
    setRumGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(globalContextManager.set),
    setGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(globalContextManager.setContext),
    clearGlobalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(globalContextManager.clearContext),
    getInternalContext: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(function (startTime) {
      return getInternalContextStrategy(startTime);
    }),
    getInitConfiguration: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(function () {
      return getInitConfigurationStrategy();
    }),
    addAction: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(function (name, context) {
      addActionStrategy({
        name: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__.sanitize)(name) : name,
        context: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__.sanitize)(context) : (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.deepClone)(context),
        startClocks: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.clocksNow)(),
        type: "custom" /* ActionType.CUSTOM */
      });
    }),

    addError: function (error, context) {
      var handlingStack = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_13__.createHandlingStack)();
      (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.callMonitored)(function () {
        addErrorStrategy({
          error: error,
          handlingStack: handlingStack,
          context: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__.sanitize)(context) : (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.deepClone)(context),
          startClocks: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.clocksNow)()
        });
      });
    },
    addTiming: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(function (name, time) {
      addTimingStrategy((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__.sanitize)(name) : name, time);
    }),
    setUser: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(function (newUser) {
      if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_14__.checkUser)(newUser)) {
        userContextManager.setContext((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_14__.sanitizeUser)(newUser));
      }
    }),
    getUser: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(userContextManager.getContext),
    setUserProperty: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(function (key, property) {
      var _a;
      var sanitizedProperty = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_14__.sanitizeUser)((_a = {}, _a[key] = property, _a))[key];
      userContextManager.setContextProperty(key, sanitizedProperty);
    }),
    removeUserProperty: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(userContextManager.removeContextProperty),
    /** @deprecated: renamed to clearUser */
    removeUser: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(userContextManager.clearContext),
    clearUser: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(userContextManager.clearContext),
    startView: startView,
    stopSession: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(function () {
      stopSessionStrategy();
    }),
    startSessionReplayRecording: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(recorderApi.start),
    stopSessionReplayRecording: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(recorderApi.stop),
    /**
     * This feature is currently in beta. For more information see the full [feature flag tracking guide](https://docs.datadoghq.com/real_user_monitoring/feature_flag_tracking/).
     */
    addFeatureFlagEvaluation: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(function (key, value) {
      addFeatureFlagEvaluationStrategy((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__.sanitize)(key) : key, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__.sanitize)(value) : value);
    }),
    getSessionReplayLink: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.monitor)(function () {
      return getSessionReplayLinkStrategy();
    })
  });
  return rumPublicApi;
  function canHandleSession(initConfiguration) {
    if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_15__.areCookiesAuthorized)((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_16__.buildCookieOptions)(initConfiguration))) {
      _datadog_browser_core__WEBPACK_IMPORTED_MODULE_17__.display.warn('Cookies are not authorized, we will not send any data.');
      return false;
    }
    if (isLocalFile()) {
      _datadog_browser_core__WEBPACK_IMPORTED_MODULE_17__.display.error('Execution is not allowed in the current context.');
      return false;
    }
    return true;
  }
  function canInitRum(initConfiguration) {
    if (isAlreadyInitialized) {
      if (!initConfiguration.silentMultipleInit) {
        _datadog_browser_core__WEBPACK_IMPORTED_MODULE_17__.display.error('DD_RUM is already initialized.');
      }
      return false;
    }
    return true;
  }
  function overrideInitConfigurationForBridge(initConfiguration) {
    return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_18__.assign)({}, initConfiguration, {
      applicationId: '00000000-aaaa-0000-aaaa-000000000000',
      clientToken: 'empty',
      sessionSampleRate: 100
    });
  }
  function isLocalFile() {
    return window.location.protocol === 'file:';
  }
}
//# sourceMappingURL=rumPublicApi.js.map

/***/ }),

/***/ 382001:
/*!*********************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/boot/startRum.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startRum": () => (/* binding */ startRum),
/* harmony export */   "startRumEventCollection": () => (/* binding */ startRumEventCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @datadog/browser-core */ 413464);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @datadog/browser-core */ 146903);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @datadog/browser-core */ 37215);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @datadog/browser-core */ 931942);
/* harmony import */ var _browser_domMutationObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../browser/domMutationObservable */ 280169);
/* harmony import */ var _browser_performanceCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../browser/performanceCollection */ 552575);
/* harmony import */ var _domain_assembly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../domain/assembly */ 891370);
/* harmony import */ var _domain_contexts_foregroundContexts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../domain/contexts/foregroundContexts */ 718758);
/* harmony import */ var _domain_contexts_internalContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../domain/contexts/internalContext */ 598536);
/* harmony import */ var _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../domain/lifeCycle */ 762618);
/* harmony import */ var _domain_contexts_viewContexts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../domain/contexts/viewContexts */ 347265);
/* harmony import */ var _domain_requestCollection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../domain/requestCollection */ 684297);
/* harmony import */ var _domain_rumEventsCollection_action_actionCollection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../domain/rumEventsCollection/action/actionCollection */ 886199);
/* harmony import */ var _domain_rumEventsCollection_error_errorCollection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../domain/rumEventsCollection/error/errorCollection */ 951057);
/* harmony import */ var _domain_rumEventsCollection_longTask_longTaskCollection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../domain/rumEventsCollection/longTask/longTaskCollection */ 278689);
/* harmony import */ var _domain_rumEventsCollection_resource_resourceCollection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../domain/rumEventsCollection/resource/resourceCollection */ 44035);
/* harmony import */ var _domain_rumEventsCollection_view_viewCollection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../domain/rumEventsCollection/view/viewCollection */ 22210);
/* harmony import */ var _domain_rumSessionManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../domain/rumSessionManager */ 77401);
/* harmony import */ var _transport_startRumBatch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../transport/startRumBatch */ 531741);
/* harmony import */ var _transport_startRumEventBridge__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../transport/startRumEventBridge */ 929146);
/* harmony import */ var _domain_contexts_urlContexts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../domain/contexts/urlContexts */ 513136);
/* harmony import */ var _browser_locationChangeObservable__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../browser/locationChangeObservable */ 695955);
/* harmony import */ var _domain_configuration__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../domain/configuration */ 471564);
/* harmony import */ var _domain_contexts_featureFlagContext__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../domain/contexts/featureFlagContext */ 728625);
/* harmony import */ var _domain_startCustomerDataTelemetry__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../domain/startCustomerDataTelemetry */ 546149);
/* harmony import */ var _domain_contexts_pageStateHistory__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../domain/contexts/pageStateHistory */ 636608);
/* harmony import */ var _domain_contexts_commonContext__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../domain/contexts/commonContext */ 459300);
























function startRum(initConfiguration, configuration, recorderApi, globalContextManager, userContextManager, initialViewOptions) {
  var lifeCycle = new _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_5__.LifeCycle();
  lifeCycle.subscribe(11 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, function (event) {
    return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_23__.sendToExtension)('rum', event);
  });
  var telemetry = startRumTelemetry(configuration);
  telemetry.setContextProvider(function () {
    var _a, _b;
    return {
      application: {
        id: configuration.applicationId
      },
      session: {
        id: (_a = session.findTrackedSession()) === null || _a === void 0 ? void 0 : _a.id
      },
      view: {
        id: (_b = viewContexts.findView()) === null || _b === void 0 ? void 0 : _b.id
      },
      action: {
        id: actionContexts.findActionId()
      }
    };
  });
  var reportError = function (error) {
    lifeCycle.notify(12 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, {
      error: error
    });
  };
  var featureFlagContexts = (0,_domain_contexts_featureFlagContext__WEBPACK_IMPORTED_MODULE_19__.startFeatureFlagContexts)(lifeCycle);
  if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_24__.canUseEventBridge)()) {
    var pageExitObservable = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_25__.createPageExitObservable)();
    pageExitObservable.subscribe(function (event) {
      lifeCycle.notify(9 /* LifeCycleEventType.PAGE_EXITED */, event);
    });
    var batch = (0,_transport_startRumBatch__WEBPACK_IMPORTED_MODULE_14__.startRumBatch)(configuration, lifeCycle, telemetry.observable, reportError, pageExitObservable);
    (0,_domain_startCustomerDataTelemetry__WEBPACK_IMPORTED_MODULE_20__.startCustomerDataTelemetry)(configuration, telemetry, lifeCycle, globalContextManager, userContextManager, featureFlagContexts, batch.flushObservable);
  } else {
    (0,_transport_startRumEventBridge__WEBPACK_IMPORTED_MODULE_15__.startRumEventBridge)(lifeCycle);
  }
  var session = !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_24__.canUseEventBridge)() ? (0,_domain_rumSessionManager__WEBPACK_IMPORTED_MODULE_13__.startRumSessionManager)(configuration, lifeCycle) : (0,_domain_rumSessionManager__WEBPACK_IMPORTED_MODULE_13__.startRumSessionManagerStub)();
  var domMutationObservable = (0,_browser_domMutationObservable__WEBPACK_IMPORTED_MODULE_0__.createDOMMutationObservable)();
  var locationChangeObservable = (0,_browser_locationChangeObservable__WEBPACK_IMPORTED_MODULE_17__.createLocationChangeObservable)(location);
  var _a = startRumEventCollection(lifeCycle, configuration, location, session, locationChangeObservable, domMutationObservable, function () {
      return (0,_domain_contexts_commonContext__WEBPACK_IMPORTED_MODULE_22__.buildCommonContext)(globalContextManager, userContextManager, recorderApi);
    }, reportError),
    viewContexts = _a.viewContexts,
    foregroundContexts = _a.foregroundContexts,
    urlContexts = _a.urlContexts,
    actionContexts = _a.actionContexts,
    addAction = _a.addAction;
  (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_26__.addTelemetryConfiguration)((0,_domain_configuration__WEBPACK_IMPORTED_MODULE_18__.serializeRumConfiguration)(initConfiguration));
  (0,_domain_rumEventsCollection_longTask_longTaskCollection__WEBPACK_IMPORTED_MODULE_10__.startLongTaskCollection)(lifeCycle, session);
  var pageStateHistory = (0,_domain_contexts_pageStateHistory__WEBPACK_IMPORTED_MODULE_21__.startPageStateHistory)();
  (0,_domain_rumEventsCollection_resource_resourceCollection__WEBPACK_IMPORTED_MODULE_11__.startResourceCollection)(lifeCycle, configuration, session, pageStateHistory);
  var _b = (0,_domain_rumEventsCollection_view_viewCollection__WEBPACK_IMPORTED_MODULE_12__.startViewCollection)(lifeCycle, configuration, location, domMutationObservable, locationChangeObservable, foregroundContexts, featureFlagContexts, recorderApi, initialViewOptions),
    addTiming = _b.addTiming,
    startView = _b.startView;
  var addError = (0,_domain_rumEventsCollection_error_errorCollection__WEBPACK_IMPORTED_MODULE_9__.startErrorCollection)(lifeCycle, foregroundContexts, featureFlagContexts).addError;
  (0,_domain_requestCollection__WEBPACK_IMPORTED_MODULE_7__.startRequestCollection)(lifeCycle, configuration, session);
  (0,_browser_performanceCollection__WEBPACK_IMPORTED_MODULE_1__.startPerformanceCollection)(lifeCycle, configuration);
  var internalContext = (0,_domain_contexts_internalContext__WEBPACK_IMPORTED_MODULE_4__.startInternalContext)(configuration.applicationId, session, viewContexts, actionContexts, urlContexts);
  return {
    addAction: addAction,
    addError: addError,
    addTiming: addTiming,
    addFeatureFlagEvaluation: featureFlagContexts.addFeatureFlagEvaluation,
    startView: startView,
    lifeCycle: lifeCycle,
    viewContexts: viewContexts,
    session: session,
    stopSession: function () {
      return session.expire();
    },
    getInternalContext: internalContext.get
  };
}
function startRumTelemetry(configuration) {
  var telemetry = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_26__.startTelemetry)("browser-rum-sdk" /* TelemetryService.RUM */, configuration);
  if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_24__.canUseEventBridge)()) {
    var bridge_1 = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_24__.getEventBridge)();
    telemetry.observable.subscribe(function (event) {
      return bridge_1.send('internal_telemetry', event);
    });
  }
  return telemetry;
}
function startRumEventCollection(lifeCycle, configuration, location, sessionManager, locationChangeObservable, domMutationObservable, buildCommonContext, reportError) {
  var viewContexts = (0,_domain_contexts_viewContexts__WEBPACK_IMPORTED_MODULE_6__.startViewContexts)(lifeCycle);
  var urlContexts = (0,_domain_contexts_urlContexts__WEBPACK_IMPORTED_MODULE_16__.startUrlContexts)(lifeCycle, locationChangeObservable, location);
  var foregroundContexts = (0,_domain_contexts_foregroundContexts__WEBPACK_IMPORTED_MODULE_3__.startForegroundContexts)();
  var _a = (0,_domain_rumEventsCollection_action_actionCollection__WEBPACK_IMPORTED_MODULE_8__.startActionCollection)(lifeCycle, domMutationObservable, configuration, foregroundContexts),
    addAction = _a.addAction,
    actionContexts = _a.actionContexts;
  (0,_domain_assembly__WEBPACK_IMPORTED_MODULE_2__.startRumAssembly)(configuration, lifeCycle, sessionManager, viewContexts, urlContexts, actionContexts, buildCommonContext, reportError);
  return {
    viewContexts: viewContexts,
    foregroundContexts: foregroundContexts,
    urlContexts: urlContexts,
    addAction: addAction,
    actionContexts: actionContexts,
    stop: function () {
      viewContexts.stop();
      foregroundContexts.stop();
    }
  };
}
//# sourceMappingURL=startRum.js.map

/***/ }),

/***/ 280169:
/*!*************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/browser/domMutationObservable.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDOMMutationObservable": () => (/* binding */ createDOMMutationObservable),
/* harmony export */   "getMutationObserverConstructor": () => (/* binding */ getMutationObserverConstructor)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 32189);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 267830);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 129107);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 897826);

function createDOMMutationObservable() {
  var MutationObserver = getMutationObserverConstructor();
  var observable = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.Observable(function () {
    if (!MutationObserver) {
      return;
    }
    var observer = new MutationObserver((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.monitor)(function () {
      return observable.notify();
    }));
    observer.observe(document, {
      attributes: true,
      characterData: true,
      childList: true,
      subtree: true
    });
    return function () {
      return observer.disconnect();
    };
  });
  return observable;
}
function getMutationObserverConstructor() {
  var constructor;
  var browserWindow = window;
  // Angular uses Zone.js to provide a context persisting across async tasks.  Zone.js replaces the
  // global MutationObserver constructor with a patched version to support the context propagation.
  // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular
  // component: on some occasions, the callback is being called in an infinite loop, causing the
  // page to freeze (even if the callback is completely empty).
  //
  // To work around this issue, we try to get the original MutationObserver constructor stored by
  // Zone.js.
  //
  // [1] https://github.com/angular/angular/issues/26948
  // [2] https://github.com/angular/angular/issues/31712
  if (browserWindow.Zone) {
    // Zone.js 0.8.6+ is storing original class constructors into the browser 'window' object[3].
    //
    // [3] https://github.com/angular/angular/blob/6375fa79875c0fe7b815efc45940a6e6f5c9c9eb/packages/zone.js/lib/common/utils.ts#L288
    constructor = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.getZoneJsOriginalValue)(browserWindow, 'MutationObserver');
    if (browserWindow.MutationObserver && constructor === browserWindow.MutationObserver) {
      // Anterior Zone.js versions (used in Angular 2) does not expose the original MutationObserver
      // in the 'window' object. Luckily, the patched MutationObserver class is storing an original
      // instance in its properties[4]. Let's get the original MutationObserver constructor from
      // there.
      //
      // [4] https://github.com/angular/zone.js/blob/v0.8.5/lib/common/utils.ts#L412
      var patchedInstance = new browserWindow.MutationObserver(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.noop);
      var originalInstance = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.getZoneJsOriginalValue)(patchedInstance, 'originalInstance');
      constructor = originalInstance && originalInstance.constructor;
    }
  }
  if (!constructor) {
    constructor = browserWindow.MutationObserver;
  }
  return constructor;
}
//# sourceMappingURL=domMutationObservable.js.map

/***/ }),

/***/ 381146:
/*!****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/browser/htmlDomUtils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getChildNodes": () => (/* binding */ getChildNodes),
/* harmony export */   "getParentNode": () => (/* binding */ getParentNode),
/* harmony export */   "isCommentNode": () => (/* binding */ isCommentNode),
/* harmony export */   "isElementNode": () => (/* binding */ isElementNode),
/* harmony export */   "isNodeShadowHost": () => (/* binding */ isNodeShadowHost),
/* harmony export */   "isNodeShadowRoot": () => (/* binding */ isNodeShadowRoot),
/* harmony export */   "isTextNode": () => (/* binding */ isTextNode)
/* harmony export */ });
function isTextNode(node) {
  return node.nodeType === Node.TEXT_NODE;
}
function isCommentNode(node) {
  return node.nodeType === Node.COMMENT_NODE;
}
function isElementNode(node) {
  return node.nodeType === Node.ELEMENT_NODE;
}
function isNodeShadowHost(node) {
  return isElementNode(node) && Boolean(node.shadowRoot);
}
function isNodeShadowRoot(node) {
  var shadowRoot = node;
  return !!shadowRoot.host && shadowRoot.nodeType === Node.DOCUMENT_FRAGMENT_NODE && isElementNode(shadowRoot.host);
}
function getChildNodes(node) {
  return isNodeShadowHost(node) ? node.shadowRoot.childNodes : node.childNodes;
}
/**
 * Return `host` in case if the current node is a shadow root otherwise will return the `parentNode`
 */
function getParentNode(node) {
  return isNodeShadowRoot(node) ? node.host : node.parentNode;
}
//# sourceMappingURL=htmlDomUtils.js.map

/***/ }),

/***/ 695955:
/*!****************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/browser/locationChangeObservable.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLocationChangeObservable": () => (/* binding */ createLocationChangeObservable)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 567934);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 32189);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 101280);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 822006);

function createLocationChangeObservable(location) {
  var currentLocation = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.shallowClone)(location);
  var observable = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.Observable(function () {
    var stopHistoryTracking = trackHistory(onLocationChange).stop;
    var stopHashTracking = trackHash(onLocationChange).stop;
    return function () {
      stopHistoryTracking();
      stopHashTracking();
    };
  });
  function onLocationChange() {
    if (currentLocation.href === location.href) {
      return;
    }
    var newLocation = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.shallowClone)(location);
    observable.notify({
      newLocation: newLocation,
      oldLocation: currentLocation
    });
    currentLocation = newLocation;
  }
  return observable;
}
function trackHistory(onHistoryChange) {
  var stopInstrumentingPushState = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.instrumentMethodAndCallOriginal)(history, 'pushState', {
    after: onHistoryChange
  }).stop;
  var stopInstrumentingReplaceState = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.instrumentMethodAndCallOriginal)(history, 'replaceState', {
    after: onHistoryChange
  }).stop;
  var removeListener = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.addEventListener)(window, "popstate" /* DOM_EVENT.POP_STATE */, onHistoryChange).stop;
  return {
    stop: function () {
      stopInstrumentingPushState();
      stopInstrumentingReplaceState();
      removeListener();
    }
  };
}
function trackHash(onHashChange) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.addEventListener)(window, "hashchange" /* DOM_EVENT.HASH_CHANGE */, onHashChange);
}
//# sourceMappingURL=locationChangeObservable.js.map

/***/ }),

/***/ 552575:
/*!*************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/browser/performanceCollection.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "retrieveInitialDocumentResourceTiming": () => (/* binding */ retrieveInitialDocumentResourceTiming),
/* harmony export */   "startPerformanceCollection": () => (/* binding */ startPerformanceCollection),
/* harmony export */   "supportPerformanceTimingEvent": () => (/* binding */ supportPerformanceTimingEvent)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 631128);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 267830);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 822006);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 656785);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 159127);
/* harmony import */ var _domain_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../domain/rumEventsCollection/resource/resourceUtils */ 604579);
/* harmony import */ var _domain_tracing_getDocumentTraceId__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domain/tracing/getDocumentTraceId */ 195265);



function supportPerformanceObject() {
  return window.performance !== undefined && 'getEntries' in performance;
}
function supportPerformanceTimingEvent(entryType) {
  return window.PerformanceObserver && PerformanceObserver.supportedEntryTypes !== undefined && PerformanceObserver.supportedEntryTypes.includes(entryType);
}
function startPerformanceCollection(lifeCycle, configuration) {
  retrieveInitialDocumentResourceTiming(function (timing) {
    handleRumPerformanceEntries(lifeCycle, configuration, [timing]);
  });
  if (supportPerformanceObject()) {
    var performanceEntries_1 = performance.getEntries();
    // Because the performance entry list can be quite large
    // delay the computation to prevent the SDK from blocking the main thread on init
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.setTimeout)(function () {
      return handleRumPerformanceEntries(lifeCycle, configuration, performanceEntries_1);
    });
  }
  if (window.PerformanceObserver) {
    var handlePerformanceEntryList_1 = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.monitor)(function (entries) {
      return handleRumPerformanceEntries(lifeCycle, configuration, entries.getEntries());
    });
    var mainEntries = ['resource', 'navigation', 'longtask', 'paint'];
    var experimentalEntries = ['largest-contentful-paint', 'first-input', 'layout-shift'];
    try {
      // Experimental entries are not retrieved by performance.getEntries()
      // use a single PerformanceObserver with buffered flag by type
      // to get values that could happen before SDK init
      experimentalEntries.forEach(function (type) {
        var observer = new PerformanceObserver(handlePerformanceEntryList_1);
        observer.observe({
          type: type,
          buffered: true
        });
      });
    } catch (e) {
      // Some old browser versions (ex: chrome 67) don't support the PerformanceObserver type and buffered options
      // In these cases, fallback to PerformanceObserver with entryTypes
      mainEntries.push.apply(mainEntries, experimentalEntries);
    }
    var mainObserver = new PerformanceObserver(handlePerformanceEntryList_1);
    mainObserver.observe({
      entryTypes: mainEntries
    });
    if (supportPerformanceObject() && 'addEventListener' in performance) {
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377
      (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.addEventListener)(performance, 'resourcetimingbufferfull', function () {
        performance.clearResourceTimings();
      });
    }
  }
  if (!supportPerformanceTimingEvent('navigation')) {
    retrieveNavigationTiming(function (timing) {
      handleRumPerformanceEntries(lifeCycle, configuration, [timing]);
    });
  }
  if (!supportPerformanceTimingEvent('first-input')) {
    retrieveFirstInputTiming(function (timing) {
      handleRumPerformanceEntries(lifeCycle, configuration, [timing]);
    });
  }
}
function retrieveInitialDocumentResourceTiming(callback) {
  (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.runOnReadyState)('interactive', function () {
    var timing;
    var forcedAttributes = {
      entryType: 'resource',
      initiatorType: _domain_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_0__.FAKE_INITIAL_DOCUMENT,
      traceId: (0,_domain_tracing_getDocumentTraceId__WEBPACK_IMPORTED_MODULE_1__.getDocumentTraceId)(document)
    };
    if (supportPerformanceTimingEvent('navigation') && performance.getEntriesByType('navigation').length > 0) {
      var navigationEntry = performance.getEntriesByType('navigation')[0];
      timing = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.assign)(navigationEntry.toJSON(), forcedAttributes);
    } else {
      var relativePerformanceTiming = computeRelativePerformanceTiming();
      timing = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.assign)(relativePerformanceTiming, {
        decodedBodySize: 0,
        duration: relativePerformanceTiming.responseEnd,
        name: window.location.href,
        startTime: 0
      }, forcedAttributes);
    }
    callback(timing);
  });
}
function retrieveNavigationTiming(callback) {
  function sendFakeTiming() {
    callback((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.assign)(computeRelativePerformanceTiming(), {
      entryType: 'navigation'
    }));
  }
  (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.runOnReadyState)('complete', function () {
    // Send it a bit after the actual load event, so the "loadEventEnd" timing is accurate
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.setTimeout)(sendFakeTiming);
  });
}
/**
 * first-input timing entry polyfill based on
 * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts
 */
function retrieveFirstInputTiming(callback) {
  var startTimeStamp = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.dateNow)();
  var timingSent = false;
  var removeEventListeners = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.addEventListeners)(window, ["click" /* DOM_EVENT.CLICK */, "mousedown" /* DOM_EVENT.MOUSE_DOWN */, "keydown" /* DOM_EVENT.KEY_DOWN */, "touchstart" /* DOM_EVENT.TOUCH_START */, "pointerdown" /* DOM_EVENT.POINTER_DOWN */], function (evt) {
    // Only count cancelable events, which should trigger behavior important to the user.
    if (!evt.cancelable) {
      return;
    }
    // This timing will be used to compute the "first Input delay", which is the delta between
    // when the system received the event (e.g. evt.timeStamp) and when it could run the callback
    // (e.g. performance.now()).
    var timing = {
      entryType: 'first-input',
      processingStart: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.relativeNow)(),
      startTime: evt.timeStamp
    };
    if (evt.type === "pointerdown" /* DOM_EVENT.POINTER_DOWN */) {
      sendTimingIfPointerIsNotCancelled(timing);
    } else {
      sendTiming(timing);
    }
  }, {
    passive: true,
    capture: true
  }).stop;
  /**
   * Pointer events are a special case, because they can trigger main or compositor thread behavior.
   * We differentiate these cases based on whether or not we see a pointercancel event, which are
   * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes
   * scrolling and pinch/zooming.
   */
  function sendTimingIfPointerIsNotCancelled(timing) {
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.addEventListeners)(window, ["pointerup" /* DOM_EVENT.POINTER_UP */, "pointercancel" /* DOM_EVENT.POINTER_CANCEL */], function (event) {
      if (event.type === "pointerup" /* DOM_EVENT.POINTER_UP */) {
        sendTiming(timing);
      }
    }, {
      once: true
    });
  }
  function sendTiming(timing) {
    if (!timingSent) {
      timingSent = true;
      removeEventListeners();
      // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than
      // the time between now and when the page was loaded.
      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4
      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6
      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7
      var delay = timing.processingStart - timing.startTime;
      if (delay >= 0 && delay < (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.dateNow)() - startTimeStamp) {
        callback(timing);
      }
    }
  }
}
function computeRelativePerformanceTiming() {
  var result = {};
  var timing = performance.timing;
  for (var key in timing) {
    if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.isNumber)(timing[key])) {
      var numberKey = key;
      var timingElement = timing[numberKey];
      result[numberKey] = timingElement === 0 ? 0 : (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.getRelativeTime)(timingElement);
    }
  }
  return result;
}
function handleRumPerformanceEntries(lifeCycle, configuration, entries) {
  var rumPerformanceEntries = entries.filter(function (entry) {
    return entry.entryType === 'resource' || entry.entryType === 'navigation' || entry.entryType === 'paint' || entry.entryType === 'longtask' || entry.entryType === 'largest-contentful-paint' || entry.entryType === 'first-input' || entry.entryType === 'layout-shift';
  });
  var rumAllowedPerformanceEntries = rumPerformanceEntries.filter(function (entry) {
    return !isIncompleteNavigation(entry) && !isForbiddenResource(configuration, entry);
  });
  if (rumAllowedPerformanceEntries.length) {
    lifeCycle.notify(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, rumAllowedPerformanceEntries);
  }
}
function isIncompleteNavigation(entry) {
  return entry.entryType === 'navigation' && entry.loadEventEnd <= 0;
}
function isForbiddenResource(configuration, entry) {
  return entry.entryType === 'resource' && !(0,_domain_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_0__.isAllowedRequestUrl)(configuration, entry.name);
}
//# sourceMappingURL=performanceCollection.js.map

/***/ }),

/***/ 845755:
/*!**********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/browser/viewportObservable.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createViewportObservable": () => (/* binding */ createViewportObservable),
/* harmony export */   "getViewportDimension": () => (/* binding */ getViewportDimension),
/* harmony export */   "initViewportObservable": () => (/* binding */ initViewportObservable)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 32189);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 822006);

var viewportObservable;
function initViewportObservable() {
  if (!viewportObservable) {
    viewportObservable = createViewportObservable();
  }
  return viewportObservable;
}
function createViewportObservable() {
  var observable = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.Observable(function () {
    var updateDimension = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.throttle)(function () {
      observable.notify(getViewportDimension());
    }, 200).throttled;
    return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.addEventListener)(window, "resize" /* DOM_EVENT.RESIZE */, updateDimension, {
      capture: true,
      passive: true
    }).stop;
  });
  return observable;
}
// excludes the width and height of any rendered classic scrollbar that is fixed to the visual viewport
function getViewportDimension() {
  var visual = window.visualViewport;
  if (visual) {
    return {
      width: Number(visual.width * visual.scale),
      height: Number(visual.height * visual.scale)
    };
  }
  return {
    width: Number(window.innerWidth || 0),
    height: Number(window.innerHeight || 0)
  };
}
//# sourceMappingURL=viewportObservable.js.map

/***/ }),

/***/ 891370:
/*!***********************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/assembly.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startRumAssembly": () => (/* binding */ startRumAssembly)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 853556);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 146903);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 307529);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 567934);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @datadog/browser-core */ 700959);
/* harmony import */ var _contexts_syntheticsContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contexts/syntheticsContext */ 976635);
/* harmony import */ var _contexts_ciTestContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contexts/ciTestContext */ 591981);
/* harmony import */ var _contexts_displayContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contexts/displayContext */ 429767);
/* harmony import */ var _limitModification__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./limitModification */ 508130);





var VIEW_EVENTS_MODIFIABLE_FIELD_PATHS = [
// Fields with sensitive data
'view.url', 'view.referrer', 'action.target.name', 'error.message', 'error.stack', 'error.resource.url', 'resource.url'];
var OTHER_EVENTS_MODIFIABLE_FIELD_PATHS = VIEW_EVENTS_MODIFIABLE_FIELD_PATHS.concat([
// User-customizable field
'context']);
function startRumAssembly(configuration, lifeCycle, sessionManager, viewContexts, urlContexts, actionContexts, buildCommonContext, reportError) {
  var _a;
  var eventRateLimiters = (_a = {}, _a["error" /* RumEventType.ERROR */] = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.createEventRateLimiter)("error" /* RumEventType.ERROR */, configuration.eventRateLimiterThreshold, reportError), _a["action" /* RumEventType.ACTION */] = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.createEventRateLimiter)("action" /* RumEventType.ACTION */, configuration.eventRateLimiterThreshold, reportError), _a);
  var syntheticsContext = (0,_contexts_syntheticsContext__WEBPACK_IMPORTED_MODULE_0__.getSyntheticsContext)();
  var ciTestContext = (0,_contexts_ciTestContext__WEBPACK_IMPORTED_MODULE_1__.getCiTestContext)();
  lifeCycle.subscribe(10 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, function (_a) {
    var startTime = _a.startTime,
      rawRumEvent = _a.rawRumEvent,
      domainContext = _a.domainContext,
      savedCommonContext = _a.savedCommonContext,
      customerContext = _a.customerContext;
    var viewContext = viewContexts.findView(startTime);
    var urlContext = urlContexts.findUrl(startTime);
    // allow to send events if the session was tracked when they start
    // except for views which are continuously updated
    // TODO: stop sending view updates when session is expired
    var session = sessionManager.findTrackedSession(rawRumEvent.type !== "view" /* RumEventType.VIEW */ ? startTime : undefined);
    if (session && viewContext && urlContext) {
      var commonContext = savedCommonContext || buildCommonContext();
      var actionId = actionContexts.findActionId(startTime);
      var rumContext = {
        _dd: {
          format_version: 2,
          drift: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.currentDrift)(),
          session: {
            plan: session.plan
          },
          browser_sdk_version: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.canUseEventBridge)() ? "4.39.0" : undefined
        },
        application: {
          id: configuration.applicationId
        },
        date: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.timeStampNow)(),
        service: viewContext.service || configuration.service,
        version: viewContext.version || configuration.version,
        source: 'browser',
        session: {
          id: session.id,
          type: syntheticsContext ? "synthetics" /* SessionType.SYNTHETICS */ : ciTestContext ? "ci_test" /* SessionType.CI_TEST */ : "user" /* SessionType.USER */
        },

        view: {
          id: viewContext.id,
          name: viewContext.name,
          url: urlContext.url,
          referrer: urlContext.referrer
        },
        action: needToAssembleWithAction(rawRumEvent) && actionId ? {
          id: actionId
        } : undefined,
        synthetics: syntheticsContext,
        ci_test: ciTestContext,
        display: (0,_contexts_displayContext__WEBPACK_IMPORTED_MODULE_2__.getDisplayContext)()
      };
      var serverRumEvent = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.combine)(rumContext, rawRumEvent);
      serverRumEvent.context = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.combine)(commonContext.context, customerContext);
      if (!('has_replay' in serverRumEvent.session)) {
        ;
        serverRumEvent.session.has_replay = commonContext.hasReplay;
      }
      if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.isEmptyObject)(commonContext.user)) {
        ;
        serverRumEvent.usr = commonContext.user;
      }
      if (shouldSend(serverRumEvent, configuration.beforeSend, domainContext, eventRateLimiters)) {
        if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.isEmptyObject)(serverRumEvent.context)) {
          delete serverRumEvent.context;
        }
        lifeCycle.notify(11 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, serverRumEvent);
      }
    }
  });
}
function shouldSend(event, beforeSend, domainContext, eventRateLimiters) {
  var _a;
  if (beforeSend) {
    var result = (0,_limitModification__WEBPACK_IMPORTED_MODULE_3__.limitModification)(event, event.type === "view" /* RumEventType.VIEW */ ? VIEW_EVENTS_MODIFIABLE_FIELD_PATHS : OTHER_EVENTS_MODIFIABLE_FIELD_PATHS, function (event) {
      return beforeSend(event, domainContext);
    });
    if (result === false && event.type !== "view" /* RumEventType.VIEW */) {
      return false;
    }
    if (result === false) {
      _datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.display.warn("Can't dismiss view events using beforeSend!");
    }
  }
  var rateLimitReached = (_a = eventRateLimiters[event.type]) === null || _a === void 0 ? void 0 : _a.isLimitReached();
  return !rateLimitReached;
}
function needToAssembleWithAction(event) {
  return ["error" /* RumEventType.ERROR */, "resource" /* RumEventType.RESOURCE */, "long_task" /* RumEventType.LONG_TASK */].indexOf(event.type) !== -1;
}
//# sourceMappingURL=assembly.js.map

/***/ }),

/***/ 471564:
/*!****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/configuration.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "serializeRumConfiguration": () => (/* binding */ serializeRumConfiguration),
/* harmony export */   "validateAndBuildRumConfiguration": () => (/* binding */ validateAndBuildRumConfiguration)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 700959);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 159127);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 351540);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 567934);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 484336);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 77615);
/* harmony import */ var _tracing_tracer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tracing/tracer */ 264320);


function validateAndBuildRumConfiguration(initConfiguration) {
  var _a, _b, _c, _d, _e, _f;
  if (!initConfiguration.applicationId) {
    _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.error('Application ID is not configured, no RUM data will be collected.');
    return;
  }
  if (initConfiguration.sessionReplaySampleRate !== undefined && !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.isPercentage)(initConfiguration.sessionReplaySampleRate)) {
    _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.error('Session Replay Sample Rate should be a number between 0 and 100');
    return;
  }
  // TODO remove fallback in next major
  var premiumSampleRate = (_a = initConfiguration.premiumSampleRate) !== null && _a !== void 0 ? _a : initConfiguration.replaySampleRate;
  if (premiumSampleRate !== undefined && initConfiguration.sessionReplaySampleRate !== undefined) {
    _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.warn('Ignoring Premium Sample Rate because Session Replay Sample Rate is set');
    premiumSampleRate = undefined;
  }
  if (premiumSampleRate !== undefined && !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.isPercentage)(premiumSampleRate)) {
    _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.error('Premium Sample Rate should be a number between 0 and 100');
    return;
  }
  var traceSampleRate = (_b = initConfiguration.traceSampleRate) !== null && _b !== void 0 ? _b : initConfiguration.tracingSampleRate;
  if (traceSampleRate !== undefined && !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.isPercentage)(traceSampleRate)) {
    _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.error('Trace Sample Rate should be a number between 0 and 100');
    return;
  }
  if (initConfiguration.excludedActivityUrls !== undefined && !Array.isArray(initConfiguration.excludedActivityUrls)) {
    _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.error('Excluded Activity Urls should be an array');
    return;
  }
  var allowedTracingUrls = validateAndBuildTracingOptions(initConfiguration);
  if (!allowedTracingUrls) {
    return;
  }
  var baseConfiguration = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.validateAndBuildConfiguration)(initConfiguration);
  if (!baseConfiguration) {
    return;
  }
  var trackUserInteractions = !!((_c = initConfiguration.trackUserInteractions) !== null && _c !== void 0 ? _c : initConfiguration.trackInteractions);
  var trackFrustrations = !!initConfiguration.trackFrustrations;
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.assign)({
    applicationId: initConfiguration.applicationId,
    version: initConfiguration.version,
    actionNameAttribute: initConfiguration.actionNameAttribute,
    sessionReplaySampleRate: (_e = (_d = initConfiguration.sessionReplaySampleRate) !== null && _d !== void 0 ? _d : premiumSampleRate) !== null && _e !== void 0 ? _e : 100,
    oldPlansBehavior: initConfiguration.sessionReplaySampleRate === undefined,
    traceSampleRate: traceSampleRate,
    allowedTracingUrls: allowedTracingUrls,
    excludedActivityUrls: (_f = initConfiguration.excludedActivityUrls) !== null && _f !== void 0 ? _f : [],
    trackUserInteractions: trackUserInteractions || trackFrustrations,
    trackFrustrations: trackFrustrations,
    trackViewsManually: !!initConfiguration.trackViewsManually,
    trackResources: initConfiguration.trackResources,
    trackLongTasks: initConfiguration.trackLongTasks,
    subdomain: initConfiguration.subdomain,
    defaultPrivacyLevel: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.objectHasValue)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.DefaultPrivacyLevel, initConfiguration.defaultPrivacyLevel) ? initConfiguration.defaultPrivacyLevel : _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.DefaultPrivacyLevel.MASK_USER_INPUT,
    customerDataTelemetrySampleRate: 1
  }, baseConfiguration);
}
/**
 * Handles allowedTracingUrls and processes legacy allowedTracingOrigins
 */
function validateAndBuildTracingOptions(initConfiguration) {
  // Advise about parameters precedence.
  if (initConfiguration.allowedTracingUrls !== undefined && initConfiguration.allowedTracingOrigins !== undefined) {
    _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.warn('Both allowedTracingUrls and allowedTracingOrigins (deprecated) have been defined. The parameter allowedTracingUrls will override allowedTracingOrigins.');
  }
  // Handle allowedTracingUrls first
  if (initConfiguration.allowedTracingUrls !== undefined) {
    if (!Array.isArray(initConfiguration.allowedTracingUrls)) {
      _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.error('Allowed Tracing URLs should be an array');
      return;
    }
    if (initConfiguration.allowedTracingUrls.length !== 0 && initConfiguration.service === undefined) {
      _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.error('Service needs to be configured when tracing is enabled');
      return;
    }
    // Convert from (MatchOption | TracingOption) to TracingOption, remove unknown properties
    var tracingOptions_1 = [];
    initConfiguration.allowedTracingUrls.forEach(function (option) {
      if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.isMatchOption)(option)) {
        tracingOptions_1.push({
          match: option,
          propagatorTypes: ['datadog']
        });
      } else if ((0,_tracing_tracer__WEBPACK_IMPORTED_MODULE_0__.isTracingOption)(option)) {
        tracingOptions_1.push(option);
      } else {
        _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.warn('Allowed Tracing Urls parameters should be a string, RegExp, function, or an object. Ignoring parameter', option);
      }
    });
    return tracingOptions_1;
  }
  // Handle conversion of allowedTracingOrigins to allowedTracingUrls
  if (initConfiguration.allowedTracingOrigins !== undefined) {
    if (!Array.isArray(initConfiguration.allowedTracingOrigins)) {
      _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.error('Allowed Tracing Origins should be an array');
      return;
    }
    if (initConfiguration.allowedTracingOrigins.length !== 0 && initConfiguration.service === undefined) {
      _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.error('Service needs to be configured when tracing is enabled');
      return;
    }
    var tracingOptions_2 = [];
    initConfiguration.allowedTracingOrigins.forEach(function (legacyMatchOption) {
      var tracingOption = convertLegacyMatchOptionToTracingOption(legacyMatchOption);
      if (tracingOption) {
        tracingOptions_2.push(tracingOption);
      }
    });
    return tracingOptions_2;
  }
  return [];
}
/**
 * Converts parameters from the deprecated allowedTracingOrigins
 * to allowedTracingUrls. Handles the change from origin to full URLs.
 */
function convertLegacyMatchOptionToTracingOption(item) {
  var match;
  if (typeof item === 'string') {
    match = item;
  } else if (item instanceof RegExp) {
    match = function (url) {
      return item.test((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.getOrigin)(url));
    };
  } else if (typeof item === 'function') {
    match = function (url) {
      return item((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.getOrigin)(url));
    };
  }
  if (match === undefined) {
    _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.display.warn('Allowed Tracing Origins parameters should be a string, RegExp or function. Ignoring parameter', item);
    return undefined;
  }
  return {
    match: match,
    propagatorTypes: ['datadog']
  };
}
/**
 * Combines the selected tracing propagators from the different options in allowedTracingUrls,
 * and assumes 'datadog' has been selected when using allowedTracingOrigins
 */
function getSelectedTracingPropagators(configuration) {
  var usedTracingPropagators = new Set();
  if (Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0) {
    configuration.allowedTracingUrls.forEach(function (option) {
      if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.isMatchOption)(option)) {
        usedTracingPropagators.add('datadog');
      } else {
        option.propagatorTypes.forEach(function (propagatorType) {
          return usedTracingPropagators.add(propagatorType);
        });
      }
    });
  }
  if (Array.isArray(configuration.allowedTracingOrigins) && configuration.allowedTracingOrigins.length > 0) {
    usedTracingPropagators.add('datadog');
  }
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.arrayFrom)(usedTracingPropagators);
}
function serializeRumConfiguration(configuration) {
  var _a, _b;
  var baseSerializedConfiguration = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.serializeConfiguration)(configuration);
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.assign)({
    premium_sample_rate: configuration.premiumSampleRate,
    replay_sample_rate: configuration.replaySampleRate,
    session_replay_sample_rate: configuration.sessionReplaySampleRate,
    trace_sample_rate: (_a = configuration.traceSampleRate) !== null && _a !== void 0 ? _a : configuration.tracingSampleRate,
    action_name_attribute: configuration.actionNameAttribute,
    use_allowed_tracing_origins: Array.isArray(configuration.allowedTracingOrigins) && configuration.allowedTracingOrigins.length > 0,
    use_allowed_tracing_urls: Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0,
    selected_tracing_propagators: getSelectedTracingPropagators(configuration),
    default_privacy_level: configuration.defaultPrivacyLevel,
    use_excluded_activity_urls: Array.isArray(configuration.allowedTracingOrigins) && configuration.allowedTracingOrigins.length > 0,
    track_frustrations: configuration.trackFrustrations,
    track_views_manually: configuration.trackViewsManually,
    track_user_interactions: (_b = configuration.trackUserInteractions) !== null && _b !== void 0 ? _b : configuration.trackInteractions
  }, baseSerializedConfiguration);
}
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ 591981:
/*!*************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/contexts/ciTestContext.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCiTestContext": () => (/* binding */ getCiTestContext)
/* harmony export */ });
function getCiTestContext() {
  var _a;
  var testExecutionId = (_a = window.Cypress) === null || _a === void 0 ? void 0 : _a.env('traceId');
  if (typeof testExecutionId === 'string') {
    return {
      test_execution_id: testExecutionId
    };
  }
}
//# sourceMappingURL=ciTestContext.js.map

/***/ }),

/***/ 459300:
/*!*************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/contexts/commonContext.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildCommonContext": () => (/* binding */ buildCommonContext)
/* harmony export */ });
function buildCommonContext(globalContextManager, userContextManager, recorderApi) {
  return {
    context: globalContextManager.getContext(),
    user: userContextManager.getContext(),
    hasReplay: recorderApi.isRecording() ? true : undefined
  };
}
//# sourceMappingURL=commonContext.js.map

/***/ }),

/***/ 429767:
/*!**************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/contexts/displayContext.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDisplayContext": () => (/* binding */ getDisplayContext),
/* harmony export */   "resetDisplayContext": () => (/* binding */ resetDisplayContext)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 393968);
/* harmony import */ var _browser_viewportObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../browser/viewportObservable */ 845755);


var viewport;
var stopListeners;
function getDisplayContext() {
  if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ExperimentalFeature.CLICKMAP)) {
    return;
  }
  if (!viewport) {
    viewport = (0,_browser_viewportObservable__WEBPACK_IMPORTED_MODULE_0__.getViewportDimension)();
    stopListeners = (0,_browser_viewportObservable__WEBPACK_IMPORTED_MODULE_0__.initViewportObservable)().subscribe(function (viewportDimension) {
      viewport = viewportDimension;
    }).unsubscribe;
  }
  return {
    viewport: viewport
  };
}
function resetDisplayContext() {
  if (stopListeners) {
    stopListeners();
  }
  viewport = undefined;
}
//# sourceMappingURL=displayContext.js.map

/***/ }),

/***/ 728625:
/*!******************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/contexts/featureFlagContext.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BYTES_COMPUTATION_THROTTLING_DELAY": () => (/* binding */ BYTES_COMPUTATION_THROTTLING_DELAY),
/* harmony export */   "FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY": () => (/* binding */ FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY),
/* harmony export */   "startFeatureFlagContexts": () => (/* binding */ startFeatureFlagContexts)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 212127);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 85010);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 393968);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 712530);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 226590);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 837585);

var FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.SESSION_TIME_OUT_DELAY;
var BYTES_COMPUTATION_THROTTLING_DELAY = 200;
/**
 * Start feature flag contexts
 *
 * Feature flag contexts follow the life of views.
 * A new context is added when a view is created and ended when the view is ended
 *
 * Note: we choose not to add a new context at each evaluation to save memory
 */
function startFeatureFlagContexts(lifeCycle, computeBytesCountImpl) {
  if (computeBytesCountImpl === void 0) {
    computeBytesCountImpl = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.computeBytesCount;
  }
  if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.ExperimentalFeature.FEATURE_FLAGS)) {
    return {
      findFeatureFlagEvaluations: function () {
        return undefined;
      },
      getFeatureFlagBytesCount: function () {
        return 0;
      },
      addFeatureFlagEvaluation: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.noop
    };
  }
  var featureFlagContexts = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.ValueHistory(FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY);
  var bytesCountCache = 0;
  var alreadyWarned = false;
  lifeCycle.subscribe(4 /* LifeCycleEventType.VIEW_ENDED */, function (_a) {
    var endClocks = _a.endClocks;
    featureFlagContexts.closeActive(endClocks.relative);
  });
  lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, function (_a) {
    var startClocks = _a.startClocks;
    featureFlagContexts.add({}, startClocks.relative);
    bytesCountCache = 0;
  });
  // Throttle the bytes computation to minimize the impact on performance.
  // Especially useful if the user call addFeatureFlagEvaluation API synchronously multiple times in a row
  var computeBytesCountThrottled = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.throttle)(function (context) {
    bytesCountCache = computeBytesCountImpl((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.jsonStringify)(context));
    if (!alreadyWarned) {
      alreadyWarned = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.warnIfCustomerDataLimitReached)(bytesCountCache, "feature flag evaluation" /* CustomerDataType.FeatureFlag */);
    }
  }, BYTES_COMPUTATION_THROTTLING_DELAY).throttled;
  return {
    findFeatureFlagEvaluations: function (startTime) {
      return featureFlagContexts.find(startTime);
    },
    getFeatureFlagBytesCount: function () {
      var currentContext = featureFlagContexts.find();
      if (!currentContext) {
        return 0;
      }
      return bytesCountCache;
    },
    addFeatureFlagEvaluation: function (key, value) {
      var currentContext = featureFlagContexts.find();
      if (currentContext) {
        currentContext[key] = value;
        computeBytesCountThrottled(currentContext);
      }
    }
  };
}
//# sourceMappingURL=featureFlagContext.js.map

/***/ }),

/***/ 718758:
/*!******************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/contexts/foregroundContexts.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS": () => (/* binding */ MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS),
/* harmony export */   "MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS": () => (/* binding */ MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS),
/* harmony export */   "addNewForegroundPeriod": () => (/* binding */ addNewForegroundPeriod),
/* harmony export */   "closeForegroundPeriod": () => (/* binding */ closeForegroundPeriod),
/* harmony export */   "startForegroundContexts": () => (/* binding */ startForegroundContexts)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 822006);

// Arbitrary value to cap number of element mostly for backend & to save bandwidth
var MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS = 500;
// Arbitrary value to cap number of element mostly for memory consumption in the browser
var MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS = 2500;
var foregroundPeriods = [];
function startForegroundContexts() {
  if (document.hasFocus()) {
    addNewForegroundPeriod();
  }
  var stopForegroundTracking = trackFocus(addNewForegroundPeriod).stop;
  var stopBlurTracking = trackBlur(closeForegroundPeriod).stop;
  return {
    isInForegroundAt: isInForegroundAt,
    selectInForegroundPeriodsFor: selectInForegroundPeriodsFor,
    stop: function () {
      foregroundPeriods = [];
      stopForegroundTracking();
      stopBlurTracking();
    }
  };
}
function addNewForegroundPeriod() {
  if (foregroundPeriods.length > MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS) {
    return;
  }
  var currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1];
  var now = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.relativeNow)();
  if (currentForegroundPeriod !== undefined && currentForegroundPeriod.end === undefined) {
    return;
  }
  foregroundPeriods.push({
    start: now
  });
}
function closeForegroundPeriod() {
  if (foregroundPeriods.length === 0) {
    return;
  }
  var currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1];
  var now = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.relativeNow)();
  if (currentForegroundPeriod.end !== undefined) {
    return;
  }
  currentForegroundPeriod.end = now;
}
function trackFocus(onFocusChange) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.addEventListener)(window, "focus" /* DOM_EVENT.FOCUS */, function (event) {
    if (!event.isTrusted) {
      return;
    }
    onFocusChange();
  });
}
function trackBlur(onBlurChange) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.addEventListener)(window, "blur" /* DOM_EVENT.BLUR */, function (event) {
    if (!event.isTrusted) {
      return;
    }
    onBlurChange();
  });
}
function isInForegroundAt(startTime) {
  for (var i = foregroundPeriods.length - 1; i >= 0; i--) {
    var foregroundPeriod = foregroundPeriods[i];
    if (foregroundPeriod.end !== undefined && startTime > foregroundPeriod.end) {
      break;
    }
    if (startTime > foregroundPeriod.start && (foregroundPeriod.end === undefined || startTime < foregroundPeriod.end)) {
      return true;
    }
  }
  return false;
}
function selectInForegroundPeriodsFor(eventStartTime, duration) {
  var eventEndTime = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.addDuration)(eventStartTime, duration);
  var filteredForegroundPeriods = [];
  var earliestIndex = Math.max(0, foregroundPeriods.length - MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS);
  for (var i = foregroundPeriods.length - 1; i >= earliestIndex; i--) {
    var foregroundPeriod = foregroundPeriods[i];
    if (foregroundPeriod.end !== undefined && eventStartTime > foregroundPeriod.end) {
      // event starts after the end of the current focus period
      // since the array is sorted, we can stop looking for foreground periods
      break;
    }
    if (eventEndTime < foregroundPeriod.start) {
      // event ends before the start of the current focus period
      // continue to previous one
      continue;
    }
    var startTime = eventStartTime > foregroundPeriod.start ? eventStartTime : foregroundPeriod.start;
    var startDuration = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.elapsed)(eventStartTime, startTime);
    var endTime = foregroundPeriod.end === undefined || eventEndTime < foregroundPeriod.end ? eventEndTime : foregroundPeriod.end;
    var endDuration = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.elapsed)(startTime, endTime);
    filteredForegroundPeriods.unshift({
      start: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.toServerDuration)(startDuration),
      duration: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.toServerDuration)(endDuration)
    });
  }
  return filteredForegroundPeriods;
}
//# sourceMappingURL=foregroundContexts.js.map

/***/ }),

/***/ 598536:
/*!***************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/contexts/internalContext.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startInternalContext": () => (/* binding */ startInternalContext)
/* harmony export */ });
/**
 * Internal context keep returning v1 format
 * to not break compatibility with logs data format
 */
function startInternalContext(applicationId, sessionManager, viewContexts, actionContexts, urlContexts) {
  return {
    get: function (startTime) {
      var viewContext = viewContexts.findView(startTime);
      var urlContext = urlContexts.findUrl(startTime);
      var session = sessionManager.findTrackedSession(startTime);
      if (session && viewContext && urlContext) {
        var actionId = actionContexts.findActionId(startTime);
        return {
          application_id: applicationId,
          session_id: session.id,
          user_action: actionId ? {
            id: actionId
          } : undefined,
          view: {
            id: viewContext.id,
            name: viewContext.name,
            referrer: urlContext.referrer,
            url: urlContext.url
          }
        };
      }
    }
  };
}
//# sourceMappingURL=internalContext.js.map

/***/ }),

/***/ 636608:
/*!****************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/contexts/pageStateHistory.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MAX_PAGE_STATE_ENTRIES": () => (/* binding */ MAX_PAGE_STATE_ENTRIES),
/* harmony export */   "addPageState": () => (/* binding */ addPageState),
/* harmony export */   "resetPageStates": () => (/* binding */ resetPageStates),
/* harmony export */   "startPageStateHistory": () => (/* binding */ startPageStateHistory)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 822006);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 573647);

var MAX_PAGE_STATE_ENTRIES = 500;
var pageStateEntries = [];
var currentPageState;
function startPageStateHistory() {
  addPageState(getPageState());
  var stop = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.addEventListeners)(window, ["pageshow" /* DOM_EVENT.PAGE_SHOW */, "focus" /* DOM_EVENT.FOCUS */, "blur" /* DOM_EVENT.BLUR */, "visibilitychange" /* DOM_EVENT.VISIBILITY_CHANGE */, "resume" /* DOM_EVENT.RESUME */, "freeze" /* DOM_EVENT.FREEZE */, "pagehide" /* DOM_EVENT.PAGE_HIDE */], function (event) {
    // Only get events fired by the browser to avoid false currentPageState changes done with custom events
    // cf: developer extension auto flush: https://github.com/DataDog/browser-sdk/blob/2f72bf05a672794c9e33965351964382a94c72ba/developer-extension/src/panel/flushEvents.ts#L11-L12
    if (!event.isTrusted) {
      return;
    }
    if (event.type === "freeze" /* DOM_EVENT.FREEZE */) {
      addPageState("frozen" /* PageState.FROZEN */);
    } else if (event.type === "pagehide" /* DOM_EVENT.PAGE_HIDE */) {
      addPageState(event.persisted ? "frozen" /* PageState.FROZEN */ : "terminated" /* PageState.TERMINATED */);
    } else {
      addPageState(getPageState());
    }
  }, {
    capture: true
  }).stop;
  return {
    findAll: function (startTime, duration) {
      var entries = [];
      var endTime = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.addDuration)(startTime, duration);
      for (var i = pageStateEntries.length - 1; i >= 0; i--) {
        var stateStartTime = pageStateEntries[i].startTime;
        if (stateStartTime >= endTime) {
          continue;
        }
        entries.unshift(pageStateEntries[i]);
        if (stateStartTime < startTime) {
          break;
        }
      }
      return entries.length ? entries : undefined;
    },
    stop: stop
  };
}
function getPageState() {
  if (document.visibilityState === 'hidden') {
    return "hidden" /* PageState.HIDDEN */;
  }

  if (document.hasFocus()) {
    return "active" /* PageState.ACTIVE */;
  }

  return "passive" /* PageState.PASSIVE */;
}

function addPageState(nextPageState, maxPageStateEntries) {
  if (maxPageStateEntries === void 0) {
    maxPageStateEntries = MAX_PAGE_STATE_ENTRIES;
  }
  if (nextPageState === currentPageState) {
    return;
  }
  currentPageState = nextPageState;
  if (pageStateEntries.length === maxPageStateEntries) {
    pageStateEntries.shift();
  }
  pageStateEntries.push({
    state: currentPageState,
    startTime: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.relativeNow)()
  });
}
function resetPageStates() {
  pageStateEntries = [];
  currentPageState = undefined;
}
//# sourceMappingURL=pageStateHistory.js.map

/***/ }),

/***/ 976635:
/*!*****************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/contexts/syntheticsContext.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSyntheticsContext": () => (/* binding */ getSyntheticsContext)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 252492);

function getSyntheticsContext() {
  var testId = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.getSyntheticsTestId)();
  var resultId = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.getSyntheticsResultId)();
  if (testId && resultId) {
    return {
      test_id: testId,
      result_id: resultId,
      injected: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.willSyntheticsInjectRum)()
    };
  }
}
//# sourceMappingURL=syntheticsContext.js.map

/***/ }),

/***/ 513136:
/*!***********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/contexts/urlContexts.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "URL_CONTEXT_TIME_OUT_DELAY": () => (/* binding */ URL_CONTEXT_TIME_OUT_DELAY),
/* harmony export */   "startUrlContexts": () => (/* binding */ startUrlContexts)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 212127);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 712530);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 573647);

/**
 * We want to attach to an event:
 * - the url corresponding to its start
 * - the referrer corresponding to the previous view url (or document referrer for initial view)
 */
var URL_CONTEXT_TIME_OUT_DELAY = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.SESSION_TIME_OUT_DELAY;
function startUrlContexts(lifeCycle, locationChangeObservable, location) {
  var urlContextHistory = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ValueHistory(URL_CONTEXT_TIME_OUT_DELAY);
  var previousViewUrl;
  lifeCycle.subscribe(4 /* LifeCycleEventType.VIEW_ENDED */, function (_a) {
    var endClocks = _a.endClocks;
    urlContextHistory.closeActive(endClocks.relative);
  });
  lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, function (_a) {
    var startClocks = _a.startClocks;
    var viewUrl = location.href;
    urlContextHistory.add(buildUrlContext({
      url: viewUrl,
      referrer: !previousViewUrl ? document.referrer : previousViewUrl
    }), startClocks.relative);
    previousViewUrl = viewUrl;
  });
  var locationChangeSubscription = locationChangeObservable.subscribe(function (_a) {
    var newLocation = _a.newLocation;
    var current = urlContextHistory.find();
    if (current) {
      var changeTime = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.relativeNow)();
      urlContextHistory.closeActive(changeTime);
      urlContextHistory.add(buildUrlContext({
        url: newLocation.href,
        referrer: current.referrer
      }), changeTime);
    }
  });
  function buildUrlContext(_a) {
    var url = _a.url,
      referrer = _a.referrer;
    return {
      url: url,
      referrer: referrer
    };
  }
  return {
    findUrl: function (startTime) {
      return urlContextHistory.find(startTime);
    },
    stop: function () {
      locationChangeSubscription.unsubscribe();
      urlContextHistory.stop();
    }
  };
}
//# sourceMappingURL=urlContexts.js.map

/***/ }),

/***/ 347265:
/*!************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/contexts/viewContexts.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VIEW_CONTEXT_TIME_OUT_DELAY": () => (/* binding */ VIEW_CONTEXT_TIME_OUT_DELAY),
/* harmony export */   "startViewContexts": () => (/* binding */ startViewContexts)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 212127);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 712530);

var VIEW_CONTEXT_TIME_OUT_DELAY = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.SESSION_TIME_OUT_DELAY;
function startViewContexts(lifeCycle) {
  var viewContextHistory = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ValueHistory(VIEW_CONTEXT_TIME_OUT_DELAY);
  lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, function (view) {
    viewContextHistory.add(buildViewContext(view), view.startClocks.relative);
  });
  lifeCycle.subscribe(4 /* LifeCycleEventType.VIEW_ENDED */, function (_a) {
    var endClocks = _a.endClocks;
    viewContextHistory.closeActive(endClocks.relative);
  });
  lifeCycle.subscribe(8 /* LifeCycleEventType.SESSION_RENEWED */, function () {
    viewContextHistory.reset();
  });
  function buildViewContext(view) {
    return {
      service: view.service,
      version: view.version,
      id: view.id,
      name: view.name,
      startClocks: view.startClocks
    };
  }
  return {
    findView: function (startTime) {
      return viewContextHistory.find(startTime);
    },
    stop: function () {
      viewContextHistory.stop();
    }
  };
}
//# sourceMappingURL=viewContexts.js.map

/***/ }),

/***/ 320339:
/*!**********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/getSessionReplayUrl.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDatadogSiteUrl": () => (/* binding */ getDatadogSiteUrl),
/* harmony export */   "getSessionReplayUrl": () => (/* binding */ getSessionReplayUrl)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 713312);

function getSessionReplayUrl(configuration, _a) {
  var session = _a.session,
    viewContext = _a.viewContext,
    errorType = _a.errorType;
  var sessionId = session ? session.id : 'no-session-id';
  var parameters = [];
  if (errorType !== undefined) {
    parameters.push("error-type=".concat(errorType));
  }
  if (viewContext) {
    parameters.push("seed=".concat(viewContext.id));
    parameters.push("from=".concat(viewContext.startClocks.timeStamp));
  }
  var origin = getDatadogSiteUrl(configuration);
  var path = "/rum/replay/sessions/".concat(sessionId);
  return "".concat(origin).concat(path, "?").concat(parameters.join('&'));
}
function getDatadogSiteUrl(rumConfiguration) {
  var site = rumConfiguration.site;
  var subdomain = rumConfiguration.subdomain || getSiteDefaultSubdomain(rumConfiguration);
  return "https://".concat(subdomain ? "".concat(subdomain, ".") : '').concat(site);
}
function getSiteDefaultSubdomain(configuration) {
  switch (configuration.site) {
    case _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.INTAKE_SITE_US1:
    case _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.INTAKE_SITE_EU1:
      return 'app';
    case _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.INTAKE_SITE_STAGING:
      return 'dd';
    default:
      return undefined;
  }
}
//# sourceMappingURL=getSessionReplayUrl.js.map

/***/ }),

/***/ 762618:
/*!************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/lifeCycle.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LifeCycle": () => (/* binding */ LifeCycle)
/* harmony export */ });
var LifeCycle = /** @class */function () {
  function LifeCycle() {
    this.callbacks = {};
  }
  LifeCycle.prototype.notify = function (eventType, data) {
    var eventCallbacks = this.callbacks[eventType];
    if (eventCallbacks) {
      eventCallbacks.forEach(function (callback) {
        return callback(data);
      });
    }
  };
  LifeCycle.prototype.subscribe = function (eventType, callback) {
    var _this = this;
    if (!this.callbacks[eventType]) {
      this.callbacks[eventType] = [];
    }
    this.callbacks[eventType].push(callback);
    return {
      unsubscribe: function () {
        _this.callbacks[eventType] = _this.callbacks[eventType].filter(function (other) {
          return callback !== other;
        });
      }
    };
  };
  return LifeCycle;
}();

//# sourceMappingURL=lifeCycle.js.map

/***/ }),

/***/ 508130:
/*!********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/limitModification.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "limitModification": () => (/* binding */ limitModification)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 307529);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 938993);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 393968);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 595530);

/**
 * Current limitation:
 * - field path do not support array, 'a.b.c' only
 */
function limitModification(object, modifiableFieldPaths, modifier) {
  var clone = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.deepClone)(object);
  var result = modifier(clone);
  modifiableFieldPaths.forEach(function (path) {
    var originalValue = get(object, path);
    var newValue = get(clone, path);
    var originalType = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.getType)(originalValue);
    var newType = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.getType)(newValue);
    if (newType === originalType) {
      set(object, path, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.ExperimentalFeature.SANITIZE_INPUTS) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.sanitize)(newValue) : newValue);
    } else if (originalType === 'object' && (newType === 'undefined' || newType === 'null')) {
      set(object, path, {});
    }
  });
  return result;
}
function get(object, path) {
  var current = object;
  for (var _i = 0, _a = path.split('.'); _i < _a.length; _i++) {
    var field = _a[_i];
    if (!isValidObjectContaining(current, field)) {
      return;
    }
    current = current[field];
  }
  return current;
}
function set(object, path, value) {
  var current = object;
  var fields = path.split('.');
  for (var i = 0; i < fields.length; i += 1) {
    var field = fields[i];
    if (!isValidObjectContaining(current, field)) {
      return;
    }
    if (i !== fields.length - 1) {
      current = current[field];
    } else {
      current[field] = value;
    }
  }
}
function isValidObjectContaining(object, field) {
  return typeof object === 'object' && object !== null && Object.prototype.hasOwnProperty.call(object, field);
}
//# sourceMappingURL=limitModification.js.map

/***/ }),

/***/ 684297:
/*!********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/requestCollection.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startRequestCollection": () => (/* binding */ startRequestCollection),
/* harmony export */   "trackFetch": () => (/* binding */ trackFetch),
/* harmony export */   "trackXhr": () => (/* binding */ trackXhr)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 995176);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 847357);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 908493);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 271048);
/* harmony import */ var _rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rumEventsCollection/resource/resourceUtils */ 604579);
/* harmony import */ var _tracing_tracer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracing/tracer */ 264320);



var nextRequestIndex = 1;
function startRequestCollection(lifeCycle, configuration, sessionManager) {
  var tracer = (0,_tracing_tracer__WEBPACK_IMPORTED_MODULE_1__.startTracer)(configuration, sessionManager);
  trackXhr(lifeCycle, configuration, tracer);
  trackFetch(lifeCycle, configuration, tracer);
}
function trackXhr(lifeCycle, configuration, tracer) {
  var subscription = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.initXhrObservable)().subscribe(function (rawContext) {
    var context = rawContext;
    if (!(0,_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_0__.isAllowedRequestUrl)(configuration, context.url)) {
      return;
    }
    switch (context.state) {
      case 'start':
        tracer.traceXhr(context, context.xhr);
        context.requestIndex = getNextRequestIndex();
        lifeCycle.notify(5 /* LifeCycleEventType.REQUEST_STARTED */, {
          requestIndex: context.requestIndex,
          url: context.url
        });
        break;
      case 'complete':
        tracer.clearTracingIfNeeded(context);
        lifeCycle.notify(6 /* LifeCycleEventType.REQUEST_COMPLETED */, {
          duration: context.duration,
          method: context.method,
          requestIndex: context.requestIndex,
          spanId: context.spanId,
          startClocks: context.startClocks,
          status: context.status,
          traceId: context.traceId,
          traceSampled: context.traceSampled,
          type: "xhr" /* RequestType.XHR */,
          url: context.url,
          xhr: context.xhr
        });
        break;
    }
  });
  return {
    stop: function () {
      return subscription.unsubscribe();
    }
  };
}
function trackFetch(lifeCycle, configuration, tracer) {
  var subscription = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.initFetchObservable)().subscribe(function (rawContext) {
    var context = rawContext;
    if (!(0,_rumEventsCollection_resource_resourceUtils__WEBPACK_IMPORTED_MODULE_0__.isAllowedRequestUrl)(configuration, context.url)) {
      return;
    }
    switch (context.state) {
      case 'start':
        tracer.traceFetch(context);
        context.requestIndex = getNextRequestIndex();
        lifeCycle.notify(5 /* LifeCycleEventType.REQUEST_STARTED */, {
          requestIndex: context.requestIndex,
          url: context.url
        });
        break;
      case 'resolve':
        waitForResponseToComplete(context, function (duration) {
          tracer.clearTracingIfNeeded(context);
          lifeCycle.notify(6 /* LifeCycleEventType.REQUEST_COMPLETED */, {
            duration: duration,
            method: context.method,
            requestIndex: context.requestIndex,
            responseType: context.responseType,
            spanId: context.spanId,
            startClocks: context.startClocks,
            status: context.status,
            traceId: context.traceId,
            traceSampled: context.traceSampled,
            type: "fetch" /* RequestType.FETCH */,
            url: context.url,
            response: context.response,
            init: context.init,
            input: context.input
          });
        });
        break;
    }
  });
  return {
    stop: function () {
      return subscription.unsubscribe();
    }
  };
}
function getNextRequestIndex() {
  var result = nextRequestIndex;
  nextRequestIndex += 1;
  return result;
}
function waitForResponseToComplete(context, callback) {
  var clonedResponse = context.response && (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.tryToClone)(context.response);
  if (!clonedResponse || !clonedResponse.body) {
    // do not try to wait for the response if the clone failed, fetch error or null body
    callback((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.elapsed)(context.startClocks.timeStamp, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.timeStampNow)()));
  } else {
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.readBytesFromStream)(clonedResponse.body, function () {
      callback((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.elapsed)(context.startClocks.timeStamp, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.timeStampNow)()));
    }, {
      bytesLimit: Number.POSITIVE_INFINITY,
      collectStreamBody: false
    });
  }
}
//# sourceMappingURL=requestCollection.js.map

/***/ }),

/***/ 886199:
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/actionCollection.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startActionCollection": () => (/* binding */ startActionCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 307529);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 347666);
/* harmony import */ var _trackClickActions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trackClickActions */ 470995);


function startActionCollection(lifeCycle, domMutationObservable, configuration, foregroundContexts) {
  lifeCycle.subscribe(1 /* LifeCycleEventType.AUTO_ACTION_COMPLETED */, function (action) {
    return lifeCycle.notify(10 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processAction(action, foregroundContexts));
  });
  var actionContexts = {
    findActionId: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.noop
  };
  if (configuration.trackUserInteractions) {
    actionContexts = (0,_trackClickActions__WEBPACK_IMPORTED_MODULE_0__.trackClickActions)(lifeCycle, domMutationObservable, configuration).actionContexts;
  }
  return {
    addAction: function (action, savedCommonContext) {
      lifeCycle.notify(10 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.assign)({
        savedCommonContext: savedCommonContext
      }, processAction(action, foregroundContexts)));
    },
    actionContexts: actionContexts
  };
}
function processAction(action, foregroundContexts) {
  var autoActionProperties = isAutoAction(action) ? {
    action: {
      id: action.id,
      loading_time: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.toServerDuration)(action.duration),
      frustration: {
        type: action.frustrationTypes
      },
      error: {
        count: action.counts.errorCount
      },
      long_task: {
        count: action.counts.longTaskCount
      },
      resource: {
        count: action.counts.resourceCount
      }
    },
    _dd: {
      action: {
        target: action.target,
        position: action.position
      }
    }
  } : undefined;
  var customerContext = !isAutoAction(action) ? action.context : undefined;
  var actionEvent = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.combine)({
    action: {
      id: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.generateUUID)(),
      target: {
        name: action.name
      },
      type: action.type
    },
    date: action.startClocks.timeStamp,
    type: "action" /* RumEventType.ACTION */
  }, autoActionProperties);
  var inForeground = foregroundContexts.isInForegroundAt(action.startClocks.relative);
  if (inForeground !== undefined) {
    actionEvent.view = {
      in_foreground: inForeground
    };
  }
  return {
    customerContext: customerContext,
    rawRumEvent: actionEvent,
    startTime: action.startClocks.relative,
    domainContext: isAutoAction(action) ? {
      event: action.event,
      events: action.events
    } : {}
  };
}
function isAutoAction(action) {
  return action.type !== "custom" /* ActionType.CUSTOM */;
}
//# sourceMappingURL=actionCollection.js.map

/***/ }),

/***/ 243505:
/*!****************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/clickChain.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MAX_DISTANCE_BETWEEN_CLICKS": () => (/* binding */ MAX_DISTANCE_BETWEEN_CLICKS),
/* harmony export */   "MAX_DURATION_BETWEEN_CLICKS": () => (/* binding */ MAX_DURATION_BETWEEN_CLICKS),
/* harmony export */   "createClickChain": () => (/* binding */ createClickChain)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 631128);

var MAX_DURATION_BETWEEN_CLICKS = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.ONE_SECOND;
var MAX_DISTANCE_BETWEEN_CLICKS = 100;
function createClickChain(firstClick, onFinalize) {
  var bufferedClicks = [];
  var status = 0 /* ClickChainStatus.WaitingForMoreClicks */;
  var maxDurationBetweenClicksTimeout;
  appendClick(firstClick);
  function appendClick(click) {
    click.stopObservable.subscribe(tryFinalize);
    bufferedClicks.push(click);
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.clearTimeout)(maxDurationBetweenClicksTimeout);
    maxDurationBetweenClicksTimeout = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.setTimeout)(dontAcceptMoreClick, MAX_DURATION_BETWEEN_CLICKS);
  }
  function tryFinalize() {
    if (status === 1 /* ClickChainStatus.WaitingForClicksToStop */ && bufferedClicks.every(function (click) {
      return click.isStopped();
    })) {
      status = 2 /* ClickChainStatus.Finalized */;
      onFinalize(bufferedClicks);
    }
  }
  function dontAcceptMoreClick() {
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.clearTimeout)(maxDurationBetweenClicksTimeout);
    if (status === 0 /* ClickChainStatus.WaitingForMoreClicks */) {
      status = 1 /* ClickChainStatus.WaitingForClicksToStop */;
      tryFinalize();
    }
  }
  return {
    tryAppend: function (click) {
      if (status !== 0 /* ClickChainStatus.WaitingForMoreClicks */) {
        return false;
      }
      if (bufferedClicks.length > 0 && !areEventsSimilar(bufferedClicks[bufferedClicks.length - 1].event, click.event)) {
        dontAcceptMoreClick();
        return false;
      }
      appendClick(click);
      return true;
    },
    stop: function () {
      dontAcceptMoreClick();
    }
  };
}
/**
 * Checks whether two events are similar by comparing their target, position and timestamp
 */
function areEventsSimilar(first, second) {
  return first.target === second.target && mouseEventDistance(first, second) <= MAX_DISTANCE_BETWEEN_CLICKS && first.timeStamp - second.timeStamp <= MAX_DURATION_BETWEEN_CLICKS;
}
function mouseEventDistance(origin, other) {
  return Math.sqrt(Math.pow(origin.clientX - other.clientX, 2) + Math.pow(origin.clientY - other.clientY, 2));
}
//# sourceMappingURL=clickChain.js.map

/***/ }),

/***/ 697827:
/*!************************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/computeFrustration.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "computeFrustration": () => (/* binding */ computeFrustration),
/* harmony export */   "isDead": () => (/* binding */ isDead),
/* harmony export */   "isRage": () => (/* binding */ isRage)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 777760);

var MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE = 3;
function computeFrustration(clicks, rageClick) {
  if (isRage(clicks)) {
    rageClick.addFrustration("rage_click" /* FrustrationType.RAGE_CLICK */);
    if (clicks.some(isDead)) {
      rageClick.addFrustration("dead_click" /* FrustrationType.DEAD_CLICK */);
    }

    if (rageClick.hasError) {
      rageClick.addFrustration("error_click" /* FrustrationType.ERROR_CLICK */);
    }

    return {
      isRage: true
    };
  }
  var hasSelectionChanged = clicks.some(function (click) {
    return click.getUserActivity().selection;
  });
  clicks.forEach(function (click) {
    if (click.hasError) {
      click.addFrustration("error_click" /* FrustrationType.ERROR_CLICK */);
    }

    if (isDead(click) &&
    // Avoid considering clicks part of a double-click or triple-click selections as dead clicks
    !hasSelectionChanged) {
      click.addFrustration("dead_click" /* FrustrationType.DEAD_CLICK */);
    }
  });

  return {
    isRage: false
  };
}
function isRage(clicks) {
  if (clicks.some(function (click) {
    return click.getUserActivity().selection;
  })) {
    return false;
  }
  for (var i = 0; i < clicks.length - (MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1); i += 1) {
    if (clicks[i + MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1].event.timeStamp - clicks[i].event.timeStamp <= _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.ONE_SECOND) {
      return true;
    }
  }
  return false;
}
var DEAD_CLICK_EXCLUDE_SELECTOR =
// inputs that don't trigger a meaningful event like "input" when clicked, including textual
// inputs (using a negative selector is shorter here)
'input:not([type="checkbox"]):not([type="radio"]):not([type="button"]):not([type="submit"]):not([type="reset"]):not([type="range"]),' + 'textarea,' + 'select,' +
// contenteditable and their descendants don't always trigger meaningful changes when manipulated
'[contenteditable],' + '[contenteditable] *,' +
// canvas, as there is no good way to detect activity occurring on them
'canvas,' +
// links that are interactive (have an href attribute) or any of their descendants, as they can
// open a new tab or navigate to a hash without triggering a meaningful event
'a[href],' + 'a[href] *';
function isDead(click) {
  if (click.hasPageActivity || click.getUserActivity().input) {
    return false;
  }
  return !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.elementMatches)(click.event.target, DEAD_CLICK_EXCLUDE_SELECTOR);
}
//# sourceMappingURL=computeFrustration.js.map

/***/ }),

/***/ 869922:
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/getActionNameFromElement.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE": () => (/* binding */ DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE),
/* harmony export */   "getActionNameFromElement": () => (/* binding */ getActionNameFromElement)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 347666);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 64637);

/**
 * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.
 * It can also be retrieved from a user defined attribute.
 */
var DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = 'data-dd-action-name';
function getActionNameFromElement(element, userProgrammaticAttribute) {
  // Proceed to get the action name in two steps:
  // * first, get the name programmatically, explicitly defined by the user.
  // * then, use strategies that are known to return good results. Those strategies will be used on
  //   the element and a few parents, but it's likely that they won't succeed at all.
  // * if no name is found this way, use strategies returning less accurate names as a fallback.
  //   Those are much likely to succeed.
  return getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) || userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute) || getActionNameFromElementForStrategies(element, userProgrammaticAttribute, priorityStrategies) || getActionNameFromElementForStrategies(element, userProgrammaticAttribute, fallbackStrategies) || '';
}
function getActionNameFromElementProgrammatically(targetElement, programmaticAttribute) {
  var elementWithAttribute;
  // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,
  // without limit. It is up to the user to declare a relevant naming strategy.
  // If available, use element.closest() to match get the attribute from the element or any of its
  // parent.  Else fallback to a more traditional implementation.
  if (supportsElementClosest()) {
    elementWithAttribute = targetElement.closest("[".concat(programmaticAttribute, "]"));
  } else {
    var element = targetElement;
    while (element) {
      if (element.hasAttribute(programmaticAttribute)) {
        elementWithAttribute = element;
        break;
      }
      element = element.parentElement;
    }
  }
  if (!elementWithAttribute) {
    return;
  }
  var name = elementWithAttribute.getAttribute(programmaticAttribute);
  return truncate(normalizeWhitespace(name.trim()));
}
var priorityStrategies = [
// associated LABEL text
function (element, userProgrammaticAttribute) {
  // IE does not support element.labels, so we fallback to a CSS selector based on the element id
  // instead
  if (supportsLabelProperty()) {
    if ('labels' in element && element.labels && element.labels.length > 0) {
      return getTextualContent(element.labels[0], userProgrammaticAttribute);
    }
  } else if (element.id) {
    var label = element.ownerDocument && (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.find)(element.ownerDocument.querySelectorAll('label'), function (label) {
      return label.htmlFor === element.id;
    });
    return label && getTextualContent(label, userProgrammaticAttribute);
  }
},
// INPUT button (and associated) value
function (element) {
  if (element.nodeName === 'INPUT') {
    var input = element;
    var type = input.getAttribute('type');
    if (type === 'button' || type === 'submit' || type === 'reset') {
      return input.value;
    }
  }
},
// BUTTON, LABEL or button-like element text
function (element, userProgrammaticAttribute) {
  if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {
    return getTextualContent(element, userProgrammaticAttribute);
  }
}, function (element) {
  return element.getAttribute('aria-label');
},
// associated element text designated by the aria-labelledby attribute
function (element, userProgrammaticAttribute) {
  var labelledByAttribute = element.getAttribute('aria-labelledby');
  if (labelledByAttribute) {
    return labelledByAttribute.split(/\s+/).map(function (id) {
      return getElementById(element, id);
    }).filter(function (label) {
      return Boolean(label);
    }).map(function (element) {
      return getTextualContent(element, userProgrammaticAttribute);
    }).join(' ');
  }
}, function (element) {
  return element.getAttribute('alt');
}, function (element) {
  return element.getAttribute('name');
}, function (element) {
  return element.getAttribute('title');
}, function (element) {
  return element.getAttribute('placeholder');
},
// SELECT first OPTION text
function (element, userProgrammaticAttribute) {
  if ('options' in element && element.options.length > 0) {
    return getTextualContent(element.options[0], userProgrammaticAttribute);
  }
}];
var fallbackStrategies = [function (element, userProgrammaticAttribute) {
  return getTextualContent(element, userProgrammaticAttribute);
}];
/**
 * Iterates over the target element and its parent, using the strategies list to get an action name.
 * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.
 */
var MAX_PARENTS_TO_CONSIDER = 10;
function getActionNameFromElementForStrategies(targetElement, userProgrammaticAttribute, strategies) {
  var element = targetElement;
  var recursionCounter = 0;
  while (recursionCounter <= MAX_PARENTS_TO_CONSIDER && element && element.nodeName !== 'BODY' && element.nodeName !== 'HTML' && element.nodeName !== 'HEAD') {
    for (var _i = 0, strategies_1 = strategies; _i < strategies_1.length; _i++) {
      var strategy = strategies_1[_i];
      var name_1 = strategy(element, userProgrammaticAttribute);
      if (typeof name_1 === 'string') {
        var trimmedName = name_1.trim();
        if (trimmedName) {
          return truncate(normalizeWhitespace(trimmedName));
        }
      }
    }
    // Consider a FORM as a contextual limit to get the action name.  This is experimental and may
    // be reconsidered in the future.
    if (element.nodeName === 'FORM') {
      break;
    }
    element = element.parentElement;
    recursionCounter += 1;
  }
}
function normalizeWhitespace(s) {
  return s.replace(/\s+/g, ' ');
}
function truncate(s) {
  return s.length > 100 ? "".concat((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.safeTruncate)(s, 100), " [...]") : s;
}
function getElementById(refElement, id) {
  // Use the element ownerDocument here, because tests are executed in an iframe, so
  // document.getElementById won't work.
  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null;
}
function getTextualContent(element, userProgrammaticAttribute) {
  if (element.isContentEditable) {
    return;
  }
  if ('innerText' in element) {
    var text_1 = element.innerText;
    var removeTextFromElements = function (query) {
      var list = element.querySelectorAll(query);
      for (var index = 0; index < list.length; index += 1) {
        var element_1 = list[index];
        if ('innerText' in element_1) {
          var textToReplace = element_1.innerText;
          if (textToReplace && textToReplace.trim().length > 0) {
            text_1 = text_1.replace(textToReplace, '');
          }
        }
      }
    };
    if (!supportsInnerTextScriptAndStyleRemoval()) {
      // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should
      // be relatively fast and work in most cases.
      removeTextFromElements('script, style');
    }
    // remove the text of elements with programmatic attribute value
    removeTextFromElements("[".concat(DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE, "]"));
    if (userProgrammaticAttribute) {
      removeTextFromElements("[".concat(userProgrammaticAttribute, "]"));
    }
    return text_1;
  }
  return element.textContent;
}
/**
 * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element. This
 * should be the case everywhere except on Internet Explorer 10 and 11 (see [1])
 *
 * The innerText property relies on what is actually rendered to compute its output, so to check if
 * it actually excludes SCRIPT and STYLE content, a solution would be to create a style element, set
 * its content to '*', inject it in the document body, and check if the style element innerText
 * property returns '*'. Using a new `document` instance won't work as it is not rendered.
 *
 * This solution requires specific CSP rules (see [2]) to be set by the customer. We want to avoid
 * this, so instead we rely on browser detection. In case of false negative, the impact should be
 * low, since we rely on this result to remove the SCRIPT and STYLE innerText (which will be empty)
 * from a parent element innerText.
 *
 * [1]: https://web.archive.org/web/20210602165716/http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent
 * [2]: https://github.com/DataDog/browser-sdk/issues/1084
 */
function supportsInnerTextScriptAndStyleRemoval() {
  return !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.isIE)();
}
/**
 * Returns true if the browser supports the element.labels property.  This should be the case
 * everywhere except on Internet Explorer.
 * Note: The result is computed lazily, because we don't want any DOM access when the SDK is
 * evaluated.
 */
var supportsLabelPropertyResult;
function supportsLabelProperty() {
  if (supportsLabelPropertyResult === undefined) {
    supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype;
  }
  return supportsLabelPropertyResult;
}
/**
 * Returns true if the browser supports the element.closest method.  This should be the case
 * everywhere except on Internet Explorer.
 * Note: The result is computed lazily, because we don't want any DOM access when the SDK is
 * evaluated.
 */
var supportsElementClosestResult;
function supportsElementClosest() {
  if (supportsElementClosestResult === undefined) {
    supportsElementClosestResult = 'closest' in HTMLElement.prototype;
  }
  return supportsElementClosestResult;
}
//# sourceMappingURL=getActionNameFromElement.js.map

/***/ }),

/***/ 571719:
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/getSelectorFromElement.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "STABLE_ATTRIBUTES": () => (/* binding */ STABLE_ATTRIBUTES),
/* harmony export */   "getSelectorFromElement": () => (/* binding */ getSelectorFromElement),
/* harmony export */   "supportScopeSelector": () => (/* binding */ supportScopeSelector)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _getActionNameFromElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getActionNameFromElement */ 869922);


/**
 * Stable attributes are attributes that are commonly used to identify parts of a UI (ex:
 * component). Those attribute values should not be generated randomly (hardcoded most of the time)
 * and stay the same across deploys. They are not necessarily unique across the document.
 */
var STABLE_ATTRIBUTES = [_getActionNameFromElement__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,
// Common test attributes (list provided by google recorder)
'data-testid', 'data-test', 'data-qa', 'data-cy', 'data-test-id', 'data-qa-id', 'data-testing',
// FullStory decorator attributes:
'data-component', 'data-element', 'data-source-file'];
// Selectors to use if they target a single element on the whole document. Those selectors are
// considered as "stable" and uniquely identify an element regardless of the page state. If we find
// one, we should consider the selector "complete" and stop iterating over ancestors.
var GLOBALLY_UNIQUE_SELECTOR_GETTERS = [getStableAttributeSelector, getIDSelector];
// Selectors to use if they target a single element among an element descendants. Those selectors
// are more brittle than "globally unique" selectors and should be combined with ancestor selectors
// to improve specificity.
var UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS = [getStableAttributeSelector, getClassSelector, getTagNameSelector];
function getSelectorFromElement(targetElement, actionNameAttribute) {
  var targetElementSelector = '';
  var element = targetElement;
  while (element && element.nodeName !== 'HTML') {
    var globallyUniqueSelector = findSelector(element, GLOBALLY_UNIQUE_SELECTOR_GETTERS, isSelectorUniqueGlobally, actionNameAttribute, targetElementSelector);
    if (globallyUniqueSelector) {
      return globallyUniqueSelector;
    }
    var uniqueSelectorAmongChildren = findSelector(element, UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS, isSelectorUniqueAmongSiblings, actionNameAttribute, targetElementSelector);
    targetElementSelector = uniqueSelectorAmongChildren || combineSelector(getPositionSelector(element), targetElementSelector);
    element = element.parentElement;
  }
  return targetElementSelector;
}
function isGeneratedValue(value) {
  // To compute the "URL path group", the backend replaces every URL path parts as a question mark
  // if it thinks the part is an identifier. The condition it uses is to checks whether a digit is
  // present.
  //
  // Here, we use the same strategy: if a the value contains a digit, we consider it generated. This
  // strategy might be a bit naive and fail in some cases, but there are many fallbacks to generate
  // CSS selectors so it should be fine most of the time. We might want to allow customers to
  // provide their own `isGeneratedValue` at some point.
  return /[0-9]/.test(value);
}
function getIDSelector(element) {
  if (element.id && !isGeneratedValue(element.id)) {
    return "#".concat((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.cssEscape)(element.id));
  }
}
function getClassSelector(element) {
  if (element.tagName === 'BODY') {
    return;
  }
  if (element.classList.length > 0) {
    for (var i = 0; i < element.classList.length; i += 1) {
      var className = element.classList[i];
      if (isGeneratedValue(className)) {
        continue;
      }
      return "".concat(element.tagName, ".").concat((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.cssEscape)(className));
    }
  }
}
function getTagNameSelector(element) {
  return element.tagName;
}
function getStableAttributeSelector(element, actionNameAttribute) {
  if (actionNameAttribute) {
    var selector = getAttributeSelector(actionNameAttribute);
    if (selector) {
      return selector;
    }
  }
  for (var _i = 0, STABLE_ATTRIBUTES_1 = STABLE_ATTRIBUTES; _i < STABLE_ATTRIBUTES_1.length; _i++) {
    var attributeName = STABLE_ATTRIBUTES_1[_i];
    var selector = getAttributeSelector(attributeName);
    if (selector) {
      return selector;
    }
  }
  function getAttributeSelector(attributeName) {
    if (element.hasAttribute(attributeName)) {
      return "".concat(element.tagName, "[").concat(attributeName, "=\"").concat((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.cssEscape)(element.getAttribute(attributeName)), "\"]");
    }
  }
}
function getPositionSelector(element) {
  var sibling = element.parentElement.firstElementChild;
  var elementIndex = 1;
  while (sibling && sibling !== element) {
    if (sibling.tagName === element.tagName) {
      elementIndex += 1;
    }
    sibling = sibling.nextElementSibling;
  }
  return "".concat(element.tagName, ":nth-of-type(").concat(elementIndex, ")");
}
function findSelector(element, selectorGetters, predicate, actionNameAttribute, childSelector) {
  for (var _i = 0, selectorGetters_1 = selectorGetters; _i < selectorGetters_1.length; _i++) {
    var selectorGetter = selectorGetters_1[_i];
    var elementSelector = selectorGetter(element, actionNameAttribute);
    if (!elementSelector) {
      continue;
    }
    var fullSelector = combineSelector(elementSelector, childSelector);
    if (predicate(element, fullSelector)) {
      return fullSelector;
    }
  }
}
/**
 * Check whether the selector is unique among the whole document.
 */
function isSelectorUniqueGlobally(element, selector) {
  return element.ownerDocument.querySelectorAll(selector).length === 1;
}
/**
 * Check whether the selector is unique among the element siblings. In other words, it returns true
 * if "ELEMENT_PARENT > SELECTOR" returns a single element.
 *
 * The result will be less accurate on browsers that don't support :scope (i. e. IE): it will check
 * for any element matching the selector contained in the parent (in other words,
 * "ELEMENT_PARENT SELECTOR" returns a single element), regardless of whether the selector is a
 * direct descendent of the element parent. This should not impact results too much: if it
 * inaccurately returns false, we'll just fall back to another strategy.
 */
function isSelectorUniqueAmongSiblings(element, selector) {
  return element.parentElement.querySelectorAll(supportScopeSelector() ? combineSelector(':scope', selector) : selector).length === 1;
}
function combineSelector(parent, child) {
  return child ? "".concat(parent, ">").concat(child) : parent;
}
var supportScopeSelectorCache;
function supportScopeSelector() {
  if (supportScopeSelectorCache === undefined) {
    try {
      document.querySelector(':scope');
      supportScopeSelectorCache = true;
    } catch (_a) {
      supportScopeSelectorCache = false;
    }
  }
  return supportScopeSelectorCache;
}
//# sourceMappingURL=getSelectorFromElement.js.map

/***/ }),

/***/ 604501:
/*!************************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/listenActionEvents.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "listenActionEvents": () => (/* binding */ listenActionEvents)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 822006);

function listenActionEvents(_a) {
  var onPointerDown = _a.onPointerDown,
    onPointerUp = _a.onPointerUp;
  var selectionEmptyAtPointerDown;
  var userActivity = {
    selection: false,
    input: false
  };
  var clickContext;
  var listeners = [(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.addEventListener)(window, "pointerdown" /* DOM_EVENT.POINTER_DOWN */, function (event) {
    if (isValidPointerEvent(event)) {
      selectionEmptyAtPointerDown = isSelectionEmpty();
      userActivity = {
        selection: false,
        input: false
      };
      clickContext = onPointerDown(event);
    }
  }, {
    capture: true
  }), (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.addEventListener)(window, "selectionchange" /* DOM_EVENT.SELECTION_CHANGE */, function () {
    if (!selectionEmptyAtPointerDown || !isSelectionEmpty()) {
      userActivity.selection = true;
    }
  }, {
    capture: true
  }), (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.addEventListener)(window, "pointerup" /* DOM_EVENT.POINTER_UP */, function (event) {
    if (isValidPointerEvent(event) && clickContext) {
      // Use a scoped variable to make sure the value is not changed by other clicks
      var localUserActivity_1 = userActivity;
      onPointerUp(clickContext, event, function () {
        return localUserActivity_1;
      });
      clickContext = undefined;
    }
  }, {
    capture: true
  }), (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.addEventListener)(window, "input" /* DOM_EVENT.INPUT */, function () {
    userActivity.input = true;
  }, {
    capture: true
  })];
  return {
    stop: function () {
      listeners.forEach(function (listener) {
        return listener.stop();
      });
    }
  };
}
function isSelectionEmpty() {
  var selection = window.getSelection();
  return !selection || selection.isCollapsed;
}
function isValidPointerEvent(event) {
  return event.target instanceof Element &&
  // Only consider 'primary' pointer events for now. Multi-touch support could be implemented in
  // the future.
  event.isPrimary !== false;
}
//# sourceMappingURL=listenActionEvents.js.map

/***/ }),

/***/ 470995:
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/action/trackClickActions.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ACTION_CONTEXT_TIME_OUT_DELAY": () => (/* binding */ ACTION_CONTEXT_TIME_OUT_DELAY),
/* harmony export */   "CLICK_ACTION_MAX_DURATION": () => (/* binding */ CLICK_ACTION_MAX_DURATION),
/* harmony export */   "finalizeClicks": () => (/* binding */ finalizeClicks),
/* harmony export */   "trackClickActions": () => (/* binding */ trackClickActions)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 712530);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @datadog/browser-core */ 32189);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @datadog/browser-core */ 393968);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @datadog/browser-core */ 347666);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _trackEventCounts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../trackEventCounts */ 935237);
/* harmony import */ var _waitPageActivityEnd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../waitPageActivityEnd */ 276212);
/* harmony import */ var _clickChain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./clickChain */ 243505);
/* harmony import */ var _getActionNameFromElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getActionNameFromElement */ 869922);
/* harmony import */ var _getSelectorFromElement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getSelectorFromElement */ 571719);
/* harmony import */ var _listenActionEvents__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./listenActionEvents */ 604501);
/* harmony import */ var _computeFrustration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./computeFrustration */ 697827);








// Maximum duration for click actions
var CLICK_ACTION_MAX_DURATION = 10 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.ONE_SECOND;
var ACTION_CONTEXT_TIME_OUT_DELAY = 5 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.ONE_MINUTE; // arbitrary
function trackClickActions(lifeCycle, domMutationObservable, configuration) {
  var history = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.ValueHistory(ACTION_CONTEXT_TIME_OUT_DELAY);
  var stopObservable = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.Observable();
  var currentClickChain;
  lifeCycle.subscribe(8 /* LifeCycleEventType.SESSION_RENEWED */, function () {
    history.reset();
  });
  lifeCycle.subscribe(4 /* LifeCycleEventType.VIEW_ENDED */, stopClickChain);
  var stopActionEventsListener = (0,_listenActionEvents__WEBPACK_IMPORTED_MODULE_5__.listenActionEvents)({
    onPointerDown: function (pointerDownEvent) {
      return processPointerDown(configuration, lifeCycle, domMutationObservable, history, pointerDownEvent);
    },
    onPointerUp: function (_a, startEvent, getUserActivity) {
      var clickActionBase = _a.clickActionBase,
        hadActivityOnPointerDown = _a.hadActivityOnPointerDown;
      return startClickAction(configuration, lifeCycle, domMutationObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown);
    }
  }).stop;
  var actionContexts = {
    findActionId: function (startTime) {
      return configuration.trackFrustrations ? history.findAll(startTime) : history.find(startTime);
    }
  };
  return {
    stop: function () {
      stopClickChain();
      stopObservable.notify();
      stopActionEventsListener();
    },
    actionContexts: actionContexts
  };
  function appendClickToClickChain(click) {
    if (!currentClickChain || !currentClickChain.tryAppend(click)) {
      var rageClick_1 = click.clone();
      currentClickChain = (0,_clickChain__WEBPACK_IMPORTED_MODULE_2__.createClickChain)(click, function (clicks) {
        finalizeClicks(clicks, rageClick_1);
      });
    }
  }
  function stopClickChain() {
    if (currentClickChain) {
      currentClickChain.stop();
    }
  }
}
function processPointerDown(configuration, lifeCycle, domMutationObservable, history, pointerDownEvent) {
  if (!configuration.trackFrustrations && history.find()) {
    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any new
    // action if another one is already occurring.
    return;
  }
  var clickActionBase = computeClickActionBase(pointerDownEvent, configuration.actionNameAttribute);
  if (!configuration.trackFrustrations && !clickActionBase.name) {
    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any action
    // with a blank name
    return;
  }
  var hadActivityOnPointerDown = false;
  (0,_waitPageActivityEnd__WEBPACK_IMPORTED_MODULE_1__.waitPageActivityEnd)(lifeCycle, domMutationObservable, configuration, function (pageActivityEndEvent) {
    hadActivityOnPointerDown = pageActivityEndEvent.hadActivity;
  },
  // We don't care about the activity duration, we just want to know whether an activity did happen
  // within the "validation delay" or not. Limit the duration so the callback is called sooner.
  _waitPageActivityEnd__WEBPACK_IMPORTED_MODULE_1__.PAGE_ACTIVITY_VALIDATION_DELAY);
  return {
    clickActionBase: clickActionBase,
    hadActivityOnPointerDown: function () {
      return hadActivityOnPointerDown;
    }
  };
}
function startClickAction(configuration, lifeCycle, domMutationObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown) {
  var click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent);
  if (configuration.trackFrustrations) {
    appendClickToClickChain(click);
  }
  var stopWaitPageActivityEnd = (0,_waitPageActivityEnd__WEBPACK_IMPORTED_MODULE_1__.waitPageActivityEnd)(lifeCycle, domMutationObservable, configuration, function (pageActivityEndEvent) {
    if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {
      // If the clock is looking weird, just discard the click
      click.discard();
    } else {
      if (pageActivityEndEvent.hadActivity) {
        click.stop(pageActivityEndEvent.end);
      } else if (hadActivityOnPointerDown()) {
        click.stop(
        // using the click start as activity end, so the click will have some activity but its
        // duration will be 0 (as the activity started before the click start)
        click.startClocks.timeStamp);
      } else {
        click.stop();
      }
      // Validate or discard the click only if we don't track frustrations. It'll be done when
      // the click chain is finalized.
      if (!configuration.trackFrustrations) {
        if (!pageActivityEndEvent.hadActivity) {
          // If we are not tracking frustrations, we should discard the click to keep backward
          // compatibility.
          click.discard();
        } else {
          click.validate();
        }
      }
    }
  }, CLICK_ACTION_MAX_DURATION).stop;
  var viewEndedSubscription = lifeCycle.subscribe(4 /* LifeCycleEventType.VIEW_ENDED */, function (_a) {
    var endClocks = _a.endClocks;
    click.stop(endClocks.timeStamp);
  });
  var stopSubscription = stopObservable.subscribe(function () {
    click.stop();
  });
  click.stopObservable.subscribe(function () {
    viewEndedSubscription.unsubscribe();
    stopWaitPageActivityEnd();
    stopSubscription.unsubscribe();
  });
}
function computeClickActionBase(event, actionNameAttribute) {
  var target;
  var position;
  if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_10__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_10__.ExperimentalFeature.CLICKMAP)) {
    var rect = event.target.getBoundingClientRect();
    target = {
      width: Math.round(rect.width),
      height: Math.round(rect.height),
      selector: (0,_getSelectorFromElement__WEBPACK_IMPORTED_MODULE_4__.getSelectorFromElement)(event.target, actionNameAttribute)
    };
    position = {
      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element
      x: Math.round(event.clientX - rect.left),
      y: Math.round(event.clientY - rect.top)
    };
  }
  return {
    type: "click" /* ActionType.CLICK */,
    target: target,
    position: position,
    name: (0,_getActionNameFromElement__WEBPACK_IMPORTED_MODULE_3__.getActionNameFromElement)(event.target, actionNameAttribute)
  };
}
function newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent) {
  var id = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_11__.generateUUID)();
  var startClocks = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.clocksNow)();
  var historyEntry = history.add(id, startClocks.relative);
  var eventCountsSubscription = (0,_trackEventCounts__WEBPACK_IMPORTED_MODULE_0__.trackEventCounts)({
    lifeCycle: lifeCycle,
    isChildEvent: function (event) {
      return event.action !== undefined && (Array.isArray(event.action.id) ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__.includes)(event.action.id, id) : event.action.id === id);
    }
  });
  var status = 0 /* ClickStatus.ONGOING */;
  var activityEndTime;
  var frustrationTypes = [];
  var stopObservable = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.Observable();
  function stop(newActivityEndTime) {
    if (status !== 0 /* ClickStatus.ONGOING */) {
      return;
    }
    activityEndTime = newActivityEndTime;
    status = 1 /* ClickStatus.STOPPED */;
    if (activityEndTime) {
      historyEntry.close((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.getRelativeTime)(activityEndTime));
    } else {
      historyEntry.remove();
    }
    eventCountsSubscription.stop();
    stopObservable.notify();
  }
  return {
    event: startEvent,
    stop: stop,
    stopObservable: stopObservable,
    get hasError() {
      return eventCountsSubscription.eventCounts.errorCount > 0;
    },
    get hasPageActivity() {
      return activityEndTime !== undefined;
    },
    getUserActivity: getUserActivity,
    addFrustration: function (frustrationType) {
      frustrationTypes.push(frustrationType);
    },
    startClocks: startClocks,
    isStopped: function () {
      return status === 1 /* ClickStatus.STOPPED */ || status === 2 /* ClickStatus.FINALIZED */;
    },
    clone: function () {
      return newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent);
    },
    validate: function (domEvents) {
      stop();
      if (status !== 1 /* ClickStatus.STOPPED */) {
        return;
      }
      var _a = eventCountsSubscription.eventCounts,
        resourceCount = _a.resourceCount,
        errorCount = _a.errorCount,
        longTaskCount = _a.longTaskCount;
      var clickAction = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_12__.assign)({
        type: "click" /* ActionType.CLICK */,
        duration: activityEndTime && (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.elapsed)(startClocks.timeStamp, activityEndTime),
        startClocks: startClocks,
        id: id,
        frustrationTypes: frustrationTypes,
        counts: {
          resourceCount: resourceCount,
          errorCount: errorCount,
          longTaskCount: longTaskCount
        },
        events: domEvents !== null && domEvents !== void 0 ? domEvents : [startEvent],
        event: startEvent
      }, clickActionBase);
      lifeCycle.notify(1 /* LifeCycleEventType.AUTO_ACTION_COMPLETED */, clickAction);
      status = 2 /* ClickStatus.FINALIZED */;
    },

    discard: function () {
      stop();
      status = 2 /* ClickStatus.FINALIZED */;
    }
  };
}

function finalizeClicks(clicks, rageClick) {
  var isRage = (0,_computeFrustration__WEBPACK_IMPORTED_MODULE_6__.computeFrustration)(clicks, rageClick).isRage;
  if (isRage) {
    clicks.forEach(function (click) {
      return click.discard();
    });
    rageClick.stop((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.timeStampNow)());
    rageClick.validate(clicks.map(function (click) {
      return click.event;
    }));
  } else {
    rageClick.discard();
    clicks.forEach(function (click) {
      return click.validate();
    });
  }
}
//# sourceMappingURL=trackClickActions.js.map

/***/ }),

/***/ 951057:
/*!********************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/error/errorCollection.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "doStartErrorCollection": () => (/* binding */ doStartErrorCollection),
/* harmony export */   "startErrorCollection": () => (/* binding */ startErrorCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 32189);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 210349);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 976474);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 803679);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 347666);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 567934);
/* harmony import */ var _trackConsoleError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trackConsoleError */ 962300);
/* harmony import */ var _trackReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trackReportError */ 960654);



function startErrorCollection(lifeCycle, foregroundContexts, featureFlagContexts) {
  var errorObservable = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.Observable();
  (0,_trackConsoleError__WEBPACK_IMPORTED_MODULE_0__.trackConsoleError)(errorObservable);
  (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.trackRuntimeError)(errorObservable);
  (0,_trackReportError__WEBPACK_IMPORTED_MODULE_1__.trackReportError)(errorObservable);
  errorObservable.subscribe(function (error) {
    return lifeCycle.notify(12 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, {
      error: error
    });
  });
  return doStartErrorCollection(lifeCycle, foregroundContexts, featureFlagContexts);
}
function doStartErrorCollection(lifeCycle, foregroundContexts, featureFlagContexts) {
  lifeCycle.subscribe(12 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, function (_a) {
    var error = _a.error,
      customerContext = _a.customerContext,
      savedCommonContext = _a.savedCommonContext;
    lifeCycle.notify(10 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.assign)({
      customerContext: customerContext,
      savedCommonContext: savedCommonContext
    }, processError(error, foregroundContexts, featureFlagContexts)));
  });
  return {
    addError: function (_a, savedCommonContext) {
      var error = _a.error,
        handlingStack = _a.handlingStack,
        startClocks = _a.startClocks,
        customerContext = _a.context;
      var stackTrace = error instanceof Error ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.computeStackTrace)(error) : undefined;
      var rawError = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.computeRawError)({
        stackTrace: stackTrace,
        originalError: error,
        handlingStack: handlingStack,
        startClocks: startClocks,
        nonErrorPrefix: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.PROVIDED_ERROR_MESSAGE_PREFIX,
        source: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.ErrorSource.CUSTOM,
        handling: "handled" /* ErrorHandling.HANDLED */
      });

      lifeCycle.notify(12 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, {
        customerContext: customerContext,
        savedCommonContext: savedCommonContext,
        error: rawError
      });
    }
  };
}
function processError(error, foregroundContexts, featureFlagContexts) {
  var rawRumEvent = {
    date: error.startClocks.timeStamp,
    error: {
      id: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.generateUUID)(),
      message: error.message,
      source: error.source,
      stack: error.stack,
      handling_stack: error.handlingStack,
      type: error.type,
      handling: error.handling,
      causes: error.causes,
      source_type: 'browser'
    },
    type: "error" /* RumEventType.ERROR */
  };

  var inForeground = foregroundContexts.isInForegroundAt(error.startClocks.relative);
  if (inForeground) {
    rawRumEvent.view = {
      in_foreground: inForeground
    };
  }
  var featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations(error.startClocks.relative);
  if (featureFlagContext && !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.isEmptyObject)(featureFlagContext)) {
    rawRumEvent.feature_flags = featureFlagContext;
  }
  return {
    rawRumEvent: rawRumEvent,
    startTime: error.startClocks.relative,
    domainContext: {
      error: error.originalError
    }
  };
}
//# sourceMappingURL=errorCollection.js.map

/***/ }),

/***/ 962300:
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/error/trackConsoleError.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trackConsoleError": () => (/* binding */ trackConsoleError)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 254074);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 700959);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 803679);

function trackConsoleError(errorObservable) {
  var subscription = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.initConsoleObservable)([_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleApiName.error]).subscribe(function (consoleError) {
    return errorObservable.notify({
      startClocks: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.clocksNow)(),
      message: consoleError.message,
      stack: consoleError.stack,
      source: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.ErrorSource.CONSOLE,
      handling: "handled" /* ErrorHandling.HANDLED */,
      handlingStack: consoleError.handlingStack
    });
  });
  return {
    stop: function () {
      subscription.unsubscribe();
    }
  };
}
//# sourceMappingURL=trackConsoleError.js.map

/***/ }),

/***/ 960654:
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/error/trackReportError.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trackReportError": () => (/* binding */ trackReportError)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 888851);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 803679);

function trackReportError(errorObservable) {
  var subscription = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.initReportObservable)([_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.RawReportType.cspViolation, _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.RawReportType.intervention]).subscribe(function (reportError) {
    return errorObservable.notify({
      startClocks: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.clocksNow)(),
      message: reportError.message,
      stack: reportError.stack,
      type: reportError.subtype,
      source: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.ErrorSource.REPORT,
      handling: "unhandled" /* ErrorHandling.UNHANDLED */
    });
  });

  return {
    stop: function () {
      subscription.unsubscribe();
    }
  };
}
//# sourceMappingURL=trackReportError.js.map

/***/ }),

/***/ 278689:
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/longTask/longTaskCollection.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startLongTaskCollection": () => (/* binding */ startLongTaskCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 347666);

function startLongTaskCollection(lifeCycle, sessionManager) {
  lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {
    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
      var entry = entries_1[_i];
      if (entry.entryType !== 'longtask') {
        break;
      }
      var session = sessionManager.findTrackedSession(entry.startTime);
      if (!session || !session.longTaskAllowed) {
        break;
      }
      var startClocks = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.relativeToClocks)(entry.startTime);
      var rawRumEvent = {
        date: startClocks.timeStamp,
        long_task: {
          id: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.generateUUID)(),
          duration: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.toServerDuration)(entry.duration)
        },
        type: "long_task" /* RumEventType.LONG_TASK */,
        _dd: {
          discarded: false
        }
      };
      lifeCycle.notify(10 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, {
        rawRumEvent: rawRumEvent,
        startTime: startClocks.relative,
        domainContext: {
          performanceEntry: entry.toJSON()
        }
      });
    }
  });
}
//# sourceMappingURL=longTaskCollection.js.map

/***/ }),

/***/ 299424:
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/matchRequestTiming.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "matchRequestTiming": () => (/* binding */ matchRequestTiming)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _resourceUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resourceUtils */ 604579);


/**
 * Look for corresponding timing in resource timing buffer
 *
 * Observations:
 * - Timing (start, end) are nested inside the request (start, end)
 * - Some timing can be not exactly nested, being off by < 1 ms
 *
 * Strategy:
 * - from valid nested entries (with 1 ms error margin)
 * - if a single timing match, return the timing
 * - otherwise we can't decide, return undefined
 */
function matchRequestTiming(request) {
  if (!performance || !('getEntriesByName' in performance)) {
    return;
  }
  var sameNameEntries = performance.getEntriesByName(request.url, 'resource');
  if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {
    return;
  }
  var candidates = sameNameEntries.map(function (entry) {
    return entry.toJSON();
  }).filter(_resourceUtils__WEBPACK_IMPORTED_MODULE_0__.toValidEntry).filter(function (entry) {
    return isBetween(entry, request.startClocks.relative, endTime({
      startTime: request.startClocks.relative,
      duration: request.duration
    }));
  });
  if (candidates.length === 1) {
    return candidates[0];
  }
  return;
}
function endTime(timing) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.addDuration)(timing.startTime, timing.duration);
}
function isBetween(timing, start, end) {
  var errorMargin = 1;
  return timing.startTime >= start - errorMargin && endTime(timing) <= (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.addDuration)(end, errorMargin);
}
//# sourceMappingURL=matchRequestTiming.js.map

/***/ }),

/***/ 44035:
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/resourceCollection.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startResourceCollection": () => (/* binding */ startResourceCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 307529);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 347666);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 159127);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 393968);
/* harmony import */ var _matchRequestTiming__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matchRequestTiming */ 299424);
/* harmony import */ var _resourceUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resourceUtils */ 604579);



function startResourceCollection(lifeCycle, configuration, sessionManager, pageStateHistory) {
  lifeCycle.subscribe(6 /* LifeCycleEventType.REQUEST_COMPLETED */, function (request) {
    lifeCycle.notify(10 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processRequest(request, configuration, sessionManager, pageStateHistory));
  });
  lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {
    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
      var entry = entries_1[_i];
      if (entry.entryType === 'resource' && !(0,_resourceUtils__WEBPACK_IMPORTED_MODULE_1__.isRequestKind)(entry)) {
        lifeCycle.notify(10 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processResourceEntry(entry, configuration, sessionManager, pageStateHistory));
      }
    }
  });
}
function processRequest(request, configuration, sessionManager, pageStateHistory) {
  var _a;
  var type = request.type === "xhr" /* RequestType.XHR */ ? "xhr" /* ResourceType.XHR */ : "fetch" /* ResourceType.FETCH */;
  var matchingTiming = (0,_matchRequestTiming__WEBPACK_IMPORTED_MODULE_0__.matchRequestTiming)(request);
  var startClocks = matchingTiming ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.relativeToClocks)(matchingTiming.startTime) : request.startClocks;
  var correspondingTimingOverrides = matchingTiming ? computePerformanceEntryMetrics(matchingTiming) : undefined;
  var tracingInfo = computeRequestTracingInfo(request, configuration);
  var indexingInfo = computeIndexingInfo(sessionManager, startClocks);
  var duration = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.toServerDuration)(request.duration);
  var pageStateInfo = computePageStateInfo(pageStateHistory, startClocks, (_a = matchingTiming === null || matchingTiming === void 0 ? void 0 : matchingTiming.duration) !== null && _a !== void 0 ? _a : request.duration);
  var resourceEvent = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.combine)({
    date: startClocks.timeStamp,
    resource: {
      id: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.generateUUID)(),
      type: type,
      duration: duration,
      method: request.method,
      status_code: request.status,
      url: request.url
    },
    type: "resource" /* RumEventType.RESOURCE */
  }, tracingInfo, correspondingTimingOverrides, indexingInfo, pageStateInfo);
  return {
    startTime: startClocks.relative,
    rawRumEvent: resourceEvent,
    domainContext: {
      performanceEntry: matchingTiming && toPerformanceEntryRepresentation(matchingTiming),
      xhr: request.xhr,
      response: request.response,
      requestInput: request.input,
      requestInit: request.init,
      error: request.error
    }
  };
}
function processResourceEntry(entry, configuration, sessionManager, pageStateHistory) {
  var type = (0,_resourceUtils__WEBPACK_IMPORTED_MODULE_1__.computeResourceKind)(entry);
  var entryMetrics = computePerformanceEntryMetrics(entry);
  var startClocks = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.relativeToClocks)(entry.startTime);
  var tracingInfo = computeEntryTracingInfo(entry, configuration);
  var indexingInfo = computeIndexingInfo(sessionManager, startClocks);
  var pageStateInfo = computePageStateInfo(pageStateHistory, startClocks, entry.duration);
  var resourceEvent = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.combine)({
    date: startClocks.timeStamp,
    resource: {
      id: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.generateUUID)(),
      type: type,
      url: entry.name
    },
    type: "resource" /* RumEventType.RESOURCE */
  }, tracingInfo, entryMetrics, indexingInfo, pageStateInfo);
  return {
    startTime: startClocks.relative,
    rawRumEvent: resourceEvent,
    domainContext: {
      performanceEntry: toPerformanceEntryRepresentation(entry)
    }
  };
}
function computePerformanceEntryMetrics(timing) {
  return {
    resource: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.assign)({
      duration: (0,_resourceUtils__WEBPACK_IMPORTED_MODULE_1__.computePerformanceResourceDuration)(timing),
      size: (0,_resourceUtils__WEBPACK_IMPORTED_MODULE_1__.computeSize)(timing)
    }, (0,_resourceUtils__WEBPACK_IMPORTED_MODULE_1__.computePerformanceResourceDetails)(timing))
  };
}
function computeRequestTracingInfo(request, configuration) {
  var hasBeenTraced = request.traceSampled && request.traceId && request.spanId;
  if (!hasBeenTraced) {
    return undefined;
  }
  return {
    _dd: {
      span_id: request.spanId.toDecimalString(),
      trace_id: request.traceId.toDecimalString(),
      rule_psr: getRulePsr(configuration)
    }
  };
}
function computeEntryTracingInfo(entry, configuration) {
  var hasBeenTraced = entry.traceId;
  if (!hasBeenTraced) {
    return undefined;
  }
  return {
    _dd: {
      trace_id: entry.traceId,
      rule_psr: getRulePsr(configuration)
    }
  };
}
// TODO next major: use directly PerformanceEntry type in domain context
function toPerformanceEntryRepresentation(entry) {
  return entry;
}
/**
 * @returns number between 0 and 1 which represents trace sample rate
 */
function getRulePsr(configuration) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.isNumber)(configuration.traceSampleRate) ? configuration.traceSampleRate / 100 : undefined;
}
function computeIndexingInfo(sessionManager, resourceStart) {
  var session = sessionManager.findTrackedSession(resourceStart.relative);
  return {
    _dd: {
      discarded: !session || !session.resourceAllowed
    }
  };
}
function computePageStateInfo(pageStateHistory, startClocks, duration) {
  if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.isExperimentalFeatureEnabled)(_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.ExperimentalFeature.RESOURCE_PAGE_STATES)) {
    return;
  }
  return {
    _dd: {
      page_states: pageStateHistory.findAll(startClocks.relative, duration),
      page_was_discarded: String(document.wasDiscarded)
    }
  };
}
//# sourceMappingURL=resourceCollection.js.map

/***/ }),

/***/ 604579:
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/resource/resourceUtils.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FAKE_INITIAL_DOCUMENT": () => (/* binding */ FAKE_INITIAL_DOCUMENT),
/* harmony export */   "computePerformanceResourceDetails": () => (/* binding */ computePerformanceResourceDetails),
/* harmony export */   "computePerformanceResourceDuration": () => (/* binding */ computePerformanceResourceDuration),
/* harmony export */   "computeResourceKind": () => (/* binding */ computeResourceKind),
/* harmony export */   "computeSize": () => (/* binding */ computeSize),
/* harmony export */   "isAllowedRequestUrl": () => (/* binding */ isAllowedRequestUrl),
/* harmony export */   "isRequestKind": () => (/* binding */ isRequestKind),
/* harmony export */   "toValidEntry": () => (/* binding */ toValidEntry)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 77615);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 931942);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 573647);

var FAKE_INITIAL_DOCUMENT = 'initial_document';
var RESOURCE_TYPES = [["document" /* ResourceType.DOCUMENT */, function (initiatorType) {
  return FAKE_INITIAL_DOCUMENT === initiatorType;
}], ["xhr" /* ResourceType.XHR */, function (initiatorType) {
  return 'xmlhttprequest' === initiatorType;
}], ["fetch" /* ResourceType.FETCH */, function (initiatorType) {
  return 'fetch' === initiatorType;
}], ["beacon" /* ResourceType.BEACON */, function (initiatorType) {
  return 'beacon' === initiatorType;
}], ["css" /* ResourceType.CSS */, function (_, path) {
  return /\.css$/i.test(path);
}], ["js" /* ResourceType.JS */, function (_, path) {
  return /\.js$/i.test(path);
}], ["image" /* ResourceType.IMAGE */, function (initiatorType, path) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.includes)(['image', 'img', 'icon'], initiatorType) || /\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null;
}], ["font" /* ResourceType.FONT */, function (_, path) {
  return /\.(woff|eot|woff2|ttf)$/i.exec(path) !== null;
}], ["media" /* ResourceType.MEDIA */, function (initiatorType, path) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.includes)(['audio', 'video'], initiatorType) || /\.(mp3|mp4)$/i.exec(path) !== null;
}]];
function computeResourceKind(timing) {
  var url = timing.name;
  if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.isValidUrl)(url)) {
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.addTelemetryDebug)("Failed to construct URL for \"".concat(timing.name, "\""));
    return "other" /* ResourceType.OTHER */;
  }

  var path = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.getPathName)(url);
  for (var _i = 0, RESOURCE_TYPES_1 = RESOURCE_TYPES; _i < RESOURCE_TYPES_1.length; _i++) {
    var _a = RESOURCE_TYPES_1[_i],
      type = _a[0],
      isType = _a[1];
    if (isType(timing.initiatorType, path)) {
      return type;
    }
  }
  return "other" /* ResourceType.OTHER */;
}

function areInOrder() {
  var numbers = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    numbers[_i] = arguments[_i];
  }
  for (var i = 1; i < numbers.length; i += 1) {
    if (numbers[i - 1] > numbers[i]) {
      return false;
    }
  }
  return true;
}
function isRequestKind(timing) {
  return timing.initiatorType === 'xmlhttprequest' || timing.initiatorType === 'fetch';
}
function computePerformanceResourceDuration(entry) {
  var duration = entry.duration,
    startTime = entry.startTime,
    responseEnd = entry.responseEnd;
  // Safari duration is always 0 on timings blocked by cross origin policies.
  if (duration === 0 && startTime < responseEnd) {
    return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.toServerDuration)((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.elapsed)(startTime, responseEnd));
  }
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.toServerDuration)(duration);
}
function computePerformanceResourceDetails(entry) {
  var validEntry = toValidEntry(entry);
  if (!validEntry) {
    return undefined;
  }
  var startTime = validEntry.startTime,
    fetchStart = validEntry.fetchStart,
    redirectStart = validEntry.redirectStart,
    redirectEnd = validEntry.redirectEnd,
    domainLookupStart = validEntry.domainLookupStart,
    domainLookupEnd = validEntry.domainLookupEnd,
    connectStart = validEntry.connectStart,
    secureConnectionStart = validEntry.secureConnectionStart,
    connectEnd = validEntry.connectEnd,
    requestStart = validEntry.requestStart,
    responseStart = validEntry.responseStart,
    responseEnd = validEntry.responseEnd;
  var details = {
    download: formatTiming(startTime, responseStart, responseEnd),
    first_byte: formatTiming(startTime, requestStart, responseStart)
  };
  // Make sure a connection occurred
  if (connectEnd !== fetchStart) {
    details.connect = formatTiming(startTime, connectStart, connectEnd);
    // Make sure a secure connection occurred
    if (areInOrder(connectStart, secureConnectionStart, connectEnd)) {
      details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd);
    }
  }
  // Make sure a domain lookup occurred
  if (domainLookupEnd !== fetchStart) {
    details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd);
  }
  if (hasRedirection(entry)) {
    details.redirect = formatTiming(startTime, redirectStart, redirectEnd);
  }
  return details;
}
function toValidEntry(entry) {
  // Ensure timings are in the right order. On top of filtering out potential invalid
  // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be
  // collected, for example cross origin requests without a "Timing-Allow-Origin" header allowing
  // it.
  if (!areInOrder(entry.startTime, entry.fetchStart, entry.domainLookupStart, entry.domainLookupEnd, entry.connectStart, entry.connectEnd, entry.requestStart, entry.responseStart, entry.responseEnd)) {
    return undefined;
  }
  if (!hasRedirection(entry)) {
    return entry;
  }
  var redirectStart = entry.redirectStart,
    redirectEnd = entry.redirectEnd;
  // Firefox doesn't provide redirect timings on cross origin requests.
  // Provide a default for those.
  if (redirectStart < entry.startTime) {
    redirectStart = entry.startTime;
  }
  if (redirectEnd < entry.startTime) {
    redirectEnd = entry.fetchStart;
  }
  // Make sure redirect timings are in order
  if (!areInOrder(entry.startTime, redirectStart, redirectEnd, entry.fetchStart)) {
    return undefined;
  }
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.assign)({}, entry, {
    redirectEnd: redirectEnd,
    redirectStart: redirectStart
  });
}
function hasRedirection(entry) {
  // The only time fetchStart is different than startTime is if a redirection occurred.
  return entry.fetchStart !== entry.startTime;
}
function formatTiming(origin, start, end) {
  return {
    duration: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.toServerDuration)((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.elapsed)(start, end)),
    start: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.toServerDuration)((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.elapsed)(origin, start))
  };
}
function computeSize(entry) {
  // Make sure a request actually occurred
  if (entry.startTime < entry.responseStart) {
    return entry.decodedBodySize;
  }
  return undefined;
}
function isAllowedRequestUrl(configuration, url) {
  return url && !configuration.isIntakeUrl(url);
}
//# sourceMappingURL=resourceUtils.js.map

/***/ }),

/***/ 241813:
/*!********************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackFirstHidden.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resetFirstHidden": () => (/* binding */ resetFirstHidden),
/* harmony export */   "trackFirstHidden": () => (/* binding */ trackFirstHidden)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 822006);

var trackFirstHiddenSingleton;
var stopListeners;
function trackFirstHidden(eventTarget) {
  if (eventTarget === void 0) {
    eventTarget = window;
  }
  if (!trackFirstHiddenSingleton) {
    if (document.visibilityState === 'hidden') {
      trackFirstHiddenSingleton = {
        timeStamp: 0
      };
    } else {
      trackFirstHiddenSingleton = {
        timeStamp: Infinity
      };
      stopListeners = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.addEventListeners)(eventTarget, ["pagehide" /* DOM_EVENT.PAGE_HIDE */, "visibilitychange" /* DOM_EVENT.VISIBILITY_CHANGE */], function (event) {
        if (event.type === 'pagehide' || document.visibilityState === 'hidden') {
          trackFirstHiddenSingleton.timeStamp = event.timeStamp;
          stopListeners();
        }
      }, {
        capture: true
      }).stop;
    }
  }
  return trackFirstHiddenSingleton;
}
function resetFirstHidden() {
  if (stopListeners) {
    stopListeners();
  }
  trackFirstHiddenSingleton = undefined;
}
//# sourceMappingURL=trackFirstHidden.js.map

/***/ }),

/***/ 404809:
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackInitialViewTimings.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TIMING_MAXIMUM_DELAY": () => (/* binding */ TIMING_MAXIMUM_DELAY),
/* harmony export */   "trackFirstContentfulPaintTiming": () => (/* binding */ trackFirstContentfulPaintTiming),
/* harmony export */   "trackFirstInputTimings": () => (/* binding */ trackFirstInputTimings),
/* harmony export */   "trackInitialViewTimings": () => (/* binding */ trackInitialViewTimings),
/* harmony export */   "trackLargestContentfulPaintTiming": () => (/* binding */ trackLargestContentfulPaintTiming),
/* harmony export */   "trackNavigationTimings": () => (/* binding */ trackNavigationTimings)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 822006);
/* harmony import */ var _trackFirstHidden__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trackFirstHidden */ 241813);


// Discard LCP and FCP timings above a certain delay to avoid incorrect data
// It happens in some cases like sleep mode or some browser implementations
var TIMING_MAXIMUM_DELAY = 10 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ONE_MINUTE;
function trackInitialViewTimings(lifeCycle, callback) {
  var timings = {};
  function setTimings(newTimings) {
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.assign)(timings, newTimings);
    callback(timings);
  }
  var stopNavigationTracking = trackNavigationTimings(lifeCycle, setTimings).stop;
  var stopFCPTracking = trackFirstContentfulPaintTiming(lifeCycle, function (firstContentfulPaint) {
    return setTimings({
      firstContentfulPaint: firstContentfulPaint
    });
  }).stop;
  var stopLCPTracking = trackLargestContentfulPaintTiming(lifeCycle, window, function (largestContentfulPaint) {
    setTimings({
      largestContentfulPaint: largestContentfulPaint
    });
  }).stop;
  var stopFIDTracking = trackFirstInputTimings(lifeCycle, function (_a) {
    var firstInputDelay = _a.firstInputDelay,
      firstInputTime = _a.firstInputTime;
    setTimings({
      firstInputDelay: firstInputDelay,
      firstInputTime: firstInputTime
    });
  }).stop;
  return {
    stop: function () {
      stopNavigationTracking();
      stopFCPTracking();
      stopLCPTracking();
      stopFIDTracking();
    }
  };
}
function trackNavigationTimings(lifeCycle, callback) {
  var stop = lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {
    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
      var entry = entries_1[_i];
      if (entry.entryType === 'navigation') {
        callback({
          domComplete: entry.domComplete,
          domContentLoaded: entry.domContentLoadedEventEnd,
          domInteractive: entry.domInteractive,
          loadEvent: entry.loadEventEnd,
          // In some cases the value reported is negative or is larger
          // than the current page time. Ignore these cases:
          // https://github.com/GoogleChrome/web-vitals/issues/137
          // https://github.com/GoogleChrome/web-vitals/issues/162
          firstByte: entry.responseStart >= 0 && entry.responseStart <= (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.relativeNow)() ? entry.responseStart : undefined
        });
      }
    }
  }).unsubscribe;
  return {
    stop: stop
  };
}
function trackFirstContentfulPaintTiming(lifeCycle, callback) {
  var firstHidden = (0,_trackFirstHidden__WEBPACK_IMPORTED_MODULE_0__.trackFirstHidden)();
  var stop = lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {
    var fcpEntry = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.find)(entries, function (entry) {
      return entry.entryType === 'paint' && entry.name === 'first-contentful-paint' && entry.startTime < firstHidden.timeStamp && entry.startTime < TIMING_MAXIMUM_DELAY;
    });
    if (fcpEntry) {
      callback(fcpEntry.startTime);
    }
  }).unsubscribe;
  return {
    stop: stop
  };
}
/**
 * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield
 * multiple values, only the most recent one should be used.
 * Documentation: https://web.dev/lcp/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts
 */
function trackLargestContentfulPaintTiming(lifeCycle, eventTarget, callback) {
  var firstHidden = (0,_trackFirstHidden__WEBPACK_IMPORTED_MODULE_0__.trackFirstHidden)();
  // Ignore entries that come after the first user interaction.  According to the documentation, the
  // browser should not send largest-contentful-paint entries after a user interact with the page,
  // but the web-vitals reference implementation uses this as a safeguard.
  var firstInteractionTimestamp = Infinity;
  var stopEventListener = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.addEventListeners)(eventTarget, ["pointerdown" /* DOM_EVENT.POINTER_DOWN */, "keydown" /* DOM_EVENT.KEY_DOWN */], function (event) {
    firstInteractionTimestamp = event.timeStamp;
  }, {
    capture: true,
    once: true
  }).stop;
  var unsubscribeLifeCycle = lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {
    var lcpEntry = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.findLast)(entries, function (entry) {
      return entry.entryType === 'largest-contentful-paint' && entry.startTime < firstInteractionTimestamp && entry.startTime < firstHidden.timeStamp && entry.startTime < TIMING_MAXIMUM_DELAY;
    });
    if (lcpEntry) {
      callback(lcpEntry.startTime);
    }
  }).unsubscribe;
  return {
    stop: function () {
      stopEventListener();
      unsubscribeLifeCycle();
    }
  };
}
/**
 * Track the first input occurring during the initial View to return:
 * - First Input Delay
 * - First Input Time
 * Callback is called at most one time.
 * Documentation: https://web.dev/fid/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts
 */
function trackFirstInputTimings(lifeCycle, callback) {
  var firstHidden = (0,_trackFirstHidden__WEBPACK_IMPORTED_MODULE_0__.trackFirstHidden)();
  var stop = lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {
    var firstInputEntry = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.find)(entries, function (entry) {
      return entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp;
    });
    if (firstInputEntry) {
      var firstInputDelay = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.elapsed)(firstInputEntry.startTime, firstInputEntry.processingStart);
      callback({
        // Ensure firstInputDelay to be positive, see
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815
        firstInputDelay: firstInputDelay >= 0 ? firstInputDelay : 0,
        firstInputTime: firstInputEntry.startTime
      });
    }
  }).unsubscribe;
  return {
    stop: stop
  };
}
//# sourceMappingURL=trackInitialViewTimings.js.map

/***/ }),

/***/ 903369:
/*!************************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackViewEventCounts.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KEEP_TRACKING_EVENT_COUNTS_AFTER_VIEW_DELAY": () => (/* binding */ KEEP_TRACKING_EVENT_COUNTS_AFTER_VIEW_DELAY),
/* harmony export */   "trackViewEventCounts": () => (/* binding */ trackViewEventCounts)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 631128);
/* harmony import */ var _trackEventCounts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../trackEventCounts */ 935237);


// Some events are not being counted as they transcend views. To reduce the occurrence;
// an arbitrary delay is added for stopping event counting after the view ends.
//
// Ideally, we would not stop and keep counting events until the end of the session.
// But this might have a small performance impact if there are many many views:
// we would need to go through each event to see if the related view matches.
// So let's have a fairly short delay to avoid impacting performances too much.
//
// In the future, we could have views stored in a data structure similar to ContextHistory. Whenever
// a child event is collected, we could look into this history to find the matching view and
// increase the associated and increase its counter. Having a centralized data structure for it
// would allow us to look for views more efficiently.
//
// For now, having a small cleanup delay will already improve the situation in most cases.
var KEEP_TRACKING_EVENT_COUNTS_AFTER_VIEW_DELAY = 5 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ONE_MINUTE;
function trackViewEventCounts(lifeCycle, viewId, onChange) {
  var _a = (0,_trackEventCounts__WEBPACK_IMPORTED_MODULE_0__.trackEventCounts)({
      lifeCycle: lifeCycle,
      isChildEvent: function (event) {
        return event.view.id === viewId;
      },
      onChange: onChange
    }),
    stop = _a.stop,
    eventCounts = _a.eventCounts;
  return {
    scheduleStop: function () {
      (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.setTimeout)(stop, KEEP_TRACKING_EVENT_COUNTS_AFTER_VIEW_DELAY);
    },
    eventCounts: eventCounts
  };
}
//# sourceMappingURL=trackViewEventCounts.js.map

/***/ }),

/***/ 306347:
/*!********************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackViewMetrics.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trackViewMetrics": () => (/* binding */ trackViewMetrics)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 159127);
/* harmony import */ var _browser_performanceCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../browser/performanceCollection */ 552575);
/* harmony import */ var _waitPageActivityEnd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../waitPageActivityEnd */ 276212);



function trackViewMetrics(lifeCycle, domMutationObservable, configuration, scheduleViewUpdate, loadingType, viewStart) {
  var viewMetrics = {};
  var _a = trackLoadingTime(lifeCycle, domMutationObservable, configuration, loadingType, viewStart, function (newLoadingTime) {
      viewMetrics.loadingTime = newLoadingTime;
      scheduleViewUpdate();
    }),
    stopLoadingTimeTracking = _a.stop,
    setLoadEvent = _a.setLoadEvent;
  var stopCLSTracking;
  if (isLayoutShiftSupported()) {
    viewMetrics.cumulativeLayoutShift = 0;
    stopCLSTracking = trackCumulativeLayoutShift(lifeCycle, function (cumulativeLayoutShift) {
      viewMetrics.cumulativeLayoutShift = cumulativeLayoutShift;
      scheduleViewUpdate();
    }).stop;
  } else {
    stopCLSTracking = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.noop;
  }
  return {
    stop: function () {
      stopLoadingTimeTracking();
      stopCLSTracking();
    },
    setLoadEvent: setLoadEvent,
    viewMetrics: viewMetrics
  };
}
function trackLoadingTime(lifeCycle, domMutationObservable, configuration, loadType, viewStart, callback) {
  var isWaitingForLoadEvent = loadType === "initial_load" /* ViewLoadingType.INITIAL_LOAD */;
  var isWaitingForActivityLoadingTime = true;
  var loadingTimeCandidates = [];
  function invokeCallbackIfAllCandidatesAreReceived() {
    if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {
      callback(Math.max.apply(Math, loadingTimeCandidates));
    }
  }
  var stop = (0,_waitPageActivityEnd__WEBPACK_IMPORTED_MODULE_1__.waitPageActivityEnd)(lifeCycle, domMutationObservable, configuration, function (event) {
    if (isWaitingForActivityLoadingTime) {
      isWaitingForActivityLoadingTime = false;
      if (event.hadActivity) {
        loadingTimeCandidates.push((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.elapsed)(viewStart.timeStamp, event.end));
      }
      invokeCallbackIfAllCandidatesAreReceived();
    }
  }).stop;
  return {
    stop: stop,
    setLoadEvent: function (loadEvent) {
      if (isWaitingForLoadEvent) {
        isWaitingForLoadEvent = false;
        loadingTimeCandidates.push(loadEvent);
        invokeCallbackIfAllCandidatesAreReceived();
      }
    }
  };
}
/**
 * Track the cumulative layout shifts (CLS).
 * Layout shifts are grouped into session windows.
 * The minimum gap between session windows is 1 second.
 * The maximum duration of a session window is 5 second.
 * The session window layout shift value is the sum of layout shifts inside it.
 * The CLS value is the max of session windows values.
 *
 * This yields a new value whenever the CLS value is updated (a higher session window value is computed).
 *
 * See isLayoutShiftSupported to check for browser support.
 *
 * Documentation:
 * https://web.dev/cls/
 * https://web.dev/evolving-cls/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts
 */
function trackCumulativeLayoutShift(lifeCycle, callback) {
  var maxClsValue = 0;
  var window = slidingSessionWindow();
  var stop = lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {
    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
      var entry = entries_1[_i];
      if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {
        window.update(entry);
        if (window.value() > maxClsValue) {
          maxClsValue = window.value();
          callback((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.round)(maxClsValue, 4));
        }
      }
    }
  }).unsubscribe;
  return {
    stop: stop
  };
}
function slidingSessionWindow() {
  var value = 0;
  var startTime;
  var endTime;
  return {
    update: function (entry) {
      var shouldCreateNewWindow = startTime === undefined || entry.startTime - endTime >= _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.ONE_SECOND || entry.startTime - startTime >= 5 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.ONE_SECOND;
      if (shouldCreateNewWindow) {
        startTime = endTime = entry.startTime;
        value = entry.value;
      } else {
        value += entry.value;
        endTime = entry.startTime;
      }
    },
    value: function () {
      return value;
    }
  };
}
/**
 * Check whether `layout-shift` is supported by the browser.
 */
function isLayoutShiftSupported() {
  return (0,_browser_performanceCollection__WEBPACK_IMPORTED_MODULE_0__.supportPerformanceTimingEvent)('layout-shift');
}
//# sourceMappingURL=trackViewMetrics.js.map

/***/ }),

/***/ 191752:
/*!**************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/trackViews.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SESSION_KEEP_ALIVE_INTERVAL": () => (/* binding */ SESSION_KEEP_ALIVE_INTERVAL),
/* harmony export */   "THROTTLE_VIEW_UPDATE_PERIOD": () => (/* binding */ THROTTLE_VIEW_UPDATE_PERIOD),
/* harmony export */   "trackViews": () => (/* binding */ trackViews)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 37215);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 631128);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 347666);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 567934);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @datadog/browser-core */ 700959);
/* harmony import */ var _trackInitialViewTimings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trackInitialViewTimings */ 404809);
/* harmony import */ var _trackViewMetrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trackViewMetrics */ 306347);
/* harmony import */ var _trackViewEventCounts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trackViewEventCounts */ 903369);




var THROTTLE_VIEW_UPDATE_PERIOD = 3000;
var SESSION_KEEP_ALIVE_INTERVAL = 5 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.ONE_MINUTE;
function trackViews(location, lifeCycle, domMutationObservable, configuration, locationChangeObservable, areViewsTrackedAutomatically, initialViewOptions) {
  var _a = trackInitialView(initialViewOptions),
    stopInitialViewTracking = _a.stop,
    initialView = _a.initialView;
  var currentView = initialView;
  var stopViewLifeCycle = startViewLifeCycle().stop;
  var locationChangeSubscription;
  if (areViewsTrackedAutomatically) {
    locationChangeSubscription = renewViewOnLocationChange(locationChangeObservable);
  }
  function trackInitialView(options) {
    var initialView = newView(lifeCycle, domMutationObservable, configuration, location, "initial_load" /* ViewLoadingType.INITIAL_LOAD */, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.clocksOrigin)(), options);
    var stop = (0,_trackInitialViewTimings__WEBPACK_IMPORTED_MODULE_0__.trackInitialViewTimings)(lifeCycle, function (timings) {
      initialView.updateTimings(timings);
      initialView.scheduleUpdate();
    }).stop;
    return {
      initialView: initialView,
      stop: stop
    };
  }
  function trackViewChange(startClocks, viewOptions) {
    return newView(lifeCycle, domMutationObservable, configuration, location, "route_change" /* ViewLoadingType.ROUTE_CHANGE */, startClocks, viewOptions);
  }
  function startViewLifeCycle() {
    lifeCycle.subscribe(8 /* LifeCycleEventType.SESSION_RENEWED */, function () {
      // do not trigger view update to avoid wrong data
      currentView.end();
      // Renew view on session renewal
      currentView = trackViewChange(undefined, {
        name: currentView.name,
        service: currentView.service,
        version: currentView.version
      });
    });
    // End the current view on page unload
    lifeCycle.subscribe(9 /* LifeCycleEventType.PAGE_EXITED */, function (pageExitEvent) {
      if (pageExitEvent.reason === _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.PageExitReason.UNLOADING || pageExitEvent.reason === _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.PageExitReason.PAGEHIDE) {
        currentView.end();
        currentView.triggerUpdate();
      }
    });
    // Session keep alive
    var keepAliveInterval = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.setInterval)(function () {
      currentView.triggerUpdate();
    }, SESSION_KEEP_ALIVE_INTERVAL);
    return {
      stop: function () {
        (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.clearInterval)(keepAliveInterval);
      }
    };
  }
  function renewViewOnLocationChange(locationChangeObservable) {
    return locationChangeObservable.subscribe(function (_a) {
      var oldLocation = _a.oldLocation,
        newLocation = _a.newLocation;
      if (areDifferentLocation(oldLocation, newLocation)) {
        currentView.end();
        currentView.triggerUpdate();
        currentView = trackViewChange();
        return;
      }
    });
  }
  return {
    addTiming: function (name, time) {
      if (time === void 0) {
        time = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.timeStampNow)();
      }
      currentView.addTiming(name, time);
      currentView.scheduleUpdate();
    },
    startView: function (options, startClocks) {
      currentView.end(startClocks);
      currentView.triggerUpdate();
      currentView = trackViewChange(startClocks, options);
    },
    stop: function () {
      locationChangeSubscription === null || locationChangeSubscription === void 0 ? void 0 : locationChangeSubscription.unsubscribe();
      stopInitialViewTracking();
      stopViewLifeCycle();
      currentView.end();
    }
  };
}
function newView(lifeCycle, domMutationObservable, configuration, initialLocation, loadingType, startClocks, viewOptions) {
  if (startClocks === void 0) {
    startClocks = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.clocksNow)();
  }
  // Setup initial values
  var id = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.generateUUID)();
  var timings = {};
  var customTimings = {};
  var documentVersion = 0;
  var endClocks;
  var location = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.shallowClone)(initialLocation);
  var name;
  var service;
  var version;
  if (viewOptions) {
    name = viewOptions.name;
    service = viewOptions.service;
    version = viewOptions.version;
  }
  lifeCycle.notify(2 /* LifeCycleEventType.VIEW_CREATED */, {
    id: id,
    name: name,
    startClocks: startClocks,
    service: service,
    version: version
  });
  // Update the view every time the measures are changing
  var _a = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.throttle)(triggerViewUpdate, THROTTLE_VIEW_UPDATE_PERIOD, {
      leading: false
    }),
    scheduleViewUpdate = _a.throttled,
    cancelScheduleViewUpdate = _a.cancel;
  var _b = (0,_trackViewMetrics__WEBPACK_IMPORTED_MODULE_1__.trackViewMetrics)(lifeCycle, domMutationObservable, configuration, scheduleViewUpdate, loadingType, startClocks),
    setLoadEvent = _b.setLoadEvent,
    stopViewMetricsTracking = _b.stop,
    viewMetrics = _b.viewMetrics;
  var _c = (0,_trackViewEventCounts__WEBPACK_IMPORTED_MODULE_2__.trackViewEventCounts)(lifeCycle, id, scheduleViewUpdate),
    scheduleStopEventCountsTracking = _c.scheduleStop,
    eventCounts = _c.eventCounts;
  // Initial view update
  triggerViewUpdate();
  function triggerViewUpdate() {
    documentVersion += 1;
    var currentEnd = endClocks === undefined ? (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.timeStampNow)() : endClocks.timeStamp;
    lifeCycle.notify(3 /* LifeCycleEventType.VIEW_UPDATED */, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_9__.assign)({
      customTimings: customTimings,
      documentVersion: documentVersion,
      id: id,
      name: name,
      service: service,
      version: version,
      loadingType: loadingType,
      location: location,
      startClocks: startClocks,
      timings: timings,
      duration: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.elapsed)(startClocks.timeStamp, currentEnd),
      isActive: endClocks === undefined,
      eventCounts: eventCounts
    }, viewMetrics));
  }
  return {
    name: name,
    service: service,
    version: version,
    scheduleUpdate: scheduleViewUpdate,
    end: function (clocks) {
      if (clocks === void 0) {
        clocks = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.clocksNow)();
      }
      endClocks = clocks;
      lifeCycle.notify(4 /* LifeCycleEventType.VIEW_ENDED */, {
        endClocks: endClocks
      });
      stopViewMetricsTracking();
      scheduleStopEventCountsTracking();
    },
    triggerUpdate: function () {
      // cancel any pending view updates execution
      cancelScheduleViewUpdate();
      triggerViewUpdate();
    },
    updateTimings: function (newTimings) {
      timings = newTimings;
      if (newTimings.loadEvent !== undefined) {
        setLoadEvent(newTimings.loadEvent);
      }
    },
    addTiming: function (name, time) {
      var relativeTime = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.looksLikeRelativeTime)(time) ? time : (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.elapsed)(startClocks.timeStamp, time);
      customTimings[sanitizeTiming(name)] = relativeTime;
    }
  };
}
/**
 * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $
 */
function sanitizeTiming(name) {
  var sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_');
  if (sanitized !== name) {
    _datadog_browser_core__WEBPACK_IMPORTED_MODULE_10__.display.warn("Invalid timing name: ".concat(name, ", sanitized to: ").concat(sanitized));
  }
  return sanitized;
}
function areDifferentLocation(currentLocation, otherLocation) {
  return currentLocation.pathname !== otherLocation.pathname || !isHashAnAnchor(otherLocation.hash) && getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash);
}
function isHashAnAnchor(hash) {
  var correspondingId = hash.substr(1);
  return !!document.getElementById(correspondingId);
}
function getPathFromHash(hash) {
  var index = hash.indexOf('?');
  return index < 0 ? hash : hash.slice(0, index);
}
//# sourceMappingURL=trackViews.js.map

/***/ }),

/***/ 22210:
/*!******************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumEventsCollection/view/viewCollection.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startViewCollection": () => (/* binding */ startViewCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 567934);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 159127);
/* harmony import */ var _trackViews__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trackViews */ 191752);


function startViewCollection(lifeCycle, configuration, location, domMutationObservable, locationChangeObservable, foregroundContexts, featureFlagContexts, recorderApi, initialViewOptions) {
  lifeCycle.subscribe(3 /* LifeCycleEventType.VIEW_UPDATED */, function (view) {
    return lifeCycle.notify(10 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, processViewUpdate(view, foregroundContexts, featureFlagContexts, recorderApi));
  });
  return (0,_trackViews__WEBPACK_IMPORTED_MODULE_0__.trackViews)(location, lifeCycle, domMutationObservable, configuration, locationChangeObservable, !configuration.trackViewsManually, initialViewOptions);
}
function processViewUpdate(view, foregroundContexts, featureFlagContexts, recorderApi) {
  var replayStats = recorderApi.getReplayStats(view.id);
  var featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations(view.startClocks.relative);
  var viewEvent = {
    _dd: {
      document_version: view.documentVersion,
      replay_stats: replayStats
    },
    date: view.startClocks.timeStamp,
    type: "view" /* RumEventType.VIEW */,
    view: {
      action: {
        count: view.eventCounts.actionCount
      },
      frustration: {
        count: view.eventCounts.frustrationCount
      },
      cumulative_layout_shift: view.cumulativeLayoutShift,
      first_byte: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration)(view.timings.firstByte),
      dom_complete: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration)(view.timings.domComplete),
      dom_content_loaded: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration)(view.timings.domContentLoaded),
      dom_interactive: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration)(view.timings.domInteractive),
      error: {
        count: view.eventCounts.errorCount
      },
      first_contentful_paint: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration)(view.timings.firstContentfulPaint),
      first_input_delay: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration)(view.timings.firstInputDelay),
      first_input_time: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration)(view.timings.firstInputTime),
      is_active: view.isActive,
      name: view.name,
      largest_contentful_paint: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration)(view.timings.largestContentfulPaint),
      load_event: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration)(view.timings.loadEvent),
      loading_time: discardNegativeDuration((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration)(view.loadingTime)),
      loading_type: view.loadingType,
      long_task: {
        count: view.eventCounts.longTaskCount
      },
      resource: {
        count: view.eventCounts.resourceCount
      },
      time_spent: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration)(view.duration),
      in_foreground_periods: foregroundContexts.selectInForegroundPeriodsFor(view.startClocks.relative, view.duration)
    },
    feature_flags: featureFlagContext && !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.isEmptyObject)(featureFlagContext) ? featureFlagContext : undefined,
    session: {
      has_replay: replayStats ? true : undefined
    }
  };
  if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.isEmptyObject)(view.customTimings)) {
    viewEvent.view.custom_timings = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.mapValues)(view.customTimings, _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.toServerDuration);
  }
  return {
    rawRumEvent: viewEvent,
    startTime: view.startClocks.relative,
    domainContext: {
      location: view.location
    }
  };
}
function discardNegativeDuration(duration) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.isNumber)(duration) && duration < 0 ? undefined : duration;
}
//# sourceMappingURL=viewCollection.js.map

/***/ }),

/***/ 77401:
/*!********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/rumSessionManager.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RUM_SESSION_KEY": () => (/* binding */ RUM_SESSION_KEY),
/* harmony export */   "startRumSessionManager": () => (/* binding */ startRumSessionManager),
/* harmony export */   "startRumSessionManagerStub": () => (/* binding */ startRumSessionManagerStub)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 313031);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 159127);

var RUM_SESSION_KEY = 'rum';
function startRumSessionManager(configuration, lifeCycle) {
  var sessionManager = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.startSessionManager)(configuration.cookieOptions, RUM_SESSION_KEY, function (rawTrackingType) {
    return computeSessionState(configuration, rawTrackingType);
  });
  sessionManager.expireObservable.subscribe(function () {
    lifeCycle.notify(7 /* LifeCycleEventType.SESSION_EXPIRED */);
  });

  sessionManager.renewObservable.subscribe(function () {
    lifeCycle.notify(8 /* LifeCycleEventType.SESSION_RENEWED */);
  });

  return {
    findTrackedSession: function (startTime) {
      var session = sessionManager.findActiveSession(startTime);
      if (!session || !isTypeTracked(session.trackingType)) {
        return;
      }
      var plan = session.trackingType === "1" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */ ? 2 /* RumSessionPlan.WITH_SESSION_REPLAY */ : 1 /* RumSessionPlan.WITHOUT_SESSION_REPLAY */;
      return {
        id: session.id,
        plan: plan,
        sessionReplayAllowed: plan === 2 /* RumSessionPlan.WITH_SESSION_REPLAY */,
        longTaskAllowed: configuration.trackLongTasks !== undefined ? configuration.trackLongTasks : configuration.oldPlansBehavior && plan === 2 /* RumSessionPlan.WITH_SESSION_REPLAY */,
        resourceAllowed: configuration.trackResources !== undefined ? configuration.trackResources : configuration.oldPlansBehavior && plan === 2 /* RumSessionPlan.WITH_SESSION_REPLAY */
      };
    },

    expire: sessionManager.expire
  };
}
/**
 * Start a tracked replay session stub
 */
function startRumSessionManagerStub() {
  var session = {
    id: '00000000-aaaa-0000-aaaa-000000000000',
    plan: 1 /* RumSessionPlan.WITHOUT_SESSION_REPLAY */,
    sessionReplayAllowed: false,
    longTaskAllowed: true,
    resourceAllowed: true
  };
  return {
    findTrackedSession: function () {
      return session;
    },
    expire: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.noop
  };
}
function computeSessionState(configuration, rawTrackingType) {
  var trackingType;
  if (hasValidRumSession(rawTrackingType)) {
    trackingType = rawTrackingType;
  } else if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.performDraw)(configuration.sessionSampleRate)) {
    trackingType = "0" /* RumTrackingType.NOT_TRACKED */;
  } else if (!(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.performDraw)(configuration.sessionReplaySampleRate)) {
    trackingType = "2" /* RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY */;
  } else {
    trackingType = "1" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */;
  }

  return {
    trackingType: trackingType,
    isTracked: isTypeTracked(trackingType)
  };
}
function hasValidRumSession(trackingType) {
  return trackingType === "0" /* RumTrackingType.NOT_TRACKED */ || trackingType === "1" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */ || trackingType === "2" /* RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY */;
}

function isTypeTracked(rumSessionType) {
  return rumSessionType === "2" /* RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY */ || rumSessionType === "1" /* RumTrackingType.TRACKED_WITH_SESSION_REPLAY */;
}
//# sourceMappingURL=rumSessionManager.js.map

/***/ }),

/***/ 546149:
/*!*****************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/startCustomerDataTelemetry.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MEASURES_PERIOD_DURATION": () => (/* binding */ MEASURES_PERIOD_DURATION),
/* harmony export */   "startCustomerDataTelemetry": () => (/* binding */ startCustomerDataTelemetry)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 159127);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 567934);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 631128);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 931942);

var MEASURES_PERIOD_DURATION = 10 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.ONE_SECOND;
var currentPeriodMeasures;
var currentBatchMeasures;
var batchHasRumEvent;
function startCustomerDataTelemetry(configuration, telemetry, lifeCycle, globalContextManager, userContextManager, featureFlagContexts, batchFlushObservable) {
  var customerDataTelemetryEnabled = telemetry.enabled && (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.performDraw)(configuration.customerDataTelemetrySampleRate);
  if (!customerDataTelemetryEnabled) {
    return;
  }
  initCurrentPeriodMeasures();
  initCurrentBatchMeasures();
  // We measure the data of every view updates even if there could only be one per batch due to the upsert
  // It means that contexts bytes count sums can be higher than it really is
  lifeCycle.subscribe(11 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, function (event) {
    batchHasRumEvent = true;
    updateMeasure(currentBatchMeasures.globalContextBytes, !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.isEmptyObject)(globalContextManager.get()) ? globalContextManager.getBytesCount() : 0);
    updateMeasure(currentBatchMeasures.userContextBytes, !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.isEmptyObject)(userContextManager.get()) ? userContextManager.getBytesCount() : 0);
    var featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations();
    var hasFeatureFlagContext = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.includes)(["view" /* RumEventType.VIEW */, "error" /* RumEventType.ERROR */], event.type) && featureFlagContext && !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.isEmptyObject)(featureFlagContext);
    updateMeasure(currentBatchMeasures.featureFlagBytes, hasFeatureFlagContext ? featureFlagContexts.getFeatureFlagBytesCount() : 0);
  });
  batchFlushObservable.subscribe(function (_a) {
    var bytesCount = _a.bytesCount,
      messagesCount = _a.messagesCount;
    // Don't measure batch that only contains telemetry events to avoid batch sending loop
    // It could happen because after each batch we are adding a customer data measures telemetry event to the next one
    if (!batchHasRumEvent) {
      return;
    }
    currentPeriodMeasures.batchCount += 1;
    updateMeasure(currentPeriodMeasures.batchBytesCount, bytesCount);
    updateMeasure(currentPeriodMeasures.batchMessagesCount, messagesCount);
    mergeMeasure(currentPeriodMeasures.globalContextBytes, currentBatchMeasures.globalContextBytes);
    mergeMeasure(currentPeriodMeasures.userContextBytes, currentBatchMeasures.userContextBytes);
    mergeMeasure(currentPeriodMeasures.featureFlagBytes, currentBatchMeasures.featureFlagBytes);
    initCurrentBatchMeasures();
  });
  (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.setInterval)(sendCurrentPeriodMeasures, MEASURES_PERIOD_DURATION);
}
function sendCurrentPeriodMeasures() {
  if (currentPeriodMeasures.batchCount === 0) {
    return;
  }
  (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.addTelemetryDebug)('Customer data measures', currentPeriodMeasures);
  initCurrentPeriodMeasures();
}
function createMeasure() {
  return {
    min: Infinity,
    max: 0,
    sum: 0
  };
}
function updateMeasure(measure, value) {
  measure.sum += value;
  measure.min = Math.min(measure.min, value);
  measure.max = Math.max(measure.max, value);
}
function mergeMeasure(target, source) {
  target.sum += source.sum;
  target.min = Math.min(target.min, source.min);
  target.max = Math.max(target.max, source.max);
}
function initCurrentPeriodMeasures() {
  currentPeriodMeasures = {
    batchCount: 0,
    batchBytesCount: createMeasure(),
    batchMessagesCount: createMeasure(),
    globalContextBytes: createMeasure(),
    userContextBytes: createMeasure(),
    featureFlagBytes: createMeasure()
  };
}
function initCurrentBatchMeasures() {
  batchHasRumEvent = false;
  currentBatchMeasures = {
    globalContextBytes: createMeasure(),
    userContextBytes: createMeasure(),
    featureFlagBytes: createMeasure()
  };
}
//# sourceMappingURL=startCustomerDataTelemetry.js.map

/***/ }),

/***/ 195265:
/*!*****************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/tracing/getDocumentTraceId.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD": () => (/* binding */ INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD),
/* harmony export */   "createDocumentTraceData": () => (/* binding */ createDocumentTraceData),
/* harmony export */   "findTraceComment": () => (/* binding */ findTraceComment),
/* harmony export */   "getDocumentTraceDataFromComment": () => (/* binding */ getDocumentTraceDataFromComment),
/* harmony export */   "getDocumentTraceDataFromMeta": () => (/* binding */ getDocumentTraceDataFromMeta),
/* harmony export */   "getDocumentTraceId": () => (/* binding */ getDocumentTraceId)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 347666);
/* harmony import */ var _browser_htmlDomUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../browser/htmlDomUtils */ 381146);


var INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.ONE_MINUTE;
function getDocumentTraceId(document) {
  var data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document);
  if (!data || data.traceTime <= (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.dateNow)() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {
    return undefined;
  }
  return data.traceId;
}
function getDocumentTraceDataFromMeta(document) {
  var traceIdMeta = document.querySelector('meta[name=dd-trace-id]');
  var traceTimeMeta = document.querySelector('meta[name=dd-trace-time]');
  return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content);
}
function getDocumentTraceDataFromComment(document) {
  var comment = findTraceComment(document);
  if (!comment) {
    return undefined;
  }
  return createDocumentTraceData((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.findCommaSeparatedValue)(comment, 'trace-id'), (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.findCommaSeparatedValue)(comment, 'trace-time'));
}
function createDocumentTraceData(traceId, rawTraceTime) {
  var traceTime = rawTraceTime && Number(rawTraceTime);
  if (!traceId || !traceTime) {
    return undefined;
  }
  return {
    traceId: traceId,
    traceTime: traceTime
  };
}
function findTraceComment(document) {
  // 1. Try to find the comment as a direct child of the document
  // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated
  // value is not an array or string (here, a NodeList).
  for (var i = 0; i < document.childNodes.length; i += 1) {
    var comment = getTraceCommentFromNode(document.childNodes[i]);
    if (comment) {
      return comment;
    }
  }
  // 2. If the comment is placed after the </html> tag, but have some space or new lines before or
  // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.
  // Try to look for the comment at the end of the <body> by by iterating over its child nodes in
  // reverse order, stopping if we come across a non-text node.
  if (document.body) {
    for (var i = document.body.childNodes.length - 1; i >= 0; i -= 1) {
      var node = document.body.childNodes[i];
      var comment = getTraceCommentFromNode(node);
      if (comment) {
        return comment;
      }
      if (!(0,_browser_htmlDomUtils__WEBPACK_IMPORTED_MODULE_0__.isTextNode)(node)) {
        break;
      }
    }
  }
}
function getTraceCommentFromNode(node) {
  if (node && (0,_browser_htmlDomUtils__WEBPACK_IMPORTED_MODULE_0__.isCommentNode)(node)) {
    var match = /^\s*DATADOG;(.*?)\s*$/.exec(node.data);
    if (match) {
      return match[1];
    }
  }
}
//# sourceMappingURL=getDocumentTraceId.js.map

/***/ }),

/***/ 264320:
/*!*****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/tracing/tracer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TraceIdentifier": () => (/* binding */ TraceIdentifier),
/* harmony export */   "clearTracingIfNeeded": () => (/* binding */ clearTracingIfNeeded),
/* harmony export */   "isTracingOption": () => (/* binding */ isTracingOption),
/* harmony export */   "isTracingSupported": () => (/* binding */ isTracingSupported),
/* harmony export */   "startTracer": () => (/* binding */ startTracer)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 938993);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 484336);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 567934);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 159127);

function isTracingOption(item) {
  var expectedItem = item;
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.getType)(expectedItem) === 'object' && (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.isMatchOption)(expectedItem.match) && Array.isArray(expectedItem.propagatorTypes);
}
/**
 * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the
 * request did not reach the server, but the browser does not expose this. So, we clear tracing
 * information if the request ended with status 0 without being aborted by the application.
 *
 * Reasoning:
 *
 * * Applications are usually aborting requests after a bit of time, for example when the user is
 * typing (autocompletion) or navigating away (in a SPA). With a performant device and good
 * network conditions, the request is likely to reach the server before being canceled.
 *
 * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)
 * are likely to finish quickly and without reaching the server.
 *
 * Of course, it might not be the case every time, but it should limit having incomplete traces a
 * bit.
 * */
function clearTracingIfNeeded(context) {
  if (context.status === 0 && !context.isAborted) {
    context.traceId = undefined;
    context.spanId = undefined;
    context.traceSampled = undefined;
  }
}
function startTracer(configuration, sessionManager) {
  return {
    clearTracingIfNeeded: clearTracingIfNeeded,
    traceFetch: function (context) {
      return injectHeadersIfTracingAllowed(configuration, context, sessionManager, function (tracingHeaders) {
        var _a;
        if (context.input instanceof Request && !((_a = context.init) === null || _a === void 0 ? void 0 : _a.headers)) {
          context.input = new Request(context.input);
          Object.keys(tracingHeaders).forEach(function (key) {
            ;
            context.input.headers.append(key, tracingHeaders[key]);
          });
        } else {
          context.init = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.shallowClone)(context.init);
          var headers_1 = [];
          if (context.init.headers instanceof Headers) {
            context.init.headers.forEach(function (value, key) {
              headers_1.push([key, value]);
            });
          } else if (Array.isArray(context.init.headers)) {
            context.init.headers.forEach(function (header) {
              headers_1.push(header);
            });
          } else if (context.init.headers) {
            Object.keys(context.init.headers).forEach(function (key) {
              headers_1.push([key, context.init.headers[key]]);
            });
          }
          context.init.headers = headers_1.concat((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.objectEntries)(tracingHeaders));
        }
      });
    },
    traceXhr: function (context, xhr) {
      return injectHeadersIfTracingAllowed(configuration, context, sessionManager, function (tracingHeaders) {
        Object.keys(tracingHeaders).forEach(function (name) {
          xhr.setRequestHeader(name, tracingHeaders[name]);
        });
      });
    }
  };
}
function injectHeadersIfTracingAllowed(configuration, context, sessionManager, inject) {
  if (!isTracingSupported() || !sessionManager.findTrackedSession()) {
    return;
  }
  var tracingOption = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.find)(configuration.allowedTracingUrls, function (tracingOption) {
    return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.matchList)([tracingOption.match], context.url, true);
  });
  if (!tracingOption) {
    return;
  }
  context.traceId = new TraceIdentifier();
  context.spanId = new TraceIdentifier();
  context.traceSampled = !(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.isNumber)(configuration.traceSampleRate) || (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.performDraw)(configuration.traceSampleRate);
  inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled, tracingOption.propagatorTypes));
}
function isTracingSupported() {
  return getCrypto() !== undefined;
}
function getCrypto() {
  return window.crypto || window.msCrypto;
}
/**
 * When trace is not sampled, set priority to '0' instead of not adding the tracing headers
 * to prepare the implementation for sampling delegation.
 */
function makeTracingHeaders(traceId, spanId, traceSampled, propagatorTypes) {
  var tracingHeaders = {};
  propagatorTypes.forEach(function (propagatorType) {
    switch (propagatorType) {
      case 'datadog':
        {
          (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.assign)(tracingHeaders, {
            'x-datadog-origin': 'rum',
            'x-datadog-parent-id': spanId.toDecimalString(),
            'x-datadog-sampling-priority': traceSampled ? '1' : '0',
            'x-datadog-trace-id': traceId.toDecimalString()
          });
          break;
        }
      // https://www.w3.org/TR/trace-context/
      case 'tracecontext':
        {
          (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.assign)(tracingHeaders, {
            traceparent: "00-0000000000000000".concat(traceId.toPaddedHexadecimalString(), "-").concat(spanId.toPaddedHexadecimalString(), "-0").concat(traceSampled ? '1' : '0')
          });
          break;
        }
      // https://github.com/openzipkin/b3-propagation
      case 'b3':
        {
          (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.assign)(tracingHeaders, {
            b3: "".concat(traceId.toPaddedHexadecimalString(), "-").concat(spanId.toPaddedHexadecimalString(), "-").concat(traceSampled ? '1' : '0')
          });
          break;
        }
      case 'b3multi':
        {
          (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.assign)(tracingHeaders, {
            'X-B3-TraceId': traceId.toPaddedHexadecimalString(),
            'X-B3-SpanId': spanId.toPaddedHexadecimalString(),
            'X-B3-Sampled': traceSampled ? '1' : '0'
          });
          break;
        }
    }
  });
  return tracingHeaders;
}
/* eslint-disable no-bitwise */
var TraceIdentifier = /** @class */function () {
  function TraceIdentifier() {
    this.buffer = new Uint8Array(8);
    getCrypto().getRandomValues(this.buffer);
    this.buffer[0] = this.buffer[0] & 0x7f; // force 63-bit
  }

  TraceIdentifier.prototype.toString = function (radix) {
    var high = this.readInt32(0);
    var low = this.readInt32(4);
    var str = '';
    do {
      var mod = high % radix * 4294967296 + low;
      high = Math.floor(high / radix);
      low = Math.floor(mod / radix);
      str = (mod % radix).toString(radix) + str;
    } while (high || low);
    return str;
  };
  /**
   * Format used everywhere except the trace intake
   */
  TraceIdentifier.prototype.toDecimalString = function () {
    return this.toString(10);
  };
  /**
   * Format used by OTel headers
   */
  TraceIdentifier.prototype.toPaddedHexadecimalString = function () {
    var traceId = this.toString(16);
    return Array(17 - traceId.length).join('0') + traceId;
  };
  TraceIdentifier.prototype.readInt32 = function (offset) {
    return this.buffer[offset] * 16777216 + (this.buffer[offset + 1] << 16) + (this.buffer[offset + 2] << 8) + this.buffer[offset + 3];
  };
  return TraceIdentifier;
}();

/* eslint-enable no-bitwise */
//# sourceMappingURL=tracer.js.map

/***/ }),

/***/ 935237:
/*!*******************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/trackEventCounts.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trackEventCounts": () => (/* binding */ trackEventCounts)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 897826);

function trackEventCounts(_a) {
  var lifeCycle = _a.lifeCycle,
    isChildEvent = _a.isChildEvent,
    _b = _a.onChange,
    callback = _b === void 0 ? _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.noop : _b;
  var eventCounts = {
    errorCount: 0,
    longTaskCount: 0,
    resourceCount: 0,
    actionCount: 0,
    frustrationCount: 0
  };
  var subscription = lifeCycle.subscribe(11 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, function (event) {
    if (event.type === 'view' || !isChildEvent(event)) {
      return;
    }
    switch (event.type) {
      case "error" /* RumEventType.ERROR */:
        eventCounts.errorCount += 1;
        callback();
        break;
      case "action" /* RumEventType.ACTION */:
        eventCounts.actionCount += 1;
        if (event.action.frustration) {
          eventCounts.frustrationCount += event.action.frustration.type.length;
        }
        callback();
        break;
      case "long_task" /* RumEventType.LONG_TASK */:
        eventCounts.longTaskCount += 1;
        callback();
        break;
      case "resource" /* RumEventType.RESOURCE */:
        eventCounts.resourceCount += 1;
        callback();
        break;
    }
  });
  return {
    stop: function () {
      subscription.unsubscribe();
    },
    eventCounts: eventCounts
  };
}
//# sourceMappingURL=trackEventCounts.js.map

/***/ }),

/***/ 276212:
/*!**********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/domain/waitPageActivityEnd.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PAGE_ACTIVITY_END_DELAY": () => (/* binding */ PAGE_ACTIVITY_END_DELAY),
/* harmony export */   "PAGE_ACTIVITY_VALIDATION_DELAY": () => (/* binding */ PAGE_ACTIVITY_VALIDATION_DELAY),
/* harmony export */   "createPageActivityObservable": () => (/* binding */ createPageActivityObservable),
/* harmony export */   "doWaitPageActivityEnd": () => (/* binding */ doWaitPageActivityEnd),
/* harmony export */   "waitPageActivityEnd": () => (/* binding */ waitPageActivityEnd)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 631128);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 267830);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 32189);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 484336);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 101280);

// Delay to wait for a page activity to validate the tracking process
var PAGE_ACTIVITY_VALIDATION_DELAY = 100;
// Delay to wait after a page activity to end the tracking process
var PAGE_ACTIVITY_END_DELAY = 100;
/**
 * Wait for the page activity end
 *
 * Detection lifecycle:
 * ```
 *                        Wait page activity end
 *              .-------------------'--------------------.
 *              v                                        v
 *     [Wait for a page activity ]          [Wait for a maximum duration]
 *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]
 *          /                  \                           |
 *         v                    v                          |
 *  [No page activity]   [Page activity]                   |
 *         |                   |,----------------------.   |
 *         v                   v                       |   |
 *     (Discard)     [Wait for a page activity]        |   |
 *                   [   timeout: END_DELAY   ]        |   |
 *                       /                \            |   |
 *                      v                  v           |   |
 *             [No page activity]    [Page activity]   |   |
 *                      |                 |            |   |
 *                      |                 '------------'   |
 *                      '-----------. ,--------------------'
 *                                   v
 *                                 (End)
 * ```
 *
 * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the
 * process is still alive after maxDuration, it has been validated.
 */
function waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, pageActivityEndCallback, maxDuration) {
  var pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, configuration);
  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration);
}
function doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration) {
  var pageActivityEndTimeoutId;
  var hasCompleted = false;
  var validationTimeoutId = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.setTimeout)((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.monitor)(function () {
    return complete({
      hadActivity: false
    });
  }), PAGE_ACTIVITY_VALIDATION_DELAY);
  var maxDurationTimeoutId = maxDuration && (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.setTimeout)((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.monitor)(function () {
    return complete({
      hadActivity: true,
      end: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.timeStampNow)()
    });
  }), maxDuration);
  var pageActivitySubscription = pageActivityObservable.subscribe(function (_a) {
    var isBusy = _a.isBusy;
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.clearTimeout)(validationTimeoutId);
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.clearTimeout)(pageActivityEndTimeoutId);
    var lastChangeTime = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.timeStampNow)();
    if (!isBusy) {
      pageActivityEndTimeoutId = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.setTimeout)((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.monitor)(function () {
        return complete({
          hadActivity: true,
          end: lastChangeTime
        });
      }), PAGE_ACTIVITY_END_DELAY);
    }
  });
  var stop = function () {
    hasCompleted = true;
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.clearTimeout)(validationTimeoutId);
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.clearTimeout)(pageActivityEndTimeoutId);
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.clearTimeout)(maxDurationTimeoutId);
    pageActivitySubscription.unsubscribe();
  };
  function complete(event) {
    if (hasCompleted) {
      return;
    }
    stop();
    pageActivityEndCallback(event);
  }
  return {
    stop: stop
  };
}
function createPageActivityObservable(lifeCycle, domMutationObservable, configuration) {
  var observable = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.Observable(function () {
    var subscriptions = [];
    var firstRequestIndex;
    var pendingRequestsCount = 0;
    subscriptions.push(domMutationObservable.subscribe(notifyPageActivity), lifeCycle.subscribe(0 /* LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED */, function (entries) {
      if (entries.some(function (entry) {
        return entry.entryType === 'resource' && !isExcludedUrl(configuration, entry.name);
      })) {
        notifyPageActivity();
      }
    }), lifeCycle.subscribe(5 /* LifeCycleEventType.REQUEST_STARTED */, function (startEvent) {
      if (isExcludedUrl(configuration, startEvent.url)) {
        return;
      }
      if (firstRequestIndex === undefined) {
        firstRequestIndex = startEvent.requestIndex;
      }
      pendingRequestsCount += 1;
      notifyPageActivity();
    }), lifeCycle.subscribe(6 /* LifeCycleEventType.REQUEST_COMPLETED */, function (request) {
      if (isExcludedUrl(configuration, request.url) || firstRequestIndex === undefined ||
      // If the request started before the tracking start, ignore it
      request.requestIndex < firstRequestIndex) {
        return;
      }
      pendingRequestsCount -= 1;
      notifyPageActivity();
    }));
    var stopTrackingWindowOpen = trackWindowOpen(notifyPageActivity).stop;
    return function () {
      stopTrackingWindowOpen();
      subscriptions.forEach(function (s) {
        return s.unsubscribe();
      });
    };
    function notifyPageActivity() {
      observable.notify({
        isBusy: pendingRequestsCount > 0
      });
    }
  });
  return observable;
}
function isExcludedUrl(configuration, requestUrl) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.matchList)(configuration.excludedActivityUrls, requestUrl);
}
function trackWindowOpen(callback) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.instrumentMethodAndCallOriginal)(window, 'open', {
    before: callback
  });
}
//# sourceMappingURL=waitPageActivityEnd.js.map

/***/ }),

/***/ 454959:
/*!*************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE": () => (/* reexport safe */ _domain_rumEventsCollection_action_getActionNameFromElement__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE),
/* harmony export */   "LifeCycle": () => (/* reexport safe */ _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_2__.LifeCycle),
/* harmony export */   "STABLE_ATTRIBUTES": () => (/* reexport safe */ _domain_rumEventsCollection_action_getSelectorFromElement__WEBPACK_IMPORTED_MODULE_6__.STABLE_ATTRIBUTES),
/* harmony export */   "getChildNodes": () => (/* reexport safe */ _browser_htmlDomUtils__WEBPACK_IMPORTED_MODULE_7__.getChildNodes),
/* harmony export */   "getMutationObserverConstructor": () => (/* reexport safe */ _browser_domMutationObservable__WEBPACK_IMPORTED_MODULE_3__.getMutationObserverConstructor),
/* harmony export */   "getParentNode": () => (/* reexport safe */ _browser_htmlDomUtils__WEBPACK_IMPORTED_MODULE_7__.getParentNode),
/* harmony export */   "getSessionReplayUrl": () => (/* reexport safe */ _domain_getSessionReplayUrl__WEBPACK_IMPORTED_MODULE_8__.getSessionReplayUrl),
/* harmony export */   "getViewportDimension": () => (/* reexport safe */ _browser_viewportObservable__WEBPACK_IMPORTED_MODULE_4__.getViewportDimension),
/* harmony export */   "initViewportObservable": () => (/* reexport safe */ _browser_viewportObservable__WEBPACK_IMPORTED_MODULE_4__.initViewportObservable),
/* harmony export */   "isCommentNode": () => (/* reexport safe */ _browser_htmlDomUtils__WEBPACK_IMPORTED_MODULE_7__.isCommentNode),
/* harmony export */   "isElementNode": () => (/* reexport safe */ _browser_htmlDomUtils__WEBPACK_IMPORTED_MODULE_7__.isElementNode),
/* harmony export */   "isNodeShadowHost": () => (/* reexport safe */ _browser_htmlDomUtils__WEBPACK_IMPORTED_MODULE_7__.isNodeShadowHost),
/* harmony export */   "isNodeShadowRoot": () => (/* reexport safe */ _browser_htmlDomUtils__WEBPACK_IMPORTED_MODULE_7__.isNodeShadowRoot),
/* harmony export */   "isTextNode": () => (/* reexport safe */ _browser_htmlDomUtils__WEBPACK_IMPORTED_MODULE_7__.isTextNode),
/* harmony export */   "makeRumPublicApi": () => (/* reexport safe */ _boot_rumPublicApi__WEBPACK_IMPORTED_MODULE_0__.makeRumPublicApi),
/* harmony export */   "startRum": () => (/* reexport safe */ _boot_startRum__WEBPACK_IMPORTED_MODULE_1__.startRum)
/* harmony export */ });
/* harmony import */ var _boot_rumPublicApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot/rumPublicApi */ 71092);
/* harmony import */ var _boot_startRum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./boot/startRum */ 382001);
/* harmony import */ var _domain_lifeCycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./domain/lifeCycle */ 762618);
/* harmony import */ var _browser_domMutationObservable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./browser/domMutationObservable */ 280169);
/* harmony import */ var _browser_viewportObservable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./browser/viewportObservable */ 845755);
/* harmony import */ var _domain_rumEventsCollection_action_getActionNameFromElement__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./domain/rumEventsCollection/action/getActionNameFromElement */ 869922);
/* harmony import */ var _domain_rumEventsCollection_action_getSelectorFromElement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./domain/rumEventsCollection/action/getSelectorFromElement */ 571719);
/* harmony import */ var _browser_htmlDomUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./browser/htmlDomUtils */ 381146);
/* harmony import */ var _domain_getSessionReplayUrl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./domain/getSessionReplayUrl */ 320339);









//# sourceMappingURL=index.js.map

/***/ }),

/***/ 531741:
/*!*******************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/transport/startRumBatch.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startRumBatch": () => (/* binding */ startRumBatch)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 931942);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 886794);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 290223);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 445260);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 307529);

function startRumBatch(configuration, lifeCycle, telemetryEventObservable, reportError, pageExitObservable) {
  var batch = makeRumBatch(configuration, reportError, pageExitObservable);
  lifeCycle.subscribe(11 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, function (serverRumEvent) {
    if (serverRumEvent.type === "view" /* RumEventType.VIEW */) {
      batch.upsert(serverRumEvent, serverRumEvent.view.id);
    } else {
      batch.add(serverRumEvent);
    }
  });
  telemetryEventObservable.subscribe(function (event) {
    return batch.add(event, (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.isTelemetryReplicationAllowed)(configuration));
  });
  return batch;
}
function makeRumBatch(configuration, reportError, pageExitObservable) {
  var _a = createRumBatch(configuration.rumEndpointBuilder),
    primaryBatch = _a.batch,
    primaryFlushController = _a.flushController;
  var replicaBatch;
  var replica = configuration.replica;
  if (replica !== undefined) {
    replicaBatch = createRumBatch(replica.rumEndpointBuilder).batch;
  }
  function createRumBatch(endpointBuilder) {
    var flushController = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.createFlushController)({
      messagesLimit: configuration.batchMessagesLimit,
      bytesLimit: configuration.batchBytesLimit,
      durationLimit: configuration.flushTimeout,
      pageExitObservable: pageExitObservable
    });
    var batch = new _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.Batch((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.createHttpRequest)(endpointBuilder, configuration.batchBytesLimit, reportError), flushController, configuration.messageBytesLimit);
    return {
      batch: batch,
      flushController: flushController
    };
  }
  function withReplicaApplicationId(message) {
    return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.combine)(message, {
      application: {
        id: replica.applicationId
      }
    });
  }
  return {
    flushObservable: primaryFlushController.flushObservable,
    add: function (message, replicated) {
      if (replicated === void 0) {
        replicated = true;
      }
      primaryBatch.add(message);
      if (replicaBatch && replicated) {
        replicaBatch.add(withReplicaApplicationId(message));
      }
    },
    upsert: function (message, key) {
      primaryBatch.upsert(message, key);
      if (replicaBatch) {
        replicaBatch.upsert(withReplicaApplicationId(message), key);
      }
    }
  };
}
//# sourceMappingURL=startRumBatch.js.map

/***/ }),

/***/ 929146:
/*!*************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum-core/esm/transport/startRumEventBridge.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startRumEventBridge": () => (/* binding */ startRumEventBridge)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 146903);

function startRumEventBridge(lifeCycle) {
  var bridge = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.getEventBridge)();
  lifeCycle.subscribe(11 /* LifeCycleEventType.RUM_EVENT_COLLECTED */, function (serverRumEvent) {
    bridge.send('rum', serverRumEvent);
  });
}
//# sourceMappingURL=startRumEventBridge.js.map

/***/ }),

/***/ 649110:
/*!**************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/boot/isBrowserSupported.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isBrowserSupported": () => (/* binding */ isBrowserSupported)
/* harmony export */ });
/**
 * Test for Browser features used while recording
 */
function isBrowserSupported() {
  return (
    // Array.from is a bit less supported by browsers than CSSSupportsRule, but has higher chances
    // to be polyfilled. Test for both to be more confident. We could add more things if we find out
    // this test is not sufficient.
    typeof Array.from === 'function' && typeof CSSSupportsRule === 'function' && typeof URL.createObjectURL === 'function' && 'forEach' in NodeList.prototype
  );
}
//# sourceMappingURL=isBrowserSupported.js.map

/***/ }),

/***/ 795540:
/*!*******************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/boot/recorderApi.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeRecorderApi": () => (/* binding */ makeRecorderApi)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 146903);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 656785);
/* harmony import */ var _domain_replayStats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../domain/replayStats */ 157818);
/* harmony import */ var _domain_getSessionReplayLink__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domain/getSessionReplayLink */ 983652);
/* harmony import */ var _domain_segmentCollection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../domain/segmentCollection */ 888490);
/* harmony import */ var _isBrowserSupported__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isBrowserSupported */ 649110);





function makeRecorderApi(startRecordingImpl, startDeflateWorkerImpl) {
  if (startDeflateWorkerImpl === void 0) {
    startDeflateWorkerImpl = _domain_segmentCollection__WEBPACK_IMPORTED_MODULE_2__.startDeflateWorker;
  }
  if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.canUseEventBridge)() || !(0,_isBrowserSupported__WEBPACK_IMPORTED_MODULE_3__.isBrowserSupported)()) {
    return {
      start: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.noop,
      stop: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.noop,
      getReplayStats: function () {
        return undefined;
      },
      onRumStart: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.noop,
      isRecording: function () {
        return false;
      },
      getSessionReplayLink: function () {
        return undefined;
      }
    };
  }
  var state = {
    status: 0 /* RecorderStatus.Stopped */
  };

  var startStrategy = function () {
    state = {
      status: 1 /* RecorderStatus.IntentToStart */
    };
  };

  var stopStrategy = function () {
    state = {
      status: 0 /* RecorderStatus.Stopped */
    };
  };

  return {
    start: function () {
      return startStrategy();
    },
    stop: function () {
      return stopStrategy();
    },
    getReplayStats: _domain_replayStats__WEBPACK_IMPORTED_MODULE_0__.getReplayStats,
    getSessionReplayLink: function (configuration, sessionManager, viewContexts) {
      return (0,_domain_getSessionReplayLink__WEBPACK_IMPORTED_MODULE_1__.getSessionReplayLink)(configuration, sessionManager, viewContexts, state.status !== 0 /* RecorderStatus.Stopped */);
    },

    onRumStart: function (lifeCycle, configuration, sessionManager, viewContexts) {
      lifeCycle.subscribe(7 /* LifeCycleEventType.SESSION_EXPIRED */, function () {
        if (state.status === 2 /* RecorderStatus.Starting */ || state.status === 3 /* RecorderStatus.Started */) {
          stopStrategy();
          state = {
            status: 1 /* RecorderStatus.IntentToStart */
          };
        }
      });

      lifeCycle.subscribe(8 /* LifeCycleEventType.SESSION_RENEWED */, function () {
        if (state.status === 1 /* RecorderStatus.IntentToStart */) {
          startStrategy();
        }
      });
      startStrategy = function () {
        var session = sessionManager.findTrackedSession();
        if (!session || !session.sessionReplayAllowed) {
          state = {
            status: 1 /* RecorderStatus.IntentToStart */
          };
          return;
        }
        if (state.status === 2 /* RecorderStatus.Starting */ || state.status === 3 /* RecorderStatus.Started */) {
          return;
        }
        state = {
          status: 2 /* RecorderStatus.Starting */
        };
        (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.runOnReadyState)('interactive', function () {
          if (state.status !== 2 /* RecorderStatus.Starting */) {
            return;
          }
          startDeflateWorkerImpl(function (worker) {
            if (state.status !== 2 /* RecorderStatus.Starting */) {
              return;
            }
            if (!worker) {
              state = {
                status: 0 /* RecorderStatus.Stopped */
              };

              return;
            }
            var stopRecording = startRecordingImpl(lifeCycle, configuration, sessionManager, viewContexts, worker).stop;
            state = {
              status: 3 /* RecorderStatus.Started */,
              stopRecording: stopRecording
            };
          });
        });
      };
      stopStrategy = function () {
        if (state.status === 0 /* RecorderStatus.Stopped */) {
          return;
        }
        if (state.status === 3 /* RecorderStatus.Started */) {
          state.stopRecording();
        }
        state = {
          status: 0 /* RecorderStatus.Stopped */
        };
      };

      if (state.status === 1 /* RecorderStatus.IntentToStart */) {
        startStrategy();
      }
    },
    isRecording: function () {
      return state.status === 3 /* RecorderStatus.Started */;
    }
  };
}
//# sourceMappingURL=recorderApi.js.map

/***/ }),

/***/ 76816:
/*!**********************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/boot/startRecording.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startRecording": () => (/* binding */ startRecording)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 445260);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _domain_record__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../domain/record */ 418791);
/* harmony import */ var _domain_segmentCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../domain/segmentCollection */ 888490);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types */ 938168);




function startRecording(lifeCycle, configuration, sessionManager, viewContexts, worker, httpRequest) {
  var reportError = function (error) {
    lifeCycle.notify(12 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, {
      error: error
    });
  };
  var replayRequest = httpRequest || (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.createHttpRequest)(configuration.sessionReplayEndpointBuilder, _domain_segmentCollection__WEBPACK_IMPORTED_MODULE_1__.SEGMENT_BYTES_LIMIT, reportError);
  var _a = (0,_domain_segmentCollection__WEBPACK_IMPORTED_MODULE_1__.startSegmentCollection)(lifeCycle, configuration.applicationId, sessionManager, viewContexts, replayRequest, worker),
    addRecord = _a.addRecord,
    stopSegmentCollection = _a.stop;
  var _b = (0,_domain_record__WEBPACK_IMPORTED_MODULE_0__.record)({
      emit: addRecord,
      configuration: configuration,
      lifeCycle: lifeCycle
    }),
    stopRecording = _b.stop,
    takeSubsequentFullSnapshot = _b.takeSubsequentFullSnapshot,
    flushMutations = _b.flushMutations;
  var unsubscribeViewEnded = lifeCycle.subscribe(4 /* LifeCycleEventType.VIEW_ENDED */, function () {
    flushMutations();
    addRecord({
      timestamp: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.timeStampNow)(),
      type: _types__WEBPACK_IMPORTED_MODULE_2__.RecordType.ViewEnd
    });
  }).unsubscribe;
  var unsubscribeViewCreated = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, function (view) {
    takeSubsequentFullSnapshot(view.startClocks.timeStamp);
  }).unsubscribe;
  return {
    stop: function () {
      unsubscribeViewEnded();
      unsubscribeViewCreated();
      stopRecording();
      stopSegmentCollection();
    }
  };
}
//# sourceMappingURL=startRecording.js.map

/***/ }),

/***/ 956683:
/*!************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/constants.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CENSORED_IMG_MARK": () => (/* binding */ CENSORED_IMG_MARK),
/* harmony export */   "CENSORED_STRING_MARK": () => (/* binding */ CENSORED_STRING_MARK),
/* harmony export */   "FORM_PRIVATE_TAG_NAMES": () => (/* binding */ FORM_PRIVATE_TAG_NAMES),
/* harmony export */   "NodePrivacyLevel": () => (/* binding */ NodePrivacyLevel),
/* harmony export */   "PRIVACY_ATTR_NAME": () => (/* binding */ PRIVACY_ATTR_NAME),
/* harmony export */   "PRIVACY_ATTR_VALUE_ALLOW": () => (/* binding */ PRIVACY_ATTR_VALUE_ALLOW),
/* harmony export */   "PRIVACY_ATTR_VALUE_HIDDEN": () => (/* binding */ PRIVACY_ATTR_VALUE_HIDDEN),
/* harmony export */   "PRIVACY_ATTR_VALUE_MASK": () => (/* binding */ PRIVACY_ATTR_VALUE_MASK),
/* harmony export */   "PRIVACY_ATTR_VALUE_MASK_USER_INPUT": () => (/* binding */ PRIVACY_ATTR_VALUE_MASK_USER_INPUT),
/* harmony export */   "PRIVACY_CLASS_ALLOW": () => (/* binding */ PRIVACY_CLASS_ALLOW),
/* harmony export */   "PRIVACY_CLASS_HIDDEN": () => (/* binding */ PRIVACY_CLASS_HIDDEN),
/* harmony export */   "PRIVACY_CLASS_MASK": () => (/* binding */ PRIVACY_CLASS_MASK),
/* harmony export */   "PRIVACY_CLASS_MASK_USER_INPUT": () => (/* binding */ PRIVACY_CLASS_MASK_USER_INPUT)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 351540);

var NodePrivacyLevel = {
  IGNORE: 'ignore',
  HIDDEN: 'hidden',
  ALLOW: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.DefaultPrivacyLevel.ALLOW,
  MASK: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.DefaultPrivacyLevel.MASK,
  MASK_USER_INPUT: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.DefaultPrivacyLevel.MASK_USER_INPUT
};
var PRIVACY_ATTR_NAME = 'data-dd-privacy';
// Privacy Attrs
var PRIVACY_ATTR_VALUE_ALLOW = 'allow';
var PRIVACY_ATTR_VALUE_MASK = 'mask';
var PRIVACY_ATTR_VALUE_MASK_USER_INPUT = 'mask-user-input';
var PRIVACY_ATTR_VALUE_HIDDEN = 'hidden';
// Privacy Classes - not all customers can set plain HTML attributes, so support classes too
var PRIVACY_CLASS_ALLOW = 'dd-privacy-allow';
var PRIVACY_CLASS_MASK = 'dd-privacy-mask';
var PRIVACY_CLASS_MASK_USER_INPUT = 'dd-privacy-mask-user-input';
var PRIVACY_CLASS_HIDDEN = 'dd-privacy-hidden';
// Private Replacement Templates
var CENSORED_STRING_MARK = '***';
var CENSORED_IMG_MARK = 'data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==';
var FORM_PRIVATE_TAG_NAMES = {
  INPUT: true,
  OUTPUT: true,
  TEXTAREA: true,
  SELECT: true,
  OPTION: true,
  DATALIST: true,
  OPTGROUP: true
};
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 983652:
/*!******************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/getSessionReplayLink.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSessionReplayLink": () => (/* binding */ getSessionReplayLink)
/* harmony export */ });
/* harmony import */ var _datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-rum-core */ 454959);
/* harmony import */ var _boot_isBrowserSupported__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../boot/isBrowserSupported */ 649110);


function getSessionReplayLink(configuration, sessionManager, viewContexts, isRecordingStarted) {
  var session = sessionManager.findTrackedSession();
  var errorType = getErrorType(session, isRecordingStarted);
  var viewContext = viewContexts.findView();
  return (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.getSessionReplayUrl)(configuration, {
    viewContext: viewContext,
    errorType: errorType,
    session: session
  });
}
function getErrorType(session, isRecordingStarted) {
  if (!(0,_boot_isBrowserSupported__WEBPACK_IMPORTED_MODULE_1__.isBrowserSupported)()) {
    return 'browser-not-supported';
  }
  if (!session) {
    // possibilities:
    // - rum sampled out
    // - session expired (edge case)
    return 'rum-not-tracked';
  }
  if (!session.sessionReplayAllowed) {
    // possibilities
    // - replay sampled out
    return 'incorrect-session-plan';
  }
  if (!isRecordingStarted) {
    return 'replay-not-started';
  }
}
//# sourceMappingURL=getSessionReplayLink.js.map

/***/ }),

/***/ 243982:
/*!*************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/assembly.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assembleIncrementalSnapshot": () => (/* binding */ assembleIncrementalSnapshot)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ 938168);


function assembleIncrementalSnapshot(source, data) {
  return {
    data: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.assign)({
      source: source
    }, data),
    type: _types__WEBPACK_IMPORTED_MODULE_0__.RecordType.IncrementalSnapshot,
    timestamp: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.timeStampNow)()
  };
}
//# sourceMappingURL=assembly.js.map

/***/ }),

/***/ 684952:
/*!****************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/elementsScrollPositions.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createElementsScrollPositions": () => (/* binding */ createElementsScrollPositions)
/* harmony export */ });
function createElementsScrollPositions() {
  var scrollPositionsByElement = new WeakMap();
  return {
    set: function (element, scrollPositions) {
      if (element === document && !document.scrollingElement) {
        // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,
        // in some cases scrolling elements can not be defined, we don't support those for now
        return;
      }
      scrollPositionsByElement.set(element === document ? document.scrollingElement : element, scrollPositions);
    },
    get: function (element) {
      return scrollPositionsByElement.get(element);
    },
    has: function (element) {
      return scrollPositionsByElement.has(element);
    }
  };
}
//# sourceMappingURL=elementsScrollPositions.js.map

/***/ }),

/***/ 32115:
/*!****************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/eventsUtils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getEventTarget": () => (/* binding */ getEventTarget),
/* harmony export */   "isTouchEvent": () => (/* binding */ isTouchEvent)
/* harmony export */ });
/* harmony import */ var _datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-rum-core */ 454959);

function isTouchEvent(event) {
  return Boolean(event.changedTouches);
}
function getEventTarget(event) {
  if (event.composed === true && (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.isNodeShadowHost)(event.target)) {
    return event.composedPath()[0];
  }
  return event.target;
}
//# sourceMappingURL=eventsUtils.js.map

/***/ }),

/***/ 418791:
/*!**********************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createElementsScrollPositions": () => (/* reexport safe */ _elementsScrollPositions__WEBPACK_IMPORTED_MODULE_2__.createElementsScrollPositions),
/* harmony export */   "record": () => (/* reexport safe */ _record__WEBPACK_IMPORTED_MODULE_0__.record),
/* harmony export */   "serializeDocument": () => (/* reexport safe */ _serialization__WEBPACK_IMPORTED_MODULE_1__.serializeDocument),
/* harmony export */   "serializeNodeWithId": () => (/* reexport safe */ _serialization__WEBPACK_IMPORTED_MODULE_1__.serializeNodeWithId)
/* harmony export */ });
/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./record */ 416430);
/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serialization */ 253776);
/* harmony import */ var _elementsScrollPositions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./elementsScrollPositions */ 684952);



//# sourceMappingURL=index.js.map

/***/ }),

/***/ 664726:
/*!******************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/mutationBatch.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMutationBatch": () => (/* binding */ createMutationBatch)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 267830);

/**
 * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be
 * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the
 * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the
 * browser is busy executing a longer task, mutations will be processed after this task.
 */
var MUTATION_PROCESS_MAX_DELAY = 100;
function createMutationBatch(processMutationBatch) {
  var cancelScheduledFlush = _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.noop;
  var pendingMutations = [];
  function flush() {
    cancelScheduledFlush();
    processMutationBatch(pendingMutations);
    pendingMutations = [];
  }
  return {
    addMutations: function (mutations) {
      if (pendingMutations.length === 0) {
        cancelScheduledFlush = requestIdleCallback(flush, {
          timeout: MUTATION_PROCESS_MAX_DELAY
        });
      }
      pendingMutations.push.apply(pendingMutations, mutations);
    },
    flush: flush,
    stop: function () {
      cancelScheduledFlush();
    }
  };
}
/**
 * Use 'requestIdleCallback' when available: it will throttle the mutation processing if the
 * browser is busy rendering frames (ex: when frames are below 60fps). When not available, the
 * fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any
 * browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes efficiently.
 *
 * Note: check both 'requestIdleCallback' and 'cancelIdleCallback' existence because some polyfills only implement 'requestIdleCallback'.
 */
function requestIdleCallback(callback, opts) {
  if (window.requestIdleCallback && window.cancelIdleCallback) {
    var id_1 = window.requestIdleCallback((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.monitor)(callback), opts);
    return function () {
      return window.cancelIdleCallback(id_1);
    };
  }
  var id = window.requestAnimationFrame((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.monitor)(callback));
  return function () {
    return window.cancelAnimationFrame(id);
  };
}
//# sourceMappingURL=mutationBatch.js.map

/***/ }),

/***/ 65775:
/*!****************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/focusObserver.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initFocusObserver": () => (/* binding */ initFocusObserver)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 822006);

function initFocusObserver(focusCb) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.addEventListeners)(window, ["focus" /* DOM_EVENT.FOCUS */, "blur" /* DOM_EVENT.BLUR */], function () {
    focusCb({
      has_focus: document.hasFocus()
    });
  }).stop;
}
//# sourceMappingURL=focusObserver.js.map

/***/ }),

/***/ 924815:
/*!**********************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/frustrationObserver.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initFrustrationObserver": () => (/* binding */ initFrustrationObserver)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../types */ 938168);

function initFrustrationObserver(lifeCycle, frustrationCb, recordIds) {
  return lifeCycle.subscribe(10 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, function (data) {
    var _a, _b, _c;
    if (data.rawRumEvent.type === "action" /* RumEventType.ACTION */ && data.rawRumEvent.action.type === "click" /* ActionType.CLICK */ && ((_b = (_a = data.rawRumEvent.action.frustration) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.length) && 'events' in data.domainContext && ((_c = data.domainContext.events) === null || _c === void 0 ? void 0 : _c.length)) {
      frustrationCb({
        timestamp: data.rawRumEvent.date,
        type: _types__WEBPACK_IMPORTED_MODULE_0__.RecordType.FrustrationRecord,
        data: {
          frustrationTypes: data.rawRumEvent.action.frustration.type,
          recordIds: data.domainContext.events.map(function (e) {
            return recordIds.getIdForEvent(e);
          })
        }
      });
    }
  }).unsubscribe;
}
//# sourceMappingURL=frustrationObserver.js.map

/***/ }),

/***/ 667412:
/*!********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initInputObserver": () => (/* reexport safe */ _inputObserver__WEBPACK_IMPORTED_MODULE_1__.initInputObserver),
/* harmony export */   "initMutationObserver": () => (/* reexport safe */ _mutationObserver__WEBPACK_IMPORTED_MODULE_2__.initMutationObserver),
/* harmony export */   "initObservers": () => (/* reexport safe */ _observers__WEBPACK_IMPORTED_MODULE_0__.initObservers)
/* harmony export */ });
/* harmony import */ var _observers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observers */ 562477);
/* harmony import */ var _inputObserver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inputObserver */ 140266);
/* harmony import */ var _mutationObserver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mutationObserver */ 388251);



//# sourceMappingURL=index.js.map

/***/ }),

/***/ 140266:
/*!****************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/inputObserver.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initInputObserver": () => (/* binding */ initInputObserver)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 822006);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 101280);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../constants */ 956683);
/* harmony import */ var _eventsUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../eventsUtils */ 32115);
/* harmony import */ var _privacy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../privacy */ 76231);
/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../serialization */ 253776);





function initInputObserver(cb, defaultPrivacyLevel, _a) {
  var _b = _a === void 0 ? {} : _a,
    _c = _b.domEvents,
    domEvents = _c === void 0 ? ["input" /* DOM_EVENT.INPUT */, "change" /* DOM_EVENT.CHANGE */] : _c,
    _d = _b.target,
    target = _d === void 0 ? document : _d;
  var lastInputStateMap = new WeakMap();
  function onElementChange(target) {
    var nodePrivacyLevel = (0,_privacy__WEBPACK_IMPORTED_MODULE_2__.getNodePrivacyLevel)(target, defaultPrivacyLevel);
    if (nodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_0__.NodePrivacyLevel.HIDDEN) {
      return;
    }
    var type = target.type;
    var inputState;
    if (type === 'radio' || type === 'checkbox') {
      if ((0,_privacy__WEBPACK_IMPORTED_MODULE_2__.shouldMaskNode)(target, nodePrivacyLevel)) {
        return;
      }
      inputState = {
        isChecked: target.checked
      };
    } else {
      var value = (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.getElementInputValue)(target, nodePrivacyLevel);
      if (value === undefined) {
        return;
      }
      inputState = {
        text: value
      };
    }
    // Can be multiple changes on the same node within the same batched mutation observation.
    cbWithDedup(target, inputState);
    // If a radio was checked, other radios with the same name attribute will be unchecked.
    var name = target.name;
    if (type === 'radio' && name && target.checked) {
      (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.forEach)(document.querySelectorAll("input[type=\"radio\"][name=\"".concat(name, "\"]")), function (el) {
        if (el !== target) {
          // TODO: Consider the privacy implications for various differing input privacy levels
          cbWithDedup(el, {
            isChecked: false
          });
        }
      });
    }
  }
  /**
   * There can be multiple changes on the same node within the same batched mutation observation.
   */
  function cbWithDedup(target, inputState) {
    if (!(0,_serialization__WEBPACK_IMPORTED_MODULE_3__.hasSerializedNode)(target)) {
      return;
    }
    var lastInputState = lastInputStateMap.get(target);
    if (!lastInputState || lastInputState.text !== inputState.text || lastInputState.isChecked !== inputState.isChecked) {
      lastInputStateMap.set(target, inputState);
      cb((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.assign)({
        id: (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.getSerializedNodeId)(target)
      }, inputState));
    }
  }
  var stopEventListeners = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.addEventListeners)(target, domEvents, function (event) {
    var target = (0,_eventsUtils__WEBPACK_IMPORTED_MODULE_1__.getEventTarget)(event);
    if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement) {
      onElementChange(target);
    }
  }, {
    capture: true,
    passive: true
  }).stop;
  var instrumentationStoppers = [(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.instrumentSetter)(HTMLInputElement.prototype, 'value', onElementChange), (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.instrumentSetter)(HTMLInputElement.prototype, 'checked', onElementChange), (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.instrumentSetter)(HTMLSelectElement.prototype, 'value', onElementChange), (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.instrumentSetter)(HTMLTextAreaElement.prototype, 'value', onElementChange), (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.instrumentSetter)(HTMLSelectElement.prototype, 'selectedIndex', onElementChange)];
  return function () {
    instrumentationStoppers.forEach(function (stopper) {
      return stopper.stop();
    });
    stopEventListeners();
  };
}
//# sourceMappingURL=inputObserver.js.map

/***/ }),

/***/ 559167:
/*!***************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/mediaInteractionObserver.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initMediaInteractionObserver": () => (/* binding */ initMediaInteractionObserver)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 822006);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../constants */ 956683);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../types */ 938168);
/* harmony import */ var _eventsUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../eventsUtils */ 32115);
/* harmony import */ var _privacy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../privacy */ 76231);
/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../serialization */ 253776);






function initMediaInteractionObserver(mediaInteractionCb, defaultPrivacyLevel) {
  var handler = function (event) {
    var target = (0,_eventsUtils__WEBPACK_IMPORTED_MODULE_2__.getEventTarget)(event);
    if (!target || (0,_privacy__WEBPACK_IMPORTED_MODULE_3__.getNodePrivacyLevel)(target, defaultPrivacyLevel) === _constants__WEBPACK_IMPORTED_MODULE_0__.NodePrivacyLevel.HIDDEN || !(0,_serialization__WEBPACK_IMPORTED_MODULE_4__.hasSerializedNode)(target)) {
      return;
    }
    mediaInteractionCb({
      id: (0,_serialization__WEBPACK_IMPORTED_MODULE_4__.getSerializedNodeId)(target),
      type: event.type === "play" /* DOM_EVENT.PLAY */ ? _types__WEBPACK_IMPORTED_MODULE_1__.MediaInteractionType.Play : _types__WEBPACK_IMPORTED_MODULE_1__.MediaInteractionType.Pause
    });
  };
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.addEventListeners)(document, ["play" /* DOM_EVENT.PLAY */, "pause" /* DOM_EVENT.PAUSE */], handler, {
    capture: true,
    passive: true
  }).stop;
}
//# sourceMappingURL=mediaInteractionObserver.js.map

/***/ }),

/***/ 732112:
/*!***************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/mouseInteractionObserver.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initMouseInteractionObserver": () => (/* binding */ initMouseInteractionObserver)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 822006);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../constants */ 956683);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../types */ 938168);
/* harmony import */ var _assembly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../assembly */ 243982);
/* harmony import */ var _eventsUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../eventsUtils */ 32115);
/* harmony import */ var _privacy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../privacy */ 76231);
/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../serialization */ 253776);
/* harmony import */ var _moveObserver__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./moveObserver */ 592825);
var _a;








var eventTypeToMouseInteraction = (_a = {},
// Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This
// allows to reference such records from Frustration records.
//
// In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records
// used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace
// `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to
// convey such interaction. This would cleanly solve the issue since we would have
// `PointerInteraction/Up` records that we could reference from `Frustration` records.
_a["pointerup" /* DOM_EVENT.POINTER_UP */] = _types__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType.MouseUp, _a["mousedown" /* DOM_EVENT.MOUSE_DOWN */] = _types__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType.MouseDown, _a["click" /* DOM_EVENT.CLICK */] = _types__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType.Click, _a["contextmenu" /* DOM_EVENT.CONTEXT_MENU */] = _types__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType.ContextMenu, _a["dblclick" /* DOM_EVENT.DBL_CLICK */] = _types__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType.DblClick, _a["focus" /* DOM_EVENT.FOCUS */] = _types__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType.Focus, _a["blur" /* DOM_EVENT.BLUR */] = _types__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType.Blur, _a["touchstart" /* DOM_EVENT.TOUCH_START */] = _types__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType.TouchStart, _a["touchend" /* DOM_EVENT.TOUCH_END */] = _types__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType.TouchEnd, _a);
function initMouseInteractionObserver(cb, defaultPrivacyLevel, recordIds) {
  var handler = function (event) {
    var target = (0,_eventsUtils__WEBPACK_IMPORTED_MODULE_3__.getEventTarget)(event);
    if ((0,_privacy__WEBPACK_IMPORTED_MODULE_4__.getNodePrivacyLevel)(target, defaultPrivacyLevel) === _constants__WEBPACK_IMPORTED_MODULE_0__.NodePrivacyLevel.HIDDEN || !(0,_serialization__WEBPACK_IMPORTED_MODULE_5__.hasSerializedNode)(target)) {
      return;
    }
    var id = (0,_serialization__WEBPACK_IMPORTED_MODULE_5__.getSerializedNodeId)(target);
    var type = eventTypeToMouseInteraction[event.type];
    var interaction;
    if (type !== _types__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType.Blur && type !== _types__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType.Focus) {
      var coordinates = (0,_moveObserver__WEBPACK_IMPORTED_MODULE_6__.tryToComputeCoordinates)(event);
      if (!coordinates) {
        return;
      }
      interaction = {
        id: id,
        type: type,
        x: coordinates.x,
        y: coordinates.y
      };
    } else {
      interaction = {
        id: id,
        type: type
      };
    }
    var record = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.assign)({
      id: recordIds.getIdForEvent(event)
    }, (0,_assembly__WEBPACK_IMPORTED_MODULE_2__.assembleIncrementalSnapshot)(_types__WEBPACK_IMPORTED_MODULE_1__.IncrementalSource.MouseInteraction, interaction));
    cb(record);
  };
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.addEventListeners)(document, Object.keys(eventTypeToMouseInteraction), handler, {
    capture: true,
    passive: true
  }).stop;
}
//# sourceMappingURL=mouseInteractionObserver.js.map

/***/ }),

/***/ 592825:
/*!***************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/moveObserver.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initMoveObserver": () => (/* binding */ initMoveObserver),
/* harmony export */   "tryToComputeCoordinates": () => (/* binding */ tryToComputeCoordinates)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 822006);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 931942);
/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../serialization */ 253776);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../types */ 938168);
/* harmony import */ var _eventsUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../eventsUtils */ 32115);
/* harmony import */ var _viewports__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../viewports */ 807602);





var MOUSE_MOVE_OBSERVER_THRESHOLD = 50;
function initMoveObserver(cb) {
  var updatePosition = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.throttle)(function (event) {
    var target = (0,_eventsUtils__WEBPACK_IMPORTED_MODULE_2__.getEventTarget)(event);
    if ((0,_serialization__WEBPACK_IMPORTED_MODULE_0__.hasSerializedNode)(target)) {
      var coordinates = tryToComputeCoordinates(event);
      if (!coordinates) {
        return;
      }
      var position = {
        id: (0,_serialization__WEBPACK_IMPORTED_MODULE_0__.getSerializedNodeId)(target),
        timeOffset: 0,
        x: coordinates.x,
        y: coordinates.y
      };
      cb([position], (0,_eventsUtils__WEBPACK_IMPORTED_MODULE_2__.isTouchEvent)(event) ? _types__WEBPACK_IMPORTED_MODULE_1__.IncrementalSource.TouchMove : _types__WEBPACK_IMPORTED_MODULE_1__.IncrementalSource.MouseMove);
    }
  }, MOUSE_MOVE_OBSERVER_THRESHOLD, {
    trailing: false
  }).throttled;
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.addEventListeners)(document, ["mousemove" /* DOM_EVENT.MOUSE_MOVE */, "touchmove" /* DOM_EVENT.TOUCH_MOVE */], updatePosition, {
    capture: true,
    passive: true
  }).stop;
}
function tryToComputeCoordinates(event) {
  var _a = (0,_eventsUtils__WEBPACK_IMPORTED_MODULE_2__.isTouchEvent)(event) ? event.changedTouches[0] : event,
    x = _a.clientX,
    y = _a.clientY;
  if (window.visualViewport) {
    var _b = (0,_viewports__WEBPACK_IMPORTED_MODULE_3__.convertMouseEventToLayoutCoordinates)(x, y),
      visualViewportX = _b.visualViewportX,
      visualViewportY = _b.visualViewportY;
    x = visualViewportX;
    y = visualViewportY;
  }
  if (!Number.isFinite(x) || !Number.isFinite(y)) {
    if (event.isTrusted) {
      (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.addTelemetryDebug)('mouse/touch event without x/y');
    }
    return undefined;
  }
  return {
    x: x,
    y: y
  };
}
//# sourceMappingURL=moveObserver.js.map

/***/ }),

/***/ 388251:
/*!*******************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/mutationObserver.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initMutationObserver": () => (/* binding */ initMutationObserver),
/* harmony export */   "sortAddedAndMovedNodes": () => (/* binding */ sortAddedAndMovedNodes)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 267830);
/* harmony import */ var _datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-rum-core */ 454959);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../constants */ 956683);
/* harmony import */ var _privacy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../privacy */ 76231);
/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../serialization */ 253776);
/* harmony import */ var _mutationBatch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mutationBatch */ 664726);






/**
 * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload
 */
function initMutationObserver(mutationCallback, configuration, shadowRootsController, target) {
  var MutationObserver = (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.getMutationObserverConstructor)();
  if (!MutationObserver) {
    return {
      stop: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.noop,
      flush: _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.noop
    };
  }
  var mutationBatch = (0,_mutationBatch__WEBPACK_IMPORTED_MODULE_4__.createMutationBatch)(function (mutations) {
    processMutations(mutations.concat(observer.takeRecords()), mutationCallback, configuration, shadowRootsController, target);
  });
  var observer = new MutationObserver((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.monitor)(mutationBatch.addMutations));
  observer.observe(target, {
    attributeOldValue: true,
    attributes: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true
  });
  return {
    stop: function () {
      observer.disconnect();
      mutationBatch.stop();
    },
    flush: function () {
      mutationBatch.flush();
    }
  };
}
function processMutations(mutations, mutationCallback, configuration, shadowRootsController, target) {
  mutations.filter(function (mutation) {
    return mutation.type === 'childList';
  }).forEach(function (mutation) {
    mutation.removedNodes.forEach(function (removedNode) {
      traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot);
    });
  });
  // Discard any mutation with a 'target' node that:
  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely
  // part of a mutation occurring in a parent Node
  // * should be hidden or ignored
  var filteredMutations = mutations.filter(function (mutation) {
    return target.contains(mutation.target) && (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.nodeAndAncestorsHaveSerializedNode)(mutation.target) && (0,_privacy__WEBPACK_IMPORTED_MODULE_2__.getNodePrivacyLevel)(mutation.target, configuration.defaultPrivacyLevel) !== _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.HIDDEN;
  });
  var _a = processChildListMutations(filteredMutations.filter(function (mutation) {
      return mutation.type === 'childList';
    }), configuration, shadowRootsController),
    adds = _a.adds,
    removes = _a.removes,
    hasBeenSerialized = _a.hasBeenSerialized;
  var texts = processCharacterDataMutations(filteredMutations.filter(function (mutation) {
    return mutation.type === 'characterData' && !hasBeenSerialized(mutation.target);
  }), configuration);
  var attributes = processAttributesMutations(filteredMutations.filter(function (mutation) {
    return mutation.type === 'attributes' && !hasBeenSerialized(mutation.target);
  }), configuration);
  if (!texts.length && !attributes.length && !removes.length && !adds.length) {
    return;
  }
  mutationCallback({
    adds: adds,
    removes: removes,
    texts: texts,
    attributes: attributes
  });
}
function processChildListMutations(mutations, configuration, shadowRootsController) {
  // First, we iterate over mutations to collect:
  //
  // * nodes that have been added in the document and not removed by a subsequent mutation
  // * nodes that have been removed from the document but were not added in a previous mutation
  //
  // For this second category, we also collect their previous parent (mutation.target) because we'll
  // need it to emit a 'remove' mutation.
  //
  // Those two categories may overlap: if a node moved from a position to another, it is reported as
  // two mutation records, one with a "removedNodes" and the other with "addedNodes". In this case,
  // the node will be in both sets.
  var addedAndMovedNodes = new Set();
  var removedNodes = new Map();
  var _loop_1 = function (mutation) {
    mutation.addedNodes.forEach(function (node) {
      addedAndMovedNodes.add(node);
    });
    mutation.removedNodes.forEach(function (node) {
      if (!addedAndMovedNodes.has(node)) {
        removedNodes.set(node, mutation.target);
      }
      addedAndMovedNodes.delete(node);
    });
  };
  for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
    var mutation = mutations_1[_i];
    _loop_1(mutation);
  }
  // Then, we sort nodes that are still in the document by topological order, for two reasons:
  //
  // * We will serialize each added nodes with their descendants. We don't want to serialize a node
  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in
  // a precedent node.
  //
  // * To emit "add" mutations, we need references to the parent and potential next sibling of each
  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are
  // siblings, we want to iterate from last to first. This will ensure that any "next" node is
  // already serialized and have an id.
  var sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);
  sortAddedAndMovedNodes(sortedAddedAndMovedNodes);
  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized
  // node ids in a set to be able to skip subsequent related mutations.
  var serializedNodeIds = new Set();
  var addedNodeMutations = [];
  for (var _a = 0, sortedAddedAndMovedNodes_1 = sortedAddedAndMovedNodes; _a < sortedAddedAndMovedNodes_1.length; _a++) {
    var node = sortedAddedAndMovedNodes_1[_a];
    if (hasBeenSerialized(node)) {
      continue;
    }
    var parentNodePrivacyLevel = (0,_privacy__WEBPACK_IMPORTED_MODULE_2__.getNodePrivacyLevel)(node.parentNode, configuration.defaultPrivacyLevel);
    if (parentNodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.IGNORE) {
      continue;
    }
    var serializedNode = (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.serializeNodeWithId)(node, {
      serializedNodeIds: serializedNodeIds,
      parentNodePrivacyLevel: parentNodePrivacyLevel,
      serializationContext: {
        status: 2 /* SerializationContextStatus.MUTATION */,
        shadowRootsController: shadowRootsController
      },
      configuration: configuration
    });
    if (!serializedNode) {
      continue;
    }
    var parentNode = (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(node);
    addedNodeMutations.push({
      nextId: getNextSibling(node),
      parentId: (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.getSerializedNodeId)(parentNode),
      node: serializedNode
    });
  }
  // Finally, we emit remove mutations.
  var removedNodeMutations = [];
  removedNodes.forEach(function (parent, node) {
    if ((0,_serialization__WEBPACK_IMPORTED_MODULE_3__.hasSerializedNode)(node)) {
      removedNodeMutations.push({
        parentId: (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.getSerializedNodeId)(parent),
        id: (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.getSerializedNodeId)(node)
      });
    }
  });
  return {
    adds: addedNodeMutations,
    removes: removedNodeMutations,
    hasBeenSerialized: hasBeenSerialized
  };
  function hasBeenSerialized(node) {
    return (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.hasSerializedNode)(node) && serializedNodeIds.has((0,_serialization__WEBPACK_IMPORTED_MODULE_3__.getSerializedNodeId)(node));
  }
  function getNextSibling(node) {
    var nextSibling = node.nextSibling;
    while (nextSibling) {
      if ((0,_serialization__WEBPACK_IMPORTED_MODULE_3__.hasSerializedNode)(nextSibling)) {
        return (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.getSerializedNodeId)(nextSibling);
      }
      nextSibling = nextSibling.nextSibling;
    }
    return null;
  }
}
function processCharacterDataMutations(mutations, configuration) {
  var _a;
  var textMutations = [];
  // Deduplicate mutations based on their target node
  var handledNodes = new Set();
  var filteredMutations = mutations.filter(function (mutation) {
    if (handledNodes.has(mutation.target)) {
      return false;
    }
    handledNodes.add(mutation.target);
    return true;
  });
  // Emit mutations
  for (var _i = 0, filteredMutations_1 = filteredMutations; _i < filteredMutations_1.length; _i++) {
    var mutation = filteredMutations_1[_i];
    var value = mutation.target.textContent;
    if (value === mutation.oldValue) {
      continue;
    }
    var parentNodePrivacyLevel = (0,_privacy__WEBPACK_IMPORTED_MODULE_2__.getNodePrivacyLevel)((0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(mutation.target), configuration.defaultPrivacyLevel);
    if (parentNodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.IGNORE) {
      continue;
    }
    textMutations.push({
      id: (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.getSerializedNodeId)(mutation.target),
      // TODO: pass a valid "ignoreWhiteSpace" argument
      value: (_a = (0,_privacy__WEBPACK_IMPORTED_MODULE_2__.getTextContent)(mutation.target, false, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null
    });
  }
  return textMutations;
}
function processAttributesMutations(mutations, configuration) {
  var attributeMutations = [];
  // Deduplicate mutations based on their target node and changed attribute
  var handledElements = new Map();
  var filteredMutations = mutations.filter(function (mutation) {
    var handledAttributes = handledElements.get(mutation.target);
    if (handledAttributes === null || handledAttributes === void 0 ? void 0 : handledAttributes.has(mutation.attributeName)) {
      return false;
    }
    if (!handledAttributes) {
      handledElements.set(mutation.target, new Set([mutation.attributeName]));
    } else {
      handledAttributes.add(mutation.attributeName);
    }
    return true;
  });
  // Emit mutations
  var emittedMutations = new Map();
  for (var _i = 0, filteredMutations_2 = filteredMutations; _i < filteredMutations_2.length; _i++) {
    var mutation = filteredMutations_2[_i];
    var uncensoredValue = mutation.target.getAttribute(mutation.attributeName);
    if (uncensoredValue === mutation.oldValue) {
      continue;
    }
    var privacyLevel = (0,_privacy__WEBPACK_IMPORTED_MODULE_2__.getNodePrivacyLevel)(mutation.target, configuration.defaultPrivacyLevel);
    var attributeValue = (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.serializeAttribute)(mutation.target, privacyLevel, mutation.attributeName, configuration);
    var transformedValue = void 0;
    if (mutation.attributeName === 'value') {
      var inputValue = (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.getElementInputValue)(mutation.target, privacyLevel);
      if (inputValue === undefined) {
        continue;
      }
      transformedValue = inputValue;
    } else if (typeof attributeValue === 'string') {
      transformedValue = attributeValue;
    } else {
      transformedValue = null;
    }
    var emittedMutation = emittedMutations.get(mutation.target);
    if (!emittedMutation) {
      emittedMutation = {
        id: (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.getSerializedNodeId)(mutation.target),
        attributes: {}
      };
      attributeMutations.push(emittedMutation);
      emittedMutations.set(mutation.target, emittedMutation);
    }
    emittedMutation.attributes[mutation.attributeName] = transformedValue;
  }
  return attributeMutations;
}
function sortAddedAndMovedNodes(nodes) {
  nodes.sort(function (a, b) {
    var position = a.compareDocumentPosition(b);
    /* eslint-disable no-bitwise */
    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
      return -1;
    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {
      return 1;
    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
      return 1;
    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {
      return -1;
    }
    /* eslint-enable no-bitwise */
    return 0;
  });
}
function traverseRemovedShadowDom(removedNode, shadowDomRemovedCallback) {
  if ((0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.isNodeShadowHost)(removedNode)) {
    shadowDomRemovedCallback(removedNode.shadowRoot);
  }
  (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.getChildNodes)(removedNode).forEach(function (child) {
    return traverseRemovedShadowDom(child, shadowDomRemovedCallback);
  });
}
//# sourceMappingURL=mutationObserver.js.map

/***/ }),

/***/ 562477:
/*!************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/observers.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initObservers": () => (/* binding */ initObservers)
/* harmony export */ });
/* harmony import */ var _moveObserver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./moveObserver */ 592825);
/* harmony import */ var _scrollObserver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scrollObserver */ 752326);
/* harmony import */ var _mouseInteractionObserver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mouseInteractionObserver */ 732112);
/* harmony import */ var _inputObserver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inputObserver */ 140266);
/* harmony import */ var _styleSheetObserver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./styleSheetObserver */ 40213);
/* harmony import */ var _mediaInteractionObserver__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mediaInteractionObserver */ 559167);
/* harmony import */ var _frustrationObserver__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./frustrationObserver */ 924815);
/* harmony import */ var _viewportResizeObserver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./viewportResizeObserver */ 837655);
/* harmony import */ var _mutationObserver__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mutationObserver */ 388251);
/* harmony import */ var _focusObserver__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./focusObserver */ 65775);
/* harmony import */ var _recordIds__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./recordIds */ 875209);











function initObservers(o) {
  var recordIds = (0,_recordIds__WEBPACK_IMPORTED_MODULE_10__.initRecordIds)();
  var mutationHandler = (0,_mutationObserver__WEBPACK_IMPORTED_MODULE_8__.initMutationObserver)(o.mutationCb, o.configuration, o.shadowRootsController, document);
  var mousemoveHandler = (0,_moveObserver__WEBPACK_IMPORTED_MODULE_0__.initMoveObserver)(o.mousemoveCb);
  var mouseInteractionHandler = (0,_mouseInteractionObserver__WEBPACK_IMPORTED_MODULE_2__.initMouseInteractionObserver)(o.mouseInteractionCb, o.configuration.defaultPrivacyLevel, recordIds);
  var scrollHandler = (0,_scrollObserver__WEBPACK_IMPORTED_MODULE_1__.initScrollObserver)(o.scrollCb, o.configuration.defaultPrivacyLevel, o.elementsScrollPositions);
  var viewportResizeHandler = (0,_viewportResizeObserver__WEBPACK_IMPORTED_MODULE_7__.initViewportResizeObserver)(o.viewportResizeCb);
  var inputHandler = (0,_inputObserver__WEBPACK_IMPORTED_MODULE_3__.initInputObserver)(o.inputCb, o.configuration.defaultPrivacyLevel);
  var mediaInteractionHandler = (0,_mediaInteractionObserver__WEBPACK_IMPORTED_MODULE_5__.initMediaInteractionObserver)(o.mediaInteractionCb, o.configuration.defaultPrivacyLevel);
  var styleSheetObserver = (0,_styleSheetObserver__WEBPACK_IMPORTED_MODULE_4__.initStyleSheetObserver)(o.styleSheetCb);
  var focusHandler = (0,_focusObserver__WEBPACK_IMPORTED_MODULE_9__.initFocusObserver)(o.focusCb);
  var visualViewportResizeHandler = (0,_viewportResizeObserver__WEBPACK_IMPORTED_MODULE_7__.initVisualViewportResizeObserver)(o.visualViewportResizeCb);
  var frustrationHandler = (0,_frustrationObserver__WEBPACK_IMPORTED_MODULE_6__.initFrustrationObserver)(o.lifeCycle, o.frustrationCb, recordIds);
  return {
    flush: function () {
      mutationHandler.flush();
    },
    stop: function () {
      mutationHandler.stop();
      mousemoveHandler();
      mouseInteractionHandler();
      scrollHandler();
      viewportResizeHandler();
      inputHandler();
      mediaInteractionHandler();
      styleSheetObserver();
      focusHandler();
      visualViewportResizeHandler();
      frustrationHandler();
    }
  };
}
//# sourceMappingURL=observers.js.map

/***/ }),

/***/ 875209:
/*!************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/recordIds.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initRecordIds": () => (/* binding */ initRecordIds)
/* harmony export */ });
function initRecordIds() {
  var recordIds = new WeakMap();
  var nextId = 1;
  return {
    getIdForEvent: function (event) {
      if (!recordIds.has(event)) {
        recordIds.set(event, nextId++);
      }
      return recordIds.get(event);
    }
  };
}
//# sourceMappingURL=recordIds.js.map

/***/ }),

/***/ 752326:
/*!*****************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/scrollObserver.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initScrollObserver": () => (/* binding */ initScrollObserver)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datadog/browser-core */ 822006);
/* harmony import */ var _eventsUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../eventsUtils */ 32115);
/* harmony import */ var _privacy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../privacy */ 76231);
/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../serialization */ 253776);
/* harmony import */ var _viewports__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../viewports */ 807602);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../constants */ 956683);






var SCROLL_OBSERVER_THRESHOLD = 100;
function initScrollObserver(cb, defaultPrivacyLevel, elementsScrollPositions) {
  var updatePosition = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.throttle)(function (event) {
    var target = (0,_eventsUtils__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);
    if (!target || (0,_privacy__WEBPACK_IMPORTED_MODULE_1__.getNodePrivacyLevel)(target, defaultPrivacyLevel) === _constants__WEBPACK_IMPORTED_MODULE_4__.NodePrivacyLevel.HIDDEN || !(0,_serialization__WEBPACK_IMPORTED_MODULE_2__.hasSerializedNode)(target)) {
      return;
    }
    var id = (0,_serialization__WEBPACK_IMPORTED_MODULE_2__.getSerializedNodeId)(target);
    var scrollPositions = target === document ? {
      scrollTop: (0,_viewports__WEBPACK_IMPORTED_MODULE_3__.getScrollY)(),
      scrollLeft: (0,_viewports__WEBPACK_IMPORTED_MODULE_3__.getScrollX)()
    } : {
      scrollTop: Math.round(target.scrollTop),
      scrollLeft: Math.round(target.scrollLeft)
    };
    elementsScrollPositions.set(target, scrollPositions);
    cb({
      id: id,
      x: scrollPositions.scrollLeft,
      y: scrollPositions.scrollTop
    });
  }, SCROLL_OBSERVER_THRESHOLD).throttled;
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_6__.addEventListener)(document, "scroll" /* DOM_EVENT.SCROLL */, updatePosition, {
    capture: true,
    passive: true
  }).stop;
}
//# sourceMappingURL=scrollObserver.js.map

/***/ }),

/***/ 40213:
/*!*********************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/styleSheetObserver.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPathToNestedCSSRule": () => (/* binding */ getPathToNestedCSSRule),
/* harmony export */   "initStyleSheetObserver": () => (/* binding */ initStyleSheetObserver)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 101280);
/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../serialization */ 253776);


function initStyleSheetObserver(cb) {
  function checkStyleSheetAndCallback(styleSheet, callback) {
    if (styleSheet && (0,_serialization__WEBPACK_IMPORTED_MODULE_0__.hasSerializedNode)(styleSheet.ownerNode)) {
      callback((0,_serialization__WEBPACK_IMPORTED_MODULE_0__.getSerializedNodeId)(styleSheet.ownerNode));
    }
  }
  var instrumentationStoppers = [(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.instrumentMethodAndCallOriginal)(CSSStyleSheet.prototype, 'insertRule', {
    before: function (rule, index) {
      checkStyleSheetAndCallback(this, function (id) {
        return cb({
          id: id,
          adds: [{
            rule: rule,
            index: index
          }]
        });
      });
    }
  }), (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.instrumentMethodAndCallOriginal)(CSSStyleSheet.prototype, 'deleteRule', {
    before: function (index) {
      checkStyleSheetAndCallback(this, function (id) {
        return cb({
          id: id,
          removes: [{
            index: index
          }]
        });
      });
    }
  })];
  if (typeof CSSGroupingRule !== 'undefined') {
    instrumentGroupingCSSRuleClass(CSSGroupingRule);
  } else {
    instrumentGroupingCSSRuleClass(CSSMediaRule);
    instrumentGroupingCSSRuleClass(CSSSupportsRule);
  }
  function instrumentGroupingCSSRuleClass(cls) {
    instrumentationStoppers.push((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.instrumentMethodAndCallOriginal)(cls.prototype, 'insertRule', {
      before: function (rule, index) {
        var _this = this;
        checkStyleSheetAndCallback(this.parentStyleSheet, function (id) {
          var path = getPathToNestedCSSRule(_this);
          if (path) {
            path.push(index || 0);
            cb({
              id: id,
              adds: [{
                rule: rule,
                index: path
              }]
            });
          }
        });
      }
    }), (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.instrumentMethodAndCallOriginal)(cls.prototype, 'deleteRule', {
      before: function (index) {
        var _this = this;
        checkStyleSheetAndCallback(this.parentStyleSheet, function (id) {
          var path = getPathToNestedCSSRule(_this);
          if (path) {
            path.push(index);
            cb({
              id: id,
              removes: [{
                index: path
              }]
            });
          }
        });
      }
    }));
  }
  return function () {
    return instrumentationStoppers.forEach(function (stopper) {
      return stopper.stop();
    });
  };
}
function getPathToNestedCSSRule(rule) {
  var path = [];
  var currentRule = rule;
  while (currentRule.parentRule) {
    var rules_1 = Array.from(currentRule.parentRule.cssRules);
    var index_1 = rules_1.indexOf(currentRule);
    path.unshift(index_1);
    currentRule = currentRule.parentRule;
  }
  // A rule may not be attached to a stylesheet
  if (!currentRule.parentStyleSheet) {
    return;
  }
  var rules = Array.from(currentRule.parentStyleSheet.cssRules);
  var index = rules.indexOf(currentRule);
  path.unshift(index);
  return path;
}
//# sourceMappingURL=styleSheetObserver.js.map

/***/ }),

/***/ 837655:
/*!*************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/observers/viewportResizeObserver.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initViewportResizeObserver": () => (/* binding */ initViewportResizeObserver),
/* harmony export */   "initVisualViewportResizeObserver": () => (/* binding */ initVisualViewportResizeObserver)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 897826);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 822006);
/* harmony import */ var _datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-rum-core */ 454959);
/* harmony import */ var _viewports__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../viewports */ 807602);



var VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200;
function initViewportResizeObserver(cb) {
  return (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.initViewportObservable)().subscribe(cb).unsubscribe;
}
function initVisualViewportResizeObserver(cb) {
  var visualViewport = window.visualViewport;
  if (!visualViewport) {
    return _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.noop;
  }
  var _a = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.throttle)(function () {
      cb((0,_viewports__WEBPACK_IMPORTED_MODULE_1__.getVisualViewport)(visualViewport));
    }, VISUAL_VIEWPORT_OBSERVER_THRESHOLD, {
      trailing: false
    }),
    updateDimension = _a.throttled,
    cancelThrottle = _a.cancel;
  var removeListener = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.addEventListeners)(visualViewport, ["resize" /* DOM_EVENT.RESIZE */, "scroll" /* DOM_EVENT.SCROLL */], updateDimension, {
    capture: true,
    passive: true
  }).stop;
  return function stop() {
    removeListener();
    cancelThrottle();
  };
}
//# sourceMappingURL=viewportResizeObserver.js.map

/***/ }),

/***/ 76231:
/*!************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/privacy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MAX_ATTRIBUTE_VALUE_CHAR_LENGTH": () => (/* binding */ MAX_ATTRIBUTE_VALUE_CHAR_LENGTH),
/* harmony export */   "censorText": () => (/* binding */ censorText),
/* harmony export */   "getNodePrivacyLevel": () => (/* binding */ getNodePrivacyLevel),
/* harmony export */   "getNodeSelfPrivacyLevel": () => (/* binding */ getNodeSelfPrivacyLevel),
/* harmony export */   "getTextContent": () => (/* binding */ getTextContent),
/* harmony export */   "reducePrivacyLevel": () => (/* binding */ reducePrivacyLevel),
/* harmony export */   "shouldIgnoreElement": () => (/* binding */ shouldIgnoreElement),
/* harmony export */   "shouldMaskNode": () => (/* binding */ shouldMaskNode)
/* harmony export */ });
/* harmony import */ var _datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-rum-core */ 454959);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants */ 956683);


var MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 100000;
var TEXT_MASKING_CHAR = 'x';
/**
 * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is
 * know, it is best to use something like:
 *
 * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)
 */
function getNodePrivacyLevel(node, defaultPrivacyLevel) {
  var parentNode = (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(node);
  var parentNodePrivacyLevel = parentNode ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel) : defaultPrivacyLevel;
  var selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node);
  return reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel);
}
/**
 * Reduces the next privacy level based on self + parent privacy levels
 */
function reducePrivacyLevel(childPrivacyLevel, parentNodePrivacyLevel) {
  switch (parentNodePrivacyLevel) {
    // These values cannot be overridden
    case _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.HIDDEN:
    case _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.IGNORE:
      return parentNodePrivacyLevel;
  }
  switch (childPrivacyLevel) {
    case _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.ALLOW:
    case _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.MASK:
    case _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.MASK_USER_INPUT:
    case _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.HIDDEN:
    case _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.IGNORE:
      return childPrivacyLevel;
    default:
      return parentNodePrivacyLevel;
  }
}
/**
 * Determines the node's own privacy level without checking for ancestors.
 */
function getNodeSelfPrivacyLevel(node) {
  // Only Element types can have a privacy level set
  if (!(0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.isElementNode)(node)) {
    return;
  }
  var privAttr = node.getAttribute(_constants__WEBPACK_IMPORTED_MODULE_1__.PRIVACY_ATTR_NAME);
  // Overrules for replay purpose
  if (node.tagName === 'BASE') {
    return _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.ALLOW;
  }
  // Overrules to enforce end-user protection
  if (node.tagName === 'INPUT') {
    var inputElement = node;
    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {
      return _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.MASK;
    }
    if (inputElement.type === 'hidden') {
      return _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.MASK;
    }
    var autocomplete = inputElement.getAttribute('autocomplete');
    // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]
    if (autocomplete && autocomplete.indexOf('cc-') === 0) {
      return _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.MASK;
    }
  }
  // Check HTML privacy attributes and classes
  if (privAttr === _constants__WEBPACK_IMPORTED_MODULE_1__.PRIVACY_ATTR_VALUE_HIDDEN || node.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_1__.PRIVACY_CLASS_HIDDEN)) {
    return _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.HIDDEN;
  }
  if (privAttr === _constants__WEBPACK_IMPORTED_MODULE_1__.PRIVACY_ATTR_VALUE_MASK || node.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_1__.PRIVACY_CLASS_MASK)) {
    return _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.MASK;
  }
  if (privAttr === _constants__WEBPACK_IMPORTED_MODULE_1__.PRIVACY_ATTR_VALUE_MASK_USER_INPUT || node.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_1__.PRIVACY_CLASS_MASK_USER_INPUT)) {
    return _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.MASK_USER_INPUT;
  }
  if (privAttr === _constants__WEBPACK_IMPORTED_MODULE_1__.PRIVACY_ATTR_VALUE_ALLOW || node.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_1__.PRIVACY_CLASS_ALLOW)) {
    return _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.ALLOW;
  }
  if (shouldIgnoreElement(node)) {
    return _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.IGNORE;
  }
}
/**
 * Helper aiming to unify `mask` and `mask-user-input` privacy levels:
 *
 * In the `mask` case, it is trivial: we should mask the element.
 *
 * In the `mask-user-input` case, we should mask the element only if it is a "form" element or the
 * direct parent is a form element for text nodes).
 *
 * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a
 * node if it is ignored or hidden? it doesn't matter since it won't be serialized).
 */
function shouldMaskNode(node, privacyLevel) {
  switch (privacyLevel) {
    case _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.MASK:
    case _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.HIDDEN:
    case _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.IGNORE:
      return true;
    case _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.MASK_USER_INPUT:
      return (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.isTextNode)(node) ? isFormElement(node.parentNode) : isFormElement(node);
    default:
      return false;
  }
}
function isFormElement(node) {
  if (!node || node.nodeType !== node.ELEMENT_NODE) {
    return false;
  }
  var element = node;
  if (element.tagName === 'INPUT') {
    switch (element.type) {
      case 'button':
      case 'color':
      case 'reset':
      case 'submit':
        return false;
    }
  }
  return !!_constants__WEBPACK_IMPORTED_MODULE_1__.FORM_PRIVATE_TAG_NAMES[element.tagName];
}
/**
 * Text censoring non-destructively maintains whitespace characters in order to preserve text shape
 * during replay.
 */
var censorText = function (text) {
  return text.replace(/\S/g, TEXT_MASKING_CHAR);
};
function getTextContent(textNode, ignoreWhiteSpace, parentNodePrivacyLevel) {
  var _a;
  // The parent node may not be a html element which has a tagName attribute.
  // So just let it be undefined which is ok in this use case.
  var parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;
  var textContent = textNode.textContent || '';
  if (ignoreWhiteSpace && !textContent.trim()) {
    return;
  }
  var nodePrivacyLevel = parentNodePrivacyLevel;
  var isStyle = parentTagName === 'STYLE' ? true : undefined;
  var isScript = parentTagName === 'SCRIPT';
  if (isScript) {
    // For perf reasons, we don't record script (heuristic)
    textContent = _constants__WEBPACK_IMPORTED_MODULE_1__.CENSORED_STRING_MARK;
  } else if (nodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.HIDDEN) {
    // Should never occur, but just in case, we set to CENSORED_MARK.
    textContent = _constants__WEBPACK_IMPORTED_MODULE_1__.CENSORED_STRING_MARK;
  } else if (shouldMaskNode(textNode, nodePrivacyLevel) &&
  // Style tags are `overruled` (Use `hide` to enforce privacy)
  !isStyle) {
    if (
    // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP
    parentTagName === 'DATALIST' || parentTagName === 'SELECT' || parentTagName === 'OPTGROUP') {
      if (!textContent.trim()) {
        return;
      }
    } else if (parentTagName === 'OPTION') {
      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked
      textContent = _constants__WEBPACK_IMPORTED_MODULE_1__.CENSORED_STRING_MARK;
    } else {
      textContent = censorText(textContent);
    }
  }
  return textContent;
}
/**
 * TODO: Preserve CSS element order, and record the presence of the tag, just don't render
 * We don't need this logic on the recorder side.
 * For security related meta's, customer can mask themmanually given they
 * are easy to identify in the HEAD tag.
 */
function shouldIgnoreElement(element) {
  if (element.nodeName === 'SCRIPT') {
    return true;
  }
  if (element.nodeName === 'LINK') {
    var relAttribute = getLowerCaseAttribute('rel');
    return (
      // Link as script - Ignore only when rel=preload, modulepreload or prefetch
      /preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script' ||
      // Favicons
      relAttribute === 'shortcut icon' || relAttribute === 'icon'
    );
  }
  if (element.nodeName === 'META') {
    var nameAttribute = getLowerCaseAttribute('name');
    var relAttribute = getLowerCaseAttribute('rel');
    var propertyAttribute = getLowerCaseAttribute('property');
    return (
      // Favicons
      /^msapplication-tile(image|color)$/.test(nameAttribute) || nameAttribute === 'application-name' || relAttribute === 'icon' || relAttribute === 'apple-touch-icon' || relAttribute === 'shortcut icon' ||
      // Description
      nameAttribute === 'keywords' || nameAttribute === 'description' ||
      // Social
      /^(og|twitter|fb):/.test(propertyAttribute) || /^(og|twitter):/.test(nameAttribute) || nameAttribute === 'pinterest' ||
      // Robots
      nameAttribute === 'robots' || nameAttribute === 'googlebot' || nameAttribute === 'bingbot' ||
      // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,
      // X-Translated-By
      element.hasAttribute('http-equiv') ||
      // Authorship
      nameAttribute === 'author' || nameAttribute === 'generator' || nameAttribute === 'framework' || nameAttribute === 'publisher' || nameAttribute === 'progid' || /^article:/.test(propertyAttribute) || /^product:/.test(propertyAttribute) ||
      // Verification
      nameAttribute === 'google-site-verification' || nameAttribute === 'yandex-verification' || nameAttribute === 'csrf-token' || nameAttribute === 'p:domain_verify' || nameAttribute === 'verify-v1' || nameAttribute === 'verification' || nameAttribute === 'shopify-checkout-api-token'
    );
  }
  function getLowerCaseAttribute(name) {
    return (element.getAttribute(name) || '').toLowerCase();
  }
  return false;
}
//# sourceMappingURL=privacy.js.map

/***/ }),

/***/ 416430:
/*!***********************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/record.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "record": () => (/* binding */ record)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-rum-core */ 454959);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types */ 938168);
/* harmony import */ var _assembly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assembly */ 243982);
/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serialization */ 253776);
/* harmony import */ var _observers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./observers */ 667412);
/* harmony import */ var _viewports__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./viewports */ 807602);
/* harmony import */ var _elementsScrollPositions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./elementsScrollPositions */ 684952);
/* harmony import */ var _shadowRootsController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shadowRootsController */ 854610);









function record(options) {
  var emit = options.emit;
  // runtime checks for user options
  if (!emit) {
    throw new Error('emit function is required');
  }
  var elementsScrollPositions = (0,_elementsScrollPositions__WEBPACK_IMPORTED_MODULE_6__.createElementsScrollPositions)();
  var mutationCb = function (mutation) {
    emit((0,_assembly__WEBPACK_IMPORTED_MODULE_2__.assembleIncrementalSnapshot)(_types__WEBPACK_IMPORTED_MODULE_1__.IncrementalSource.Mutation, mutation));
  };
  var inputCb = function (s) {
    return emit((0,_assembly__WEBPACK_IMPORTED_MODULE_2__.assembleIncrementalSnapshot)(_types__WEBPACK_IMPORTED_MODULE_1__.IncrementalSource.Input, s));
  };
  var shadowRootsController = (0,_shadowRootsController__WEBPACK_IMPORTED_MODULE_7__.initShadowRootsController)(options.configuration, {
    mutationCb: mutationCb,
    inputCb: inputCb
  });
  var takeFullSnapshot = function (timestamp, serializationContext) {
    if (timestamp === void 0) {
      timestamp = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.timeStampNow)();
    }
    if (serializationContext === void 0) {
      serializationContext = {
        status: 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */,
        elementsScrollPositions: elementsScrollPositions,
        shadowRootsController: shadowRootsController
      };
    }
    var _a = (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.getViewportDimension)(),
      width = _a.width,
      height = _a.height;
    emit({
      data: {
        height: height,
        href: window.location.href,
        width: width
      },
      type: _types__WEBPACK_IMPORTED_MODULE_1__.RecordType.Meta,
      timestamp: timestamp
    });
    emit({
      data: {
        has_focus: document.hasFocus()
      },
      type: _types__WEBPACK_IMPORTED_MODULE_1__.RecordType.Focus,
      timestamp: timestamp
    });
    emit({
      data: {
        node: (0,_serialization__WEBPACK_IMPORTED_MODULE_3__.serializeDocument)(document, options.configuration, serializationContext),
        initialOffset: {
          left: (0,_viewports__WEBPACK_IMPORTED_MODULE_5__.getScrollX)(),
          top: (0,_viewports__WEBPACK_IMPORTED_MODULE_5__.getScrollY)()
        }
      },
      type: _types__WEBPACK_IMPORTED_MODULE_1__.RecordType.FullSnapshot,
      timestamp: timestamp
    });
    if (window.visualViewport) {
      emit({
        data: (0,_viewports__WEBPACK_IMPORTED_MODULE_5__.getVisualViewport)(window.visualViewport),
        type: _types__WEBPACK_IMPORTED_MODULE_1__.RecordType.VisualViewport,
        timestamp: timestamp
      });
    }
  };
  takeFullSnapshot();
  var _a = (0,_observers__WEBPACK_IMPORTED_MODULE_4__.initObservers)({
      lifeCycle: options.lifeCycle,
      configuration: options.configuration,
      elementsScrollPositions: elementsScrollPositions,
      inputCb: inputCb,
      mediaInteractionCb: function (p) {
        return emit((0,_assembly__WEBPACK_IMPORTED_MODULE_2__.assembleIncrementalSnapshot)(_types__WEBPACK_IMPORTED_MODULE_1__.IncrementalSource.MediaInteraction, p));
      },
      mouseInteractionCb: function (mouseInteractionRecord) {
        return emit(mouseInteractionRecord);
      },
      mousemoveCb: function (positions, source) {
        return emit((0,_assembly__WEBPACK_IMPORTED_MODULE_2__.assembleIncrementalSnapshot)(source, {
          positions: positions
        }));
      },
      mutationCb: mutationCb,
      scrollCb: function (p) {
        return emit((0,_assembly__WEBPACK_IMPORTED_MODULE_2__.assembleIncrementalSnapshot)(_types__WEBPACK_IMPORTED_MODULE_1__.IncrementalSource.Scroll, p));
      },
      styleSheetCb: function (r) {
        return emit((0,_assembly__WEBPACK_IMPORTED_MODULE_2__.assembleIncrementalSnapshot)(_types__WEBPACK_IMPORTED_MODULE_1__.IncrementalSource.StyleSheetRule, r));
      },
      viewportResizeCb: function (d) {
        return emit((0,_assembly__WEBPACK_IMPORTED_MODULE_2__.assembleIncrementalSnapshot)(_types__WEBPACK_IMPORTED_MODULE_1__.IncrementalSource.ViewportResize, d));
      },
      frustrationCb: function (frustrationRecord) {
        return emit(frustrationRecord);
      },
      focusCb: function (data) {
        return emit({
          data: data,
          type: _types__WEBPACK_IMPORTED_MODULE_1__.RecordType.Focus,
          timestamp: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.timeStampNow)()
        });
      },
      visualViewportResizeCb: function (data) {
        emit({
          data: data,
          type: _types__WEBPACK_IMPORTED_MODULE_1__.RecordType.VisualViewport,
          timestamp: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_8__.timeStampNow)()
        });
      },
      shadowRootsController: shadowRootsController
    }),
    stopObservers = _a.stop,
    flushMutationsFromObservers = _a.flush;
  function flushMutations() {
    shadowRootsController.flush();
    flushMutationsFromObservers();
  }
  return {
    stop: function () {
      shadowRootsController.stop();
      stopObservers();
    },
    takeSubsequentFullSnapshot: function (timestamp) {
      flushMutations();
      takeFullSnapshot(timestamp, {
        shadowRootsController: shadowRootsController,
        status: 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */,
        elementsScrollPositions: elementsScrollPositions
      });
    },
    flushMutations: flushMutations,
    shadowRootsController: shadowRootsController
  };
}
//# sourceMappingURL=record.js.map

/***/ }),

/***/ 253776:
/*!************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/serialization/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getElementInputValue": () => (/* reexport safe */ _serializationUtils__WEBPACK_IMPORTED_MODULE_0__.getElementInputValue),
/* harmony export */   "getSerializedNodeId": () => (/* reexport safe */ _serializationUtils__WEBPACK_IMPORTED_MODULE_0__.getSerializedNodeId),
/* harmony export */   "hasSerializedNode": () => (/* reexport safe */ _serializationUtils__WEBPACK_IMPORTED_MODULE_0__.hasSerializedNode),
/* harmony export */   "nodeAndAncestorsHaveSerializedNode": () => (/* reexport safe */ _serializationUtils__WEBPACK_IMPORTED_MODULE_0__.nodeAndAncestorsHaveSerializedNode),
/* harmony export */   "serializeAttribute": () => (/* reexport safe */ _serializeAttribute__WEBPACK_IMPORTED_MODULE_3__.serializeAttribute),
/* harmony export */   "serializeDocument": () => (/* reexport safe */ _serializeDocument__WEBPACK_IMPORTED_MODULE_1__.serializeDocument),
/* harmony export */   "serializeNodeWithId": () => (/* reexport safe */ _serializeNode__WEBPACK_IMPORTED_MODULE_2__.serializeNodeWithId)
/* harmony export */ });
/* harmony import */ var _serializationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./serializationUtils */ 606626);
/* harmony import */ var _serializeDocument__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serializeDocument */ 701535);
/* harmony import */ var _serializeNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serializeNode */ 590026);
/* harmony import */ var _serializeAttribute__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serializeAttribute */ 897806);




//# sourceMappingURL=index.js.map

/***/ }),

/***/ 606626:
/*!*************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializationUtils.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ABSOLUTE_URL": () => (/* binding */ ABSOLUTE_URL),
/* harmony export */   "DATA_URI": () => (/* binding */ DATA_URI),
/* harmony export */   "URL_IN_CSS_REF": () => (/* binding */ URL_IN_CSS_REF),
/* harmony export */   "getElementInputValue": () => (/* binding */ getElementInputValue),
/* harmony export */   "getSerializedNodeId": () => (/* binding */ getSerializedNodeId),
/* harmony export */   "getValidTagName": () => (/* binding */ getValidTagName),
/* harmony export */   "hasSerializedNode": () => (/* binding */ hasSerializedNode),
/* harmony export */   "makeUrlAbsolute": () => (/* binding */ makeUrlAbsolute),
/* harmony export */   "nodeAndAncestorsHaveSerializedNode": () => (/* binding */ nodeAndAncestorsHaveSerializedNode),
/* harmony export */   "setSerializedNodeId": () => (/* binding */ setSerializedNodeId),
/* harmony export */   "switchToAbsoluteUrl": () => (/* binding */ switchToAbsoluteUrl)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 77615);
/* harmony import */ var _datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-rum-core */ 454959);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../constants */ 956683);
/* harmony import */ var _privacy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../privacy */ 76231);




var serializedNodeIds = new WeakMap();
function hasSerializedNode(node) {
  return serializedNodeIds.has(node);
}
function nodeAndAncestorsHaveSerializedNode(node) {
  var current = node;
  while (current) {
    if (!hasSerializedNode(current) && !(0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.isNodeShadowRoot)(current)) {
      return false;
    }
    current = (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(current);
  }
  return true;
}
function getSerializedNodeId(node) {
  return serializedNodeIds.get(node);
}
function setSerializedNodeId(node, serializeNodeId) {
  serializedNodeIds.set(node, serializeNodeId);
}
/**
 * Get the element "value" to be serialized as an attribute or an input update record. It respects
 * the input privacy mode of the element.
 * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.
 */
function getElementInputValue(element, nodePrivacyLevel) {
  /*
   BROWSER SPEC NOTE: <input>, <select>
   For some <input> elements, the `value` is an exceptional property/attribute that has the
   value synced between el.value and el.getAttribute()
   input[type=button,checkbox,hidden,image,radio,reset,submit]
   */
  var tagName = element.tagName;
  var value = element.value;
  if ((0,_privacy__WEBPACK_IMPORTED_MODULE_2__.shouldMaskNode)(element, nodePrivacyLevel)) {
    var type = element.type;
    if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {
      // Overrule `MASK` privacy level for button-like element values, as they are used during replay
      // to display their label. They can still be hidden via the "hidden" privacy attribute or class name.
      return value;
    } else if (!value || tagName === 'OPTION') {
      // <Option> value provides no benefit
      return;
    }
    return _constants__WEBPACK_IMPORTED_MODULE_1__.CENSORED_STRING_MARK;
  }
  if (tagName === 'OPTION' || tagName === 'SELECT') {
    return element.value;
  }
  if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {
    return;
  }
  return value;
}
var URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")([^"]*)"|([^)]*))\)/gm;
var ABSOLUTE_URL = /^[A-Za-z]+:|^\/\//;
var DATA_URI = /^data:.*,/i;
function switchToAbsoluteUrl(cssText, cssHref) {
  return cssText.replace(URL_IN_CSS_REF, function (matchingSubstring, singleQuote, urlWrappedInSingleQuotes, doubleQuote, urlWrappedInDoubleQuotes, urlNotWrappedInQuotes) {
    var url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes;
    if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {
      return matchingSubstring;
    }
    var quote = singleQuote || doubleQuote || '';
    return "url(".concat(quote).concat(makeUrlAbsolute(url, cssHref)).concat(quote, ")");
  });
}
function makeUrlAbsolute(url, baseUrl) {
  try {
    return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.buildUrl)(url, baseUrl).href;
  } catch (_) {
    return url;
  }
}
var TAG_NAME_REGEX = /[^a-z1-6-_]/;
function getValidTagName(tagName) {
  var processedTagName = tagName.toLowerCase().trim();
  if (TAG_NAME_REGEX.test(processedTagName)) {
    // if the tag name is odd and we cannot extract
    // anything from the string, then we return a
    // generic div
    return 'div';
  }
  return processedTagName;
}
//# sourceMappingURL=serializationUtils.js.map

/***/ }),

/***/ 897806:
/*!*************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttribute.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "serializeAttribute": () => (/* binding */ serializeAttribute)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-rum-core */ 454959);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../constants */ 956683);
/* harmony import */ var _privacy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../privacy */ 76231);




function serializeAttribute(element, nodePrivacyLevel, attributeName, configuration) {
  if (nodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.HIDDEN) {
    // dup condition for direct access case
    return null;
  }
  var attributeValue = element.getAttribute(attributeName);
  if (nodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_1__.NodePrivacyLevel.MASK && attributeName !== _constants__WEBPACK_IMPORTED_MODULE_1__.PRIVACY_ATTR_NAME && !_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.STABLE_ATTRIBUTES.includes(attributeName) && attributeName !== configuration.actionNameAttribute) {
    var tagName = element.tagName;
    switch (attributeName) {
      // Mask Attribute text content
      case 'title':
      case 'alt':
      case 'placeholder':
        return _constants__WEBPACK_IMPORTED_MODULE_1__.CENSORED_STRING_MARK;
    }
    // mask image URLs
    if (tagName === 'IMG' || tagName === 'SOURCE') {
      if (attributeName === 'src' || attributeName === 'srcset') {
        return _constants__WEBPACK_IMPORTED_MODULE_1__.CENSORED_IMG_MARK;
      }
    }
    // mask <a> URLs
    if (tagName === 'A' && attributeName === 'href') {
      return _constants__WEBPACK_IMPORTED_MODULE_1__.CENSORED_STRING_MARK;
    }
    // mask data-* attributes
    if (attributeValue && (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.startsWith)(attributeName, 'data-')) {
      // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr
      return _constants__WEBPACK_IMPORTED_MODULE_1__.CENSORED_STRING_MARK;
    }
  }
  if (!attributeValue || typeof attributeValue !== 'string') {
    return attributeValue;
  }
  // Minimum Fix for customer.
  if (attributeValue.length > _privacy__WEBPACK_IMPORTED_MODULE_2__.MAX_ATTRIBUTE_VALUE_CHAR_LENGTH && attributeValue.slice(0, 5) === 'data:') {
    return 'data:truncated';
  }
  return attributeValue;
}
//# sourceMappingURL=serializeAttribute.js.map

/***/ }),

/***/ 670111:
/*!**************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttributes.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "serializeAttributes": () => (/* binding */ serializeAttributes)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../constants */ 956683);
/* harmony import */ var _privacy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../privacy */ 76231);
/* harmony import */ var _serializationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serializationUtils */ 606626);
/* harmony import */ var _serializeAttribute__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serializeAttribute */ 897806);




function serializeAttributes(element, nodePrivacyLevel, options) {
  var _a;
  if (nodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_0__.NodePrivacyLevel.HIDDEN) {
    return {};
  }
  var safeAttrs = {};
  var tagName = (0,_serializationUtils__WEBPACK_IMPORTED_MODULE_2__.getValidTagName)(element.tagName);
  var doc = element.ownerDocument;
  for (var i = 0; i < element.attributes.length; i += 1) {
    var attribute = element.attributes.item(i);
    var attributeName = attribute.name;
    var attributeValue = (0,_serializeAttribute__WEBPACK_IMPORTED_MODULE_3__.serializeAttribute)(element, nodePrivacyLevel, attributeName, options.configuration);
    if (attributeValue !== null) {
      safeAttrs[attributeName] = attributeValue;
    }
  }
  if (element.value && (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {
    var formValue = (0,_serializationUtils__WEBPACK_IMPORTED_MODULE_2__.getElementInputValue)(element, nodePrivacyLevel);
    if (formValue !== undefined) {
      safeAttrs.value = formValue;
    }
  }
  /**
   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`
   */
  if (tagName === 'option' && nodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_0__.NodePrivacyLevel.ALLOW) {
    // For privacy=`MASK`, all the values would be the same, so skip.
    var optionElement = element;
    if (optionElement.selected) {
      safeAttrs.selected = optionElement.selected;
    }
  }
  // remote css
  if (tagName === 'link') {
    var stylesheet = Array.from(doc.styleSheets).find(function (s) {
      return s.href === element.href;
    });
    var cssText = getCssRulesString(stylesheet);
    if (cssText && stylesheet) {
      safeAttrs._cssText = cssText;
    }
  }
  // dynamic stylesheet
  if (tagName === 'style' && element.sheet &&
  // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element
  !(element.innerText || element.textContent || '').trim().length) {
    var cssText = getCssRulesString(element.sheet);
    if (cssText) {
      safeAttrs._cssText = cssText;
    }
  }
  /**
   * Forms: input[type=checkbox,radio]
   * The `checked` property for <input> is a little bit special:
   * 1. el.checked is a setter that returns if truthy.
   * 2. getAttribute returns the string value
   * getAttribute('checked') does not sync with `Element.checked`, so use JS property
   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.
   */
  var inputElement = element;
  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {
    if (nodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_0__.NodePrivacyLevel.ALLOW) {
      safeAttrs.checked = !!inputElement.checked;
    } else if ((0,_privacy__WEBPACK_IMPORTED_MODULE_1__.shouldMaskNode)(inputElement, nodePrivacyLevel)) {
      delete safeAttrs.checked;
    }
  }
  /**
   * Serialize the media playback state
   */
  if (tagName === 'audio' || tagName === 'video') {
    var mediaElement = element;
    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';
  }
  /**
   * Serialize the scroll state for each element only for full snapshot
   */
  var scrollTop;
  var scrollLeft;
  var serializationContext = options.serializationContext;
  switch (serializationContext.status) {
    case 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */:
      scrollTop = Math.round(element.scrollTop);
      scrollLeft = Math.round(element.scrollLeft);
      if (scrollTop || scrollLeft) {
        serializationContext.elementsScrollPositions.set(element, {
          scrollTop: scrollTop,
          scrollLeft: scrollLeft
        });
      }
      break;
    case 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */:
      if (serializationContext.elementsScrollPositions.has(element)) {
        ;
        _a = serializationContext.elementsScrollPositions.get(element), scrollTop = _a.scrollTop, scrollLeft = _a.scrollLeft;
      }
      break;
  }
  if (scrollLeft) {
    safeAttrs.rr_scrollLeft = scrollLeft;
  }
  if (scrollTop) {
    safeAttrs.rr_scrollTop = scrollTop;
  }
  return safeAttrs;
}
function getCssRulesString(cssStyleSheet) {
  if (!cssStyleSheet) {
    return null;
  }
  var rules;
  try {
    rules = cssStyleSheet.rules || cssStyleSheet.cssRules;
  } catch (_a) {
    // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface
  }
  if (!rules) {
    return null;
  }
  var styleSheetCssText = Array.from(rules, getCssRuleString).join('');
  return (0,_serializationUtils__WEBPACK_IMPORTED_MODULE_2__.switchToAbsoluteUrl)(styleSheetCssText, cssStyleSheet.href);
}
function getCssRuleString(rule) {
  return isCSSImportRule(rule) ? getCssRulesString(rule.styleSheet) || '' : rule.cssText;
}
function isCSSImportRule(rule) {
  return 'styleSheet' in rule;
}
//# sourceMappingURL=serializeAttributes.js.map

/***/ }),

/***/ 701535:
/*!************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeDocument.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "serializeDocument": () => (/* binding */ serializeDocument)
/* harmony export */ });
/* harmony import */ var _serializeNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./serializeNode */ 590026);

function serializeDocument(document, configuration, serializationContext) {
  // We are sure that Documents are never ignored, so this function never returns null
  return (0,_serializeNode__WEBPACK_IMPORTED_MODULE_0__.serializeNodeWithId)(document, {
    serializationContext: serializationContext,
    parentNodePrivacyLevel: configuration.defaultPrivacyLevel,
    configuration: configuration
  });
}
//# sourceMappingURL=serializeDocument.js.map

/***/ }),

/***/ 590026:
/*!********************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeNode.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateNextId": () => (/* binding */ generateNextId),
/* harmony export */   "serializeChildNodes": () => (/* binding */ serializeChildNodes),
/* harmony export */   "serializeDocumentNode": () => (/* binding */ serializeDocumentNode),
/* harmony export */   "serializeNodeWithId": () => (/* binding */ serializeNodeWithId)
/* harmony export */ });
/* harmony import */ var _datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-rum-core */ 454959);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../types */ 938168);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../constants */ 956683);
/* harmony import */ var _privacy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../privacy */ 76231);
/* harmony import */ var _serializationUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./serializationUtils */ 606626);
/* harmony import */ var _serializeStyleSheets__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./serializeStyleSheets */ 824734);
/* harmony import */ var _serializeAttributes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./serializeAttributes */ 670111);








function serializeNodeWithId(node, options) {
  var serializedNode = serializeNode(node, options);
  if (!serializedNode) {
    return null;
  }
  // Try to reuse the previous id
  var id = (0,_serializationUtils__WEBPACK_IMPORTED_MODULE_4__.getSerializedNodeId)(node) || generateNextId();
  var serializedNodeWithId = serializedNode;
  serializedNodeWithId.id = id;
  (0,_serializationUtils__WEBPACK_IMPORTED_MODULE_4__.setSerializedNodeId)(node, id);
  if (options.serializedNodeIds) {
    options.serializedNodeIds.add(id);
  }
  return serializedNodeWithId;
}
var _nextId = 1;
function generateNextId() {
  return _nextId++;
}
function serializeChildNodes(node, options) {
  var result = [];
  node.childNodes.forEach(function (childNode) {
    var serializedChildNode = serializeNodeWithId(childNode, options);
    if (serializedChildNode) {
      result.push(serializedChildNode);
    }
  });
  return result;
}
function serializeNode(node, options) {
  switch (node.nodeType) {
    case node.DOCUMENT_NODE:
      return serializeDocumentNode(node, options);
    case node.DOCUMENT_FRAGMENT_NODE:
      return serializeDocumentFragmentNode(node, options);
    case node.DOCUMENT_TYPE_NODE:
      return serializeDocumentTypeNode(node);
    case node.ELEMENT_NODE:
      return serializeElementNode(node, options);
    case node.TEXT_NODE:
      return serializeTextNode(node, options);
    case node.CDATA_SECTION_NODE:
      return serializeCDataNode();
  }
}
function serializeDocumentNode(document, options) {
  return {
    type: _types__WEBPACK_IMPORTED_MODULE_1__.NodeType.Document,
    childNodes: serializeChildNodes(document, options),
    adoptedStyleSheets: (0,_serializeStyleSheets__WEBPACK_IMPORTED_MODULE_5__.serializeStyleSheets)(document.adoptedStyleSheets)
  };
}
function serializeDocumentFragmentNode(element, options) {
  var childNodes = [];
  if (element.childNodes.length) {
    childNodes = serializeChildNodes(element, options);
  }
  var isShadowRoot = (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.isNodeShadowRoot)(element);
  if (isShadowRoot) {
    options.serializationContext.shadowRootsController.addShadowRoot(element);
  }
  return {
    type: _types__WEBPACK_IMPORTED_MODULE_1__.NodeType.DocumentFragment,
    childNodes: childNodes,
    isShadowRoot: isShadowRoot,
    adoptedStyleSheets: isShadowRoot ? (0,_serializeStyleSheets__WEBPACK_IMPORTED_MODULE_5__.serializeStyleSheets)(element.adoptedStyleSheets) : undefined
  };
}
function serializeDocumentTypeNode(documentType) {
  return {
    type: _types__WEBPACK_IMPORTED_MODULE_1__.NodeType.DocumentType,
    name: documentType.name,
    publicId: documentType.publicId,
    systemId: documentType.systemId
  };
}
/**
 * Serializing Element nodes involves capturing:
 * 1. HTML ATTRIBUTES:
 * 2. JS STATE:
 * - scroll offsets
 * - Form fields (input value, checkbox checked, option selection, range)
 * - Canvas state,
 * - Media (video/audio) play mode + currentTime
 * - iframe contents
 * - webcomponents
 * 3. CUSTOM PROPERTIES:
 * - height+width for when `hidden` to cover the element
 * 4. EXCLUDED INTERACTION STATE:
 * - focus (possible, but not worth perf impact)
 * - hover (tracked only via mouse activity)
 * - fullscreen mode
 */
function serializeElementNode(element, options) {
  var _a;
  var tagName = (0,_serializationUtils__WEBPACK_IMPORTED_MODULE_4__.getValidTagName)(element.tagName);
  var isSVG = isSVGElement(element) || undefined;
  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the
  // parentNodePrivacyLevel option to avoid iterating over all parents
  var nodePrivacyLevel = (0,_privacy__WEBPACK_IMPORTED_MODULE_3__.reducePrivacyLevel)((0,_privacy__WEBPACK_IMPORTED_MODULE_3__.getNodeSelfPrivacyLevel)(element), options.parentNodePrivacyLevel);
  if (nodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_2__.NodePrivacyLevel.HIDDEN) {
    var _b = element.getBoundingClientRect(),
      width = _b.width,
      height = _b.height;
    return {
      type: _types__WEBPACK_IMPORTED_MODULE_1__.NodeType.Element,
      tagName: tagName,
      attributes: (_a = {
        rr_width: "".concat(width, "px"),
        rr_height: "".concat(height, "px")
      }, _a[_constants__WEBPACK_IMPORTED_MODULE_2__.PRIVACY_ATTR_NAME] = _constants__WEBPACK_IMPORTED_MODULE_2__.PRIVACY_ATTR_VALUE_HIDDEN, _a),
      childNodes: [],
      isSVG: isSVG
    };
  }
  // Ignore Elements like Script and some Link, Metas
  if (nodePrivacyLevel === _constants__WEBPACK_IMPORTED_MODULE_2__.NodePrivacyLevel.IGNORE) {
    return;
  }
  var attributes = (0,_serializeAttributes__WEBPACK_IMPORTED_MODULE_6__.serializeAttributes)(element, nodePrivacyLevel, options);
  var childNodes = [];
  if (element.childNodes.length) {
    // OBJECT POOLING OPTIMIZATION:
    // We should not create a new object systematically as it could impact performances. Try to reuse
    // the same object as much as possible, and clone it only if we need to.
    var childNodesSerializationOptions = void 0;
    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {
      childNodesSerializationOptions = options;
    } else {
      childNodesSerializationOptions = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_7__.assign)({}, options, {
        parentNodePrivacyLevel: nodePrivacyLevel,
        ignoreWhiteSpace: tagName === 'head'
      });
    }
    childNodes = serializeChildNodes(element, childNodesSerializationOptions);
  }
  if ((0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.isNodeShadowHost)(element)) {
    var shadowRoot = serializeNodeWithId(element.shadowRoot, options);
    if (shadowRoot !== null) {
      childNodes.push(shadowRoot);
    }
  }
  return {
    type: _types__WEBPACK_IMPORTED_MODULE_1__.NodeType.Element,
    tagName: tagName,
    attributes: attributes,
    childNodes: childNodes,
    isSVG: isSVG
  };
}
function isSVGElement(el) {
  return el.tagName === 'svg' || el instanceof SVGElement;
}
/**
 * Text Nodes are dependant on Element nodes
 * Privacy levels are set on elements so we check the parentElement of a text node
 * for privacy level.
 */
function serializeTextNode(textNode, options) {
  var _a;
  // The parent node may not be a html element which has a tagName attribute.
  // So just let it be undefined which is ok in this use case.
  var parentTagName = (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.tagName;
  var textContent = (0,_privacy__WEBPACK_IMPORTED_MODULE_3__.getTextContent)(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);
  if (!textContent) {
    return;
  }
  return {
    type: _types__WEBPACK_IMPORTED_MODULE_1__.NodeType.Text,
    textContent: textContent,
    isStyle: parentTagName === 'STYLE' ? true : undefined
  };
}
function serializeCDataNode() {
  return {
    type: _types__WEBPACK_IMPORTED_MODULE_1__.NodeType.CDATA,
    textContent: ''
  };
}
//# sourceMappingURL=serializeNode.js.map

/***/ }),

/***/ 824734:
/*!***************************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeStyleSheets.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "serializeStyleSheets": () => (/* binding */ serializeStyleSheets)
/* harmony export */ });
function serializeStyleSheets(cssStyleSheets) {
  if (cssStyleSheets === undefined || cssStyleSheets.length === 0) {
    return undefined;
  }
  return cssStyleSheets.map(function (cssStyleSheet) {
    var rules = cssStyleSheet.cssRules || cssStyleSheet.rules;
    var cssRules = Array.from(rules, function (cssRule) {
      return cssRule.cssText;
    });
    var styleSheet = {
      cssRules: cssRules,
      disabled: cssStyleSheet.disabled || undefined,
      media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : undefined
    };
    return styleSheet;
  });
}
//# sourceMappingURL=serializeStyleSheets.js.map

/***/ }),

/***/ 854610:
/*!**************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/shadowRootsController.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initShadowRootsController": () => (/* binding */ initShadowRootsController)
/* harmony export */ });
/* harmony import */ var _observers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observers */ 667412);

var initShadowRootsController = function (configuration, _a) {
  var mutationCb = _a.mutationCb,
    inputCb = _a.inputCb;
  var controllerByShadowRoot = new Map();
  var shadowRootsController = {
    addShadowRoot: function (shadowRoot) {
      var _a = (0,_observers__WEBPACK_IMPORTED_MODULE_0__.initMutationObserver)(mutationCb, configuration, shadowRootsController, shadowRoot),
        stopMutationObserver = _a.stop,
        flush = _a.flush;
      // the change event no do bubble up across the shadow root, we have to listen on the shadow root
      var stopInputObserver = (0,_observers__WEBPACK_IMPORTED_MODULE_0__.initInputObserver)(inputCb, configuration.defaultPrivacyLevel, {
        target: shadowRoot,
        domEvents: ["change" /* DOM_EVENT.CHANGE */]
      });

      controllerByShadowRoot.set(shadowRoot, {
        flush: flush,
        stop: function () {
          stopMutationObserver();
          stopInputObserver();
        }
      });
    },
    removeShadowRoot: function (shadowRoot) {
      var entry = controllerByShadowRoot.get(shadowRoot);
      if (!entry) {
        // unidentified root cause: observed in some cases with shadow DOM added by browser extensions
        return;
      }
      entry.stop();
      controllerByShadowRoot.delete(shadowRoot);
    },
    stop: function () {
      controllerByShadowRoot.forEach(function (_a) {
        var stop = _a.stop;
        return stop();
      });
    },
    flush: function () {
      controllerByShadowRoot.forEach(function (_a) {
        var flush = _a.flush;
        return flush();
      });
    }
  };
  return shadowRootsController;
};
//# sourceMappingURL=shadowRootsController.js.map

/***/ }),

/***/ 807602:
/*!**************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/record/viewports.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertMouseEventToLayoutCoordinates": () => (/* binding */ convertMouseEventToLayoutCoordinates),
/* harmony export */   "getScrollX": () => (/* binding */ getScrollX),
/* harmony export */   "getScrollY": () => (/* binding */ getScrollY),
/* harmony export */   "getVisualViewport": () => (/* binding */ getVisualViewport)
/* harmony export */ });
/**
 * Browsers have not standardized various dimension properties. Mobile devices typically report
 * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,
 * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.
 *
 * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.
 * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize
 * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout
 * viewport is being measured by the browser
 */
// Scrollbar widths vary across properties on different devices and browsers
var TOLERANCE = 25;
/**
 * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport
 * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.
 * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.
 */
function isVisualViewportFactoredIn(visualViewport) {
  return Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE || Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE;
}
var convertMouseEventToLayoutCoordinates = function (clientX, clientY) {
  var visualViewport = window.visualViewport;
  var normalized = {
    layoutViewportX: clientX,
    layoutViewportY: clientY,
    visualViewportX: clientX,
    visualViewportY: clientY
  };
  if (!visualViewport) {
    // On old browsers, we cannot normalize, so fallback to clientX/Y
    return normalized;
  } else if (isVisualViewportFactoredIn(visualViewport)) {
    // Typically Mobile Devices
    normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft);
    normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop);
  } else {
    // Typically Desktop Devices
    normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft);
    normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop);
  }
  return normalized;
};
var getVisualViewport = function (visualViewport) {
  return {
    scale: visualViewport.scale,
    offsetLeft: visualViewport.offsetLeft,
    offsetTop: visualViewport.offsetTop,
    pageLeft: visualViewport.pageLeft,
    pageTop: visualViewport.pageTop,
    height: visualViewport.height,
    width: visualViewport.width
  };
};
function getScrollX() {
  var scrollX;
  var visual = window.visualViewport;
  if (visual) {
    scrollX = visual.pageLeft - visual.offsetLeft;
  } else if (window.scrollX !== undefined) {
    scrollX = window.scrollX;
  } else {
    scrollX = window.pageXOffset || 0;
  }
  return Math.round(scrollX);
}
function getScrollY() {
  var scrollY;
  var visual = window.visualViewport;
  if (visual) {
    scrollY = visual.pageTop - visual.offsetTop;
  } else if (window.scrollY !== undefined) {
    scrollY = window.scrollY;
  } else {
    scrollY = window.pageYOffset || 0;
  }
  return Math.round(scrollY);
}
//# sourceMappingURL=viewports.js.map

/***/ }),

/***/ 157818:
/*!*********************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/replayStats.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MAX_STATS_HISTORY": () => (/* binding */ MAX_STATS_HISTORY),
/* harmony export */   "addRecord": () => (/* binding */ addRecord),
/* harmony export */   "addSegment": () => (/* binding */ addSegment),
/* harmony export */   "addWroteData": () => (/* binding */ addWroteData),
/* harmony export */   "getReplayStats": () => (/* binding */ getReplayStats),
/* harmony export */   "getSegmentsCount": () => (/* binding */ getSegmentsCount),
/* harmony export */   "resetReplayStats": () => (/* binding */ resetReplayStats)
/* harmony export */ });
var MAX_STATS_HISTORY = 10;
var statsPerView;
function getSegmentsCount(viewId) {
  return getOrCreateReplayStats(viewId).segments_count;
}
function addSegment(viewId) {
  getOrCreateReplayStats(viewId).segments_count += 1;
}
function addRecord(viewId) {
  getOrCreateReplayStats(viewId).records_count += 1;
}
function addWroteData(viewId, additionalBytesCount) {
  getOrCreateReplayStats(viewId).segments_total_raw_size += additionalBytesCount;
}
function getReplayStats(viewId) {
  return statsPerView === null || statsPerView === void 0 ? void 0 : statsPerView.get(viewId);
}
function resetReplayStats() {
  statsPerView = undefined;
}
function getOrCreateReplayStats(viewId) {
  if (!statsPerView) {
    statsPerView = new Map();
  }
  var replayStats;
  if (statsPerView.has(viewId)) {
    replayStats = statsPerView.get(viewId);
  } else {
    replayStats = {
      records_count: 0,
      segments_count: 0,
      segments_total_raw_size: 0
    };
    statsPerView.set(viewId, replayStats);
    if (statsPerView.size > MAX_STATS_HISTORY) {
      deleteOldestStats();
    }
  }
  return replayStats;
}
function deleteOldestStats() {
  if (!statsPerView) {
    return;
  }
  if (statsPerView.keys) {
    statsPerView.delete(statsPerView.keys().next().value);
  } else {
    // IE11 doesn't support map.keys
    var isFirst_1 = true;
    statsPerView.forEach(function (_value, key) {
      if (isFirst_1) {
        statsPerView.delete(key);
        isFirst_1 = false;
      }
    });
  }
}
//# sourceMappingURL=replayStats.js.map

/***/ }),

/***/ 866802:
/*!**********************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/segmentCollection/buildReplayPayload.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildReplayPayload": () => (/* binding */ buildReplayPayload),
/* harmony export */   "toFormEntries": () => (/* binding */ toFormEntries)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-core */ 777760);

function buildReplayPayload(data, metadata, rawSegmentBytesCount) {
  var formData = new FormData();
  formData.append('segment', new Blob([data], {
    type: 'application/octet-stream'
  }), "".concat(metadata.session.id, "-").concat(metadata.start));
  toFormEntries(metadata, function (key, value) {
    return formData.append(key, value);
  });
  formData.append('raw_segment_size', rawSegmentBytesCount.toString());
  return {
    data: formData,
    bytesCount: data.byteLength
  };
}
function toFormEntries(input, onEntry, prefix) {
  if (prefix === void 0) {
    prefix = '';
  }
  (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_0__.objectEntries)(input).forEach(function (_a) {
    var key = _a[0],
      value = _a[1];
    if (typeof value === 'object' && value !== null) {
      toFormEntries(value, onEntry, "".concat(prefix).concat(key, "."));
    } else {
      onEntry("".concat(prefix).concat(key), String(value));
    }
  });
}
//# sourceMappingURL=buildReplayPayload.js.map

/***/ }),

/***/ 312188:
/*!*****************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/segmentCollection/deflateWorker.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDeflateWorker": () => (/* binding */ createDeflateWorker)
/* harmony export */ });
var workerURL;
function createDeflateWorker() {
  // Lazily compute the worker URL to allow importing the SDK in NodeJS
  if (!workerURL) {
    workerURL = URL.createObjectURL(new Blob(["(".concat(workerCodeFn, ")(self)")]));
  }
  return new Worker(workerURL);
}
function workerCodeFn() {
  monitor(function () {
    var _a = makePakoDeflate(),
      Deflate = _a.Deflate,
      constants = _a.constants,
      string2buf = _a.string2buf;
    var deflate = new Deflate();
    var rawBytesCount = 0;
    self.addEventListener('message', monitor(function (event) {
      var data = event.data;
      switch (data.action) {
        case 'init':
          self.postMessage({
            type: 'initialized'
          });
          break;
        case 'write':
          {
            var additionalBytesCount = pushData(data.data);
            self.postMessage({
              type: 'wrote',
              id: data.id,
              compressedBytesCount: deflate.chunks.reduce(function (total, chunk) {
                return total + chunk.length;
              }, 0),
              additionalBytesCount: additionalBytesCount
            });
            break;
          }
        case 'flush':
          {
            var additionalBytesCount = data.data ? pushData(data.data) : 0;
            deflate.push('', constants.Z_FINISH);
            self.postMessage({
              type: 'flushed',
              id: data.id,
              result: deflate.result,
              additionalBytesCount: additionalBytesCount,
              rawBytesCount: rawBytesCount
            });
            deflate = new Deflate();
            rawBytesCount = 0;
            break;
          }
      }
    }));
    function pushData(data) {
      // TextEncoder is not supported on old browser version like Edge 18, therefore we use string2buf
      var binaryData = string2buf(data);
      deflate.push(binaryData, constants.Z_SYNC_FLUSH);
      rawBytesCount += binaryData.length;
      return binaryData.length;
    }
  })();
  function monitor(fn) {
    return function () {
      try {
        return fn.apply(this, arguments);
      } catch (e) {
        try {
          self.postMessage({
            type: 'errored',
            error: e
          });
        } catch (_) {
          // DATA_CLONE_ERR, cf https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm
          self.postMessage({
            type: 'errored',
            error: "".concat(e)
          });
        }
      }
    };
  }
  // https://github.com/nodeca/pako/blob/034669ba0f1a4c0590e45f7c2820128200f972b3/dist/pako_deflate.es5.js
  function makePakoDeflate() {
    /* eslint-disable camelcase, no-bitwise */
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.
    /* Public constants ========================================================== */
    /* =========================================================================== */
    // const Z_FILTERED          = 1;
    // const Z_HUFFMAN_ONLY      = 2;
    // const Z_RLE               = 3;
    var Z_FIXED = 4; // const Z_DEFAULT_STRATEGY  = 0;
    /* Possible values of the data_type field (though see inflate()) */
    var Z_BINARY = 0;
    var Z_TEXT = 1; // const Z_ASCII             = 1; // = Z_TEXT
    var Z_UNKNOWN = 2;
    /* ============================================================================ */
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    } // From zutil.h
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    /* The three kinds of block type */
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    /* The minimum and maximum match lengths */
    // From deflate.h
    /* ===========================================================================
     * Internal compression state.
     */
    var LENGTH_CODES = 29;
    /* number of length codes, not counting the special END_BLOCK code */
    var LITERALS = 256;
    /* number of literal bytes 0..255 */
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    /* number of Literal or Length codes, including the END_BLOCK code */
    var D_CODES = 30;
    /* number of distance codes */
    var BL_CODES = 19;
    /* number of codes used to transfer the bit lengths */
    var HEAP_SIZE = 2 * L_CODES + 1;
    /* maximum heap size */
    var MAX_BITS = 15;
    /* All codes must not exceed MAX_BITS bits */
    var Buf_size = 16;
    /* size of bit buffer in bi_buf */
    /* ===========================================================================
     * Constants
     */
    var MAX_BL_BITS = 7;
    /* Bit length codes must not exceed MAX_BL_BITS bits */
    var END_BLOCK = 256;
    /* end of block literal code */
    var REP_3_6 = 16;
    /* repeat previous bit length 3-6 times (2 bits of repeat count) */
    var REPZ_3_10 = 17;
    /* repeat a zero length 3-10 times  (3 bits of repeat count) */
    var REPZ_11_138 = 18;
    /* repeat a zero length 11-138 times  (7 bits of repeat count) */
    var extra_lbits = /* extra bits for each length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
    var extra_dbits = /* extra bits for each distance code */
    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    var extra_blbits = /* extra bits for each bit length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    /* eslint-enable comma-spacing,array-bracket-spacing */
    /* The lengths of the bit length codes are sent in order of decreasing
     * probability, to avoid transmitting the lengths for unused bit length codes.
     */
    /* ===========================================================================
     * Local data. These are initialized only once.
     */
    // We pre-fill arrays with 0 to avoid uninitialized gaps
    var DIST_CODE_LEN = 512;
    /* see definition of array dist_code below */
    // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    /* The static literal tree. Since the bit lengths are imposed, there is no
     * need for the L_CODES extra codes used during heap construction. However
     * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
     * below).
     */
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    /* The static distance tree. (Actually a trivial tree since all codes use
     * 5 bits.)
     */
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    /* Distance codes. The first 256 values correspond to the distances
     * 3 .. 258, the last 256 values correspond to the top 8 bits of
     * the 15 bit distances.
     */
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    /* length code for each normalized match length (0 == MIN_MATCH) */
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    /* First normalized length for each code (0 = MIN_MATCH) */
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    /* First normalized distance for each code (0 = distance of 1) */
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      /* static tree or NULL */
      this.extra_bits = extra_bits;
      /* extra bits for each code or NULL */
      this.extra_base = extra_base;
      /* base index for extra_bits */
      this.elems = elems;
      /* max number of elements in the tree */
      this.max_length = max_length;
      /* max bit length for the codes */
      // show if `static_tree` has data or dummy - needed for monomorphic objects
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      /* the dynamic tree */
      this.max_code = 0;
      /* largest code with non zero frequency */
      this.stat_desc = stat_desc;
      /* the corresponding static tree */
    }

    var d_code = function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    /* ===========================================================================
     * Output a short LSB first on the stream.
     * IN assertion: there is enough room in pendingBuf.
     */
    var put_short = function put_short(s, w) {
      //    put_byte(s, (uch)((w) & 0xff));
      //    put_byte(s, (uch)((ush)(w) >> 8));
      s.pending_buf[s.pending++] = w & 0xff;
      s.pending_buf[s.pending++] = w >>> 8 & 0xff;
    };
    /* ===========================================================================
     * Send a value on a given number of bits.
     * IN assertion: length <= 16 and value fits in length bits.
     */
    var send_bits = function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        s.bi_valid += length;
      }
    };
    var send_code = function send_code(s, c, tree) {
      send_bits(s, tree[c * 2], /* .Code */
      tree[c * 2 + 1]
      /* .Len */);
    };
    /* ===========================================================================
     * Reverse the first len bits of a code, using straightforward code (a faster
     * method would use a table)
     * IN assertion: 1 <= len <= 15
     */
    var bi_reverse = function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    /* ===========================================================================
     * Flush the bit buffer, keeping at most 7 bits in it.
     */
    var bi_flush = function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    /* ===========================================================================
     * Compute the optimal bit lengths for a tree and update the total bit length
     * for the current block.
     * IN assertion: the fields freq and dad are set, heap[heap_max] and
     *    above are the tree nodes sorted by increasing frequency.
     * OUT assertions: the field len is set to the optimal bit length, the
     *     array bl_count contains the frequencies for each bit length.
     *     The length opt_len is updated; static_len is also updated if stree is
     *     not null.
     */
    var gen_bitlen = function gen_bitlen(s, desc //    deflate_state *s; //    tree_desc *desc;    /* the tree descriptor */
    ) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      /* heap index */
      var n;
      var m;
      /* iterate over the tree elements */
      var bits;
      /* bit length */
      var xbits;
      /* extra bits */
      var f;
      /* frequency */
      var overflow = 0;
      /* number of elements with bit length too large */
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      /* In a first pass, compute the optimal bit lengths (which may
       * overflow in the case of the bit length tree).
       */
      tree[s.heap[s.heap_max] * 2 + 1] = /* .Len */
      0;
      /* root of the heap */
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * /* .Dad */
        2 + 1] + /* .Len */
        1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = /* .Len */
        bits;
        /* We overwrite tree[n].Dad which is no longer needed */
        if (n > max_code) {
          continue;
        }
        /* not a leaf node */
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        /* .Freq */
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + /* .Len */
          xbits);
        }
      }
      if (overflow === 0) {
        return;
      } // Trace((stderr,"\nbit length overflow\n"));
      /* This happens for example on obj2 and pic of the Calgary corpus */
      /* Find the first bit length which could increase: */
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        /* move one leaf down the tree */
        s.bl_count[bits + 1] += 2;
        /* move one overflow item as its brother */
        s.bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
      } while (overflow > 0);
      /* Now recompute all bit lengths, scanning in increasing frequency.
       * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
       * lengths instead of fixing only the wrong ones. This idea is taken
       * from 'ar' written by Haruhiko Okumura.)
       */
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== /* .Len */
          bits) {
            // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
            s.opt_len += (bits - tree[m * 2 + 1]) * /* .Len */
            tree[m * 2];
            /* .Freq */
            tree[m * 2 + 1] = /* .Len */
            bits;
          }
          n--;
        }
      }
    };
    /* ===========================================================================
     * Generate the codes for a given tree and bit counts (which need not be
     * optimal).
     * IN assertion: the array bl_count contains the bit length statistics for
     * the given tree and the field len is set for all tree elements.
     * OUT assertion: the field code is set for all tree elements of non
     *     zero code length.
     */
    var gen_codes = function gen_codes(tree, max_code, bl_count
    //    ct_data *tree;             /* the tree to decorate */
    //    int max_code;              /* largest code with non zero frequency */
    //    ushf *bl_count;            /* number of codes at each bit length */
    ) {
      var next_code = new Array(MAX_BITS + 1);
      /* next code value for each bit length */
      var code = 0;
      /* running code value */
      var bits;
      /* bit index */
      var n;
      /* code index */
      /* The distribution counts are first used to generate the code values
       * without bit reversal.
       */
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      /* Check that the bit counts in bl_count are consistent. The last code
       * must be all ones.
       */
      // Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
      //        "inconsistent bit counts");
      // Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        /* .Len */
        if (len === 0) {
          continue;
        }
        /* Now reverse the bits */
        tree[n * 2] = /* .Code */
        bi_reverse(next_code[len]++, len); // Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
        //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
      }
    };
    /* ===========================================================================
     * Initialize the various 'constant' tables.
     */
    var tr_static_init = function tr_static_init() {
      var n;
      /* iterates over tree elements */
      var bits;
      /* bit counter */
      var length;
      /* length value */
      var code;
      /* code value */
      var dist;
      /* distance index */
      var bl_count = new Array(MAX_BITS + 1);
      /* number of codes at each bit length for an optimal tree */
      // do check in _tr_init()
      // if (static_init_done) return;
      /* For some embedded targets, global variables are not initialized: */
      /* #ifdef NO_INIT_GLOBAL_POINTERS
      static_l_desc.static_tree = static_ltree;
      static_l_desc.extra_bits = extra_lbits;
      static_d_desc.static_tree = static_dtree;
      static_d_desc.extra_bits = extra_dbits;
      static_bl_desc.extra_bits = extra_blbits;
      #endif */
      /* Initialize the mapping length (0..255) -> length code (0..28) */
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      } // Assert (length == 256, "tr_static_init: length != 256");
      /* Note that the length 255 (match length 258) can be represented
       * in two different ways: code 284 + 5 bits or code 285, so we
       * overwrite length_code[255] to use the best encoding:
       */
      _length_code[length - 1] = code;
      /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      } // Assert (dist == 256, "tr_static_init: dist != 256");
      dist >>= 7;
      /* from now on, all distances are divided by 128 */
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      } // Assert (dist == 256, "tr_static_init: 256+dist != 512");
      /* Construct the codes of the static literal tree */
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = /* .Len */
        8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = /* .Len */
        9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = /* .Len */
        7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = /* .Len */
        8;
        n++;
        bl_count[8]++;
      }
      /* Codes 286 and 287 do not exist, but we must include them in the
       * tree construction to get a canonical Huffman tree (longest code
       * all ones)
       */
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      /* The static distance tree is trivial: */
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = /* .Len */
        5;
        static_dtree[n * 2] = /* .Code */
        bi_reverse(n, 5);
      } // Now data ready and we can init static trees
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
      // static_init_done = true;
    };
    /* ===========================================================================
     * Initialize a new block.
     */
    var init_block = function init_block(s) {
      var n;
      /* iterates over tree elements */
      /* Initialize the trees. */
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = /* .Freq */
        0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = /* .Freq */
        0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = /* .Freq */
        0;
      }
      s.dyn_ltree[END_BLOCK * 2] = /* .Freq */
      1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    };
    /* ===========================================================================
     * Flush the bit buffer and align the output on a byte boundary
     */
    var bi_windup = function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        // put_byte(s, (Byte)s->bi_buf);
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    /* ===========================================================================
     * Copy a stored block, storing first the length and its
     * one's complement if requested.
     */
    var copy_block = function copy_block(s, buf, len, header
    // DeflateState *s;
    // charf    *buf;    /* the input data */
    // unsigned len;     /* its length */
    // int      header;  /* true if block header must be written */
    ) {
      bi_windup(s);
      /* align on byte boundary */
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      //  while (len--) {
      //    put_byte(s, *buf++);
      //  }
      s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
      s.pending += len;
    };
    /* ===========================================================================
     * Compares to subtrees, using the tree depth as tie breaker when
     * the subtrees have equal frequency. This minimizes the worst case length.
     */
    var smaller = function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < /* .Freq */
      tree[_m2] || /* .Freq */
      tree[_n2] === /* .Freq */
      tree[_m2] && /* .Freq */
      depth[n] <= depth[m];
    };
    /* ===========================================================================
     * Restore the heap property by moving down the tree starting at node k,
     * exchanging a node with the smallest of its two sons if necessary, stopping
     * when the heap property is re-established (each father smaller than its
     * two sons).
     */
    var pqdownheap = function pqdownheap(s, tree, k
    //    deflate_state *s;
    //    ct_data *tree;  /* the tree to restore */
    //    int k;               /* node to move down */
    ) {
      var v = s.heap[k];
      var j = k << 1;
      /* left son of k */
      while (j <= s.heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        /* Exchange v with the smallest son */
        s.heap[k] = s.heap[j];
        k = j;
        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
      }
      s.heap[k] = v;
    }; // inlined manually
    // const SMALLEST = 1;
    /* ===========================================================================
     * Send the block data compressed using the given Huffman trees
     */
    var compress_block = function compress_block(s, ltree, dtree
    //    deflate_state *s;
    //    const ct_data *ltree; /* literal tree */
    //    const ct_data *dtree; /* distance tree */
    ) {
      var dist;
      /* distance of matched string */
      var lc;
      /* match length or unmatched char (if dist == 0) */
      var lx = 0;
      /* running index in l_buf */
      var code;
      /* the code to send */
      var extra;
      /* number of extra bits to send */
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
            /* send a literal byte */
            // Tracecv(isgraph(lc), (stderr," '%c' ", lc));
          } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            /* send the length code */
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
              /* send the extra length bits */
            }

            dist--;
            /* dist is now the match distance - 1 */
            code = d_code(dist); // Assert (code < D_CODES, "bad d_code");
            send_code(s, code, dtree);
            /* send the distance code */
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
              /* send the extra distance bits */
            }
          }
          /* literal or match pair ? */
          /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
          // Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
          //       "pendingBuf overflow");
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    };
    /* ===========================================================================
     * Construct one Huffman tree and assigns the code bit strings and lengths.
     * Update the total bit length for the current block.
     * IN assertion: the field freq is set for all tree elements.
     * OUT assertions: the fields len and code are set to the optimal bit length
     *     and corresponding code. The length opt_len is updated; static_len is
     *     also updated if stree is not null. The field max_code is set.
     */
    var build_tree = function build_tree(s, desc //    deflate_state *s; //    tree_desc *desc; /* the tree descriptor */
    ) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n;
      var m;
      /* iterate over heap elements */
      var max_code = -1;
      /* largest code with non zero frequency */
      var node;
      /* new node being created */
      /* Construct the initial heap, with least frequent element in
       * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
       * heap[0] is not used.
       */
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== /* .Freq */
        0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = /* .Len */
          0;
        }
      }
      /* The pkzip format requires that at least one distance code exists,
       * and that at least one bit should be sent even if there is only one
       * possible code. So to avoid special checks later on we force at least
       * two codes of non zero frequency.
       */
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = /* .Freq */
        1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
          /* .Len */
        }
        /* node is 0 or 1 so it does not have extra bits */
      }

      desc.max_code = max_code;
      /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
       * establish sub-heaps of increasing lengths:
       */
      for (n = s.heap_len >> 1; /* int /2 */
      n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      /* Construct the Huffman tree by repeatedly combining the least two
       * frequent nodes.
       */
      node = elems;
      /* next internal node of the tree */
      do {
        // pqremove(s, tree, n);  /* n = node of least frequency */
        /** * pqremove ** */
        n = s.heap[1];
        /* SMALLEST */
        s.heap[1] = s.heap[s.heap_len--];
        /* SMALLEST */
        pqdownheap(s, tree, 1
        /* SMALLEST */);
        /***/
        m = s.heap[1];
        /* SMALLEST */
        /* m = node of next least frequency */
        s.heap[--s.heap_max] = n;
        /* keep the nodes sorted by frequency */
        s.heap[--s.heap_max] = m;
        /* Create a new node father of n and m */
        tree[node * 2] = /* .Freq */
        tree[n * 2] + /* .Freq */
        tree[m * 2];
        /* .Freq */
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = /* .Dad */
        tree[m * 2 + 1] = /* .Dad */
        node;
        /* and insert the new node in the heap */
        s.heap[1] = node++;
        /* SMALLEST */
        pqdownheap(s, tree, 1
        /* SMALLEST */);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      /* SMALLEST */
      /* At this point, the fields freq and dad are set. We can now
       * generate the bit lengths.
       */
      gen_bitlen(s, desc);
      /* The field len is now set, we can generate the bit codes */
      gen_codes(tree, max_code, s.bl_count);
    };
    /* ===========================================================================
     * Scan a literal or distance tree to determine the frequencies of the codes
     * in the bit length tree.
     */
    var scan_tree = function scan_tree(s, tree, max_code
    //    deflate_state *s;
    //    ct_data *tree;   /* the tree to be scanned */
    //    int max_code;    /* and its largest code of non zero frequency */
    ) {
      var n;
      /* iterates over all tree elements */
      var prevlen = -1;
      /* last emitted length */
      var curlen;
      /* length of current code */
      var nextlen = tree[0 * 2 + 1];
      /* .Len */
      /* length of next code */
      var count = 0;
      /* repeat count of the current code */
      var max_count = 7;
      /* max repeat count */
      var min_count = 4;
      /* min repeat count */
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = /* .Len */
      0xffff;
      /* guard */
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        /* .Len */
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += /* .Freq */
          count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2] /* .Freq */++;
          }

          s.bl_tree[REP_3_6 * 2] /* .Freq */++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2] /* .Freq */++;
        } else {
          s.bl_tree[REPZ_11_138 * 2] /* .Freq */++;
        }

        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    /* ===========================================================================
     * Send a literal or distance tree in compressed form, using the codes in
     * bl_tree.
     */
    var send_tree = function send_tree(s, tree, max_code
    //    deflate_state *s;
    //    ct_data *tree; /* the tree to be scanned */
    //    int max_code;       /* and its largest code of non zero frequency */
    ) {
      var n;
      /* iterates over all tree elements */
      var prevlen = -1;
      /* last emitted length */
      var curlen;
      /* length of current code */
      var nextlen = tree[0 * 2 + 1];
      /* .Len */
      /* length of next code */
      var count = 0;
      /* repeat count of the current code */
      var max_count = 7;
      /* max repeat count */
      var min_count = 4;
      /* min repeat count */
      /* tree[max_code+1].Len = -1; */
      /* guard already set */
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        /* .Len */
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          } // Assert(count >= 3 && count <= 6, " 3_6?");
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    /* ===========================================================================
     * Construct the Huffman tree for the bit lengths and return the index in
     * bl_order of the last bit length code to send.
     */
    var build_bl_tree = function build_bl_tree(s) {
      var max_blindex;
      /* index of last bit length code of non zero freq */
      /* Determine the bit length frequencies for literal and distance trees */
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      /* Build the bit length tree: */
      build_tree(s, s.bl_desc);
      /* opt_len now includes the length of the tree representations, except
       * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
       */
      /* Determine the number of bit length codes to send. The pkzip format
       * requires that at least 4 bit length codes be sent. (appnote.txt says
       * 3 but the actual value used is 4.)
       */
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== /* .Len */
        0) {
          break;
        }
      }
      /* Update opt_len to include the bit length tree and counts */
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; // Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
      //        s->opt_len, s->static_len));
      return max_blindex;
    };
    /* ===========================================================================
     * Send the header for a block using dynamic Huffman trees: the counts, the
     * lengths of the bit length codes, the literal tree and the distance tree.
     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
     */
    var send_all_trees = function send_all_trees(s, lcodes, dcodes, blcodes //    deflate_state *s; //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
    ) {
      var rank;
      /* index in bl_order */
      // Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
      // Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
      //        "too many codes");
      // Tracev((stderr, "\nbl counts: "));
      send_bits(s, lcodes - 257, 5);
      /* not +255 as stated in appnote.txt */
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      /* not -3 as stated in appnote.txt */
      for (rank = 0; rank < blcodes; rank++) {
        // Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], /* .Len */
        3);
      } // Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
      send_tree(s, s.dyn_ltree, lcodes - 1);
      /* literal tree */
      // Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
      send_tree(s, s.dyn_dtree, dcodes - 1);
      /* distance tree */
      // Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
    };
    /* ===========================================================================
     * Check if the data type is TEXT or BINARY, using the following algorithm:
     * - TEXT if the two conditions below are satisfied:
     *    a) There are no non-portable control characters belonging to the
     *       "black list" (0..6, 14..25, 28..31).
     *    b) There is at least one printable character belonging to the
     *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
     * - BINARY otherwise.
     * - The following partially-portable control characters form a
     *   "gray list" that is ignored in this detection algorithm:
     *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
     * IN assertion: the fields Freq of dyn_ltree are set.
     */
    var detect_data_type = function detect_data_type(s) {
      /* black_mask is the bit mask of black-listed bytes
       * set bits 0..6, 14..25, and 28..31
       * 0xf3ffc07f = binary 11110011111111111100000001111111
       */
      var black_mask = 0xf3ffc07f;
      var n;
      /* Check for non-textual ("black-listed") bytes. */
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== /* .Freq */
        0) {
          return Z_BINARY;
        }
      }
      /* Check for textual ("white-listed") bytes. */
      if (s.dyn_ltree[9 * 2] !== /* .Freq */
      0 || s.dyn_ltree[10 * 2] !== /* .Freq */
      0 || s.dyn_ltree[13 * 2] !== /* .Freq */
      0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== /* .Freq */
        0) {
          return Z_TEXT;
        }
      }
      /* There are no "black-listed" or "white-listed" bytes:
       * this stream either is empty or has tolerated ("gray-listed") bytes only.
       */
      return Z_BINARY;
    };
    var static_init_done = false;
    /* ===========================================================================
     * Initialize the tree data structures for a new zlib stream.
     */
    var _tr_init = function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      /* Initialize the first block of the first file: */
      init_block(s);
    };
    /* ===========================================================================
     * Send a stored block
     */
    var _tr_stored_block = function _tr_stored_block(s, buf, stored_len, last
    // DeflateState *s;
    // charf *buf;       /* input block */
    // ulg stored_len;   /* length of input block */
    // int last;         /* one if this is the last block for a file */
    ) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      /* send block type */
      copy_block(s, buf, stored_len, true);
      /* with header */
    };
    /* ===========================================================================
     * Send one empty static block to give enough lookahead for inflate.
     * This takes 10 bits, of which 7 may remain in the bit buffer.
     */
    var _tr_align = function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    /* ===========================================================================
     * Determine the best encoding for the current block: dynamic trees, static
     * trees or store, and output the encoded block to the zip file.
     */
    var _tr_flush_block = function _tr_flush_block(s, buf, stored_len, last
    // DeflateState *s;
    // charf *buf;       /* input block, or NULL if too old */
    // ulg stored_len;   /* length of input block */
    // int last;         /* one if this is the last block for a file */
    ) {
      var opt_lenb;
      var static_lenb;
      /* opt_len and static_len in bytes */
      var max_blindex = 0;
      /* index of last bit length code of non zero freq */
      /* Build the Huffman trees unless a stored block is forced */
      if (s.level > 0) {
        /* Check if the file is binary or text */
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        /* Construct the literal and distance trees */
        build_tree(s, s.l_desc); // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
        //        s->static_len));
        build_tree(s, s.d_desc); // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
        //        s->static_len));
        /* At this point, opt_len and static_len are the total bit lengths of
         * the compressed block data, excluding the tree representations.
         */
        /* Build the bit length tree for the above two trees, and get the index
         * in bl_order of the last bit length code to send.
         */
        max_blindex = build_bl_tree(s);
        /* Determine the best encoding. Compute the block lengths in bytes. */
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
        //        s->last_lit));
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        // Assert(buf != (char*)0, "lost buf");
        opt_lenb = static_lenb = stored_len + 5;
        /* force a stored block */
      }

      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        /* 4: two words for the lengths */
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      } // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
      /* The above check is made mod 2^32, for files larger than 512 MB
       * and uLong implemented on 32 bits.
       */
      init_block(s);
      if (last) {
        bi_windup(s);
      } // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
      //       s->compressed_len-7*last));
    };
    /* ===========================================================================
     * Save the match info and tally the frequency counts. Return true if
     * the current block must be flushed.
     */
    var _tr_tally = function _tr_tally(s, dist, lc
    //    deflate_state *s;
    //    unsigned dist;  /* distance of matched string */
    //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
    ) {
      // let out_length, in_length, dcode;
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
      s.last_lit++;
      if (dist === 0) {
        /* lc is the unmatched char */
        s.dyn_ltree[lc * 2] /* .Freq */++;
      } else {
        s.matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;
        /* dist = match distance - 1 */
        // Assert((ush)dist < (ush)MAX_DIST(s) &&
        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
        //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /* .Freq */++;
        s.dyn_dtree[d_code(dist) * 2] /* .Freq */++;
      } // (!) This block is disabled in zlib defaults,
      // don't enable it for binary compatibility
      // #ifdef TRUNCATE_BLOCK
      //  /* Try to guess if it is profitable to stop the current block here */
      //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
      //    /* Compute an upper bound for the compressed length */
      //    out_length = s.last_lit*8;
      //    in_length = s.strstart - s.block_start;
      //
      //    for (dcode = 0; dcode < D_CODES; dcode++) {
      //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
      //    }
      //    out_length >>>= 3;
      //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
      //    //       s->last_lit, in_length, out_length,
      //    //       100L - out_length*100L/in_length));
      //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
      //      return true;
      //    }
      //  }
      // #endif
      return s.last_lit === s.lit_bufsize - 1;
      /* We avoid equality with lit_bufsize because of wraparound at 64K
       * on 16 bit machines and because stored blocks are restricted to
       * 64K-1 bytes.
       */
    };

    var _tr_init_1 = _tr_init;
    var _tr_stored_block_1 = _tr_stored_block;
    var _tr_flush_block_1 = _tr_flush_block;
    var _tr_tally_1 = _tr_tally;
    var _tr_align_1 = _tr_align;
    var trees = {
      _tr_init: _tr_init_1,
      _tr_stored_block: _tr_stored_block_1,
      _tr_flush_block: _tr_flush_block_1,
      _tr_tally: _tr_tally_1,
      _tr_align: _tr_align_1
    };
    // It isn't worth it to make additional optimizations as in original.
    // Small size is preferable.
    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.
    var adler32 = function adler32(adler, buf, len, pos) {
      var s1 = adler & 0xffff | 0;
      var s2 = adler >>> 16 & 0xffff | 0;
      var n = 0;
      while (len !== 0) {
        // Set limit ~ twice less than 5552, to keep
        // s2 in 31-bits, because we force signed ints.
        // in other case %= will fail.
        n = len > 2000 ? 2000 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    var adler32_1 = adler32;
    // So write code to minimize size - no pregenerated tables
    // and array tools dependencies.
    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.
    // Use ordinary array, since untyped makes no boost here
    var makeTable = function makeTable() {
      var c;
      var table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }; // Create table on load. Just 255 signed longs. Not a problem.
    var crcTable = new Uint32Array(makeTable());
    var crc32 = function crc32(crc, buf, len, pos) {
      var t = crcTable;
      var end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xff];
      }
      return crc ^ -1; // >>> 0;
    };

    var crc32_1 = crc32;
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.
    var messages = {
      2: 'need dictionary',
      /* Z_NEED_DICT       2  */
      1: 'stream end',
      /* Z_STREAM_END      1  */
      0: '',
      /* Z_OK              0  */
      '-1': 'file error',
      /* Z_ERRNO         (-1) */
      '-2': 'stream error',
      /* Z_STREAM_ERROR  (-2) */
      '-3': 'data error',
      /* Z_DATA_ERROR    (-3) */
      '-4': 'insufficient memory',
      /* Z_MEM_ERROR     (-4) */
      '-5': 'buffer error',
      /* Z_BUF_ERROR     (-5) */
      '-6': 'incompatible version'
      /* Z_VERSION_ERROR (-6) */
    };
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.
    var constants = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
       * are errors, positive values are used for special but normal events.
       */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      // Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      // Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8 // Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.
    var _tr_init$1 = trees._tr_init;
    var _tr_stored_block$1 = trees._tr_stored_block;
    var _tr_flush_block$1 = trees._tr_flush_block;
    var _tr_tally$1 = trees._tr_tally;
    var _tr_align$1 = trees._tr_align;
    /* Public constants ========================================================== */
    /* =========================================================================== */
    var Z_NO_FLUSH = constants.Z_NO_FLUSH;
    var Z_PARTIAL_FLUSH = constants.Z_PARTIAL_FLUSH;
    var Z_FULL_FLUSH = constants.Z_FULL_FLUSH;
    var Z_FINISH = constants.Z_FINISH;
    var Z_BLOCK = constants.Z_BLOCK;
    var Z_OK = constants.Z_OK;
    var Z_STREAM_END = constants.Z_STREAM_END;
    var Z_STREAM_ERROR = constants.Z_STREAM_ERROR;
    var Z_DATA_ERROR = constants.Z_DATA_ERROR;
    var Z_BUF_ERROR = constants.Z_BUF_ERROR;
    var Z_DEFAULT_COMPRESSION = constants.Z_DEFAULT_COMPRESSION;
    var Z_FILTERED = constants.Z_FILTERED;
    var Z_HUFFMAN_ONLY = constants.Z_HUFFMAN_ONLY;
    var Z_RLE = constants.Z_RLE;
    var Z_FIXED$1 = constants.Z_FIXED;
    var Z_DEFAULT_STRATEGY = constants.Z_DEFAULT_STRATEGY;
    var Z_UNKNOWN$1 = constants.Z_UNKNOWN;
    var Z_DEFLATED = constants.Z_DEFLATED;
    /* ============================================================================ */
    var MAX_MEM_LEVEL = 9;
    /* Maximum value for memLevel in deflateInit2 */
    var MAX_WBITS = 15;
    /* 32K LZ77 window */
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES$1 = 29;
    /* number of length codes, not counting the special END_BLOCK code */
    var LITERALS$1 = 256;
    /* number of literal bytes 0..255 */
    var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
    /* number of Literal or Length codes, including the END_BLOCK code */
    var D_CODES$1 = 30;
    /* number of distance codes */
    var BL_CODES$1 = 19;
    /* number of codes used to transfer the bit lengths */
    var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
    /* maximum heap size */
    var MAX_BITS$1 = 15;
    /* All codes must not exceed MAX_BITS bits */
    var MIN_MATCH$1 = 3;
    var MAX_MATCH$1 = 258;
    var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1;
    var PRESET_DICT = 0x20;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    /* block not completed, need more input or more output */
    var BS_BLOCK_DONE = 2;
    /* block flush performed */
    var BS_FINISH_STARTED = 3;
    /* finish started, need only more output at next deflate */
    var BS_FINISH_DONE = 4;
    /* finish done, accept no more input or output */
    var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.
    var err = function err(strm, errorCode) {
      strm.msg = messages[errorCode];
      return errorCode;
    };
    var rank = function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    };
    var zero$1 = function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var HASH_ZLIB = function HASH_ZLIB(s, prev, data) {
      return (prev << s.hash_shift ^ data) & s.hash_mask;
    }; // This hash causes less collisions, https://github.com/nodeca/pako/issues/135
    // But breaks binary compatibility
    // let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
    var HASH = HASH_ZLIB;
    /* =========================================================================
     * Flush as much pending output as possible. All deflate() output goes
     * through this function so some applications may wish to modify it
     * to avoid allocating a large strm->output buffer and copying into it.
     * (See also read_buf()).
     */
    var flush_pending = function flush_pending(strm) {
      var s = strm.state; // _tr_flush_bits(s);
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    var flush_block_only = function flush_block_only(s, last) {
      _tr_flush_block$1(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    var put_byte = function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    };
    /* =========================================================================
     * Put a short in the pending buffer. The 16-bit value is put in MSB order.
     * IN assertion: the stream state is correct and there is enough room in
     * pending_buf.
     */
    var putShortMSB = function putShortMSB(s, b) {
      //  put_byte(s, (Byte)(b >> 8));
      //  put_byte(s, (Byte)(b & 0xff));
      s.pending_buf[s.pending++] = b >>> 8 & 0xff;
      s.pending_buf[s.pending++] = b & 0xff;
    };
    /* ===========================================================================
     * Read a new buffer from the current input stream, update the adler32
     * and total number of bytes read.  All deflate() input goes through
     * this function so some applications may wish to modify it to avoid
     * allocating a large strm->input buffer and copying from it.
     * (See also flush_pending()).
     */
    var read_buf = function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32_1(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32_1(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    /* ===========================================================================
     * Set match_start to the longest match starting at the given string and
     * return its length. Matches shorter or equal to prev_length are discarded,
     * in which case the result is equal to prev_length and match_start is
     * garbage.
     * IN assertions: cur_match is the head of the hash chain for the current
     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
     * OUT assertion: the match length is not greater than s->lookahead.
     */
    var longest_match = function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      /* max hash chain length */
      var scan = s.strstart;
      /* current string */
      var match;
      /* matched string */
      var len;
      /* length of current match */
      var best_len = s.prev_length;
      /* best match length so far */
      var nice_match = s.nice_match;
      /* stop if match long enough */
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      /* NIL */
      var _win = s.window; // shortcut
      var wmask = s.w_mask;
      var prev = s.prev;
      /* Stop when cur_match becomes <= limit. To simplify the code,
       * we prevent matches with the string of window index 0.
       */
      var strend = s.strstart + MAX_MATCH$1;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
       * It is easy to get rid of this optimization if necessary.
       */
      // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
      /* Do not waste too much time if we already have a good match: */
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      /* Do not look for matches beyond the end of the input. This is necessary
       * to make deflate deterministic.
       */
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
      do {
        // Assert(cur_match < s->strstart, "no future");
        match = cur_match;
        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2.  Note that the checks below
         * for insufficient lookahead only occur occasionally for performance
         * reasons.  Therefore uninitialized memory will be accessed, and
         * conditional jumps will be made that depend on those values.
         * However the length of the match is limited to the lookahead, so
         * the output of deflate is not affected by the uninitialized values.
         */
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2;
        match++; // Assert(*scan == *match, "match[2]?");
        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
          /* jshint noempty:false */
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
        len = MAX_MATCH$1 - (strend - scan);
        scan = strend - MAX_MATCH$1;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    /* ===========================================================================
     * Fill the window when the lookahead becomes insufficient.
     * Updates strstart and lookahead.
     *
     * IN assertion: lookahead < MIN_LOOKAHEAD
     * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
     *    At least one byte has been read, or avail_in == 0; reads are
     *    performed for at least two bytes (required for the zip translate_eol
     *    option -- not supported here).
     */
    var fill_window = function fill_window(s) {
      var _w_size = s.w_size;
      var p;
      var n;
      var m;
      var more;
      var str; // Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
      do {
        more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed
        /* Deal with !@#$% 64K limit: */
        // if (sizeof(int) <= 2) {
        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
        //        more = wsize;
        //
        //  } else if (more == (unsigned)(-1)) {
        //        /* Very unlikely, but possible on 16 bit machine if
        //         * strstart == 0 && lookahead == 1 (input done a byte at time)
        //         */
        //        more--;
        //    }
        // }
        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          /* we now have strstart >= MAX_DIST */
          s.block_start -= _w_size;
          /* Slide the hash table (could be avoided with 32 bit values
          at the expense of memory usage). We slide even when level == 0
          to keep the hash table consistent if we switch back to level > 0
          later. (Using level 0 permanently is not an optimal usage of
          zlib, so we don't care about this pathological case.)
          */
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
            /* If n is not on any hash chain, prev[n] is garbage but
             * its value will never be used.
             */
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        // Assert(more >= 2, "more < 2");
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        /* Initialize the hash value now that we have some input: */
        if (s.lookahead + s.insert >= MIN_MATCH$1) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]); // #if MIN_MATCH != 3
          //        Call update_hash() MIN_MATCH-3 more times
          // #endif
          while (s.insert) {
            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH$1) {
              break;
            }
          }
        }
        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
      /* If the WIN_INIT bytes after the end of the current data have never been
       * written, then zero those bytes in order to avoid memory check reports of
       * the use of uninitialized (or uninitialised as Julian writes) bytes by
       * the longest match routines.  Update the high water mark for the next
       * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
       * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
       */
      //  if (s.high_water < s.window_size) {
      //    const curr = s.strstart + s.lookahead;
      //    let init = 0;
      //
      //    if (s.high_water < curr) {
      //      /* Previous high water mark below current data -- zero WIN_INIT
      //       * bytes or up to end of window, whichever is less.
      //       */
      //      init = s.window_size - curr;
      //      if (init > WIN_INIT)
      //        init = WIN_INIT;
      //      zmemzero(s->window + curr, (unsigned)init);
      //      s->high_water = curr + init;
      //    }
      //    else if (s->high_water < (ulg)curr + WIN_INIT) {
      //      /* High water mark at or above current data, but below current data
      //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
      //       * to end of window, whichever is less.
      //       */
      //      init = (ulg)curr + WIN_INIT - s->high_water;
      //      if (init > s->window_size - s->high_water)
      //        init = s->window_size - s->high_water;
      //      zmemzero(s->window + s->high_water, (unsigned)init);
      //      s->high_water += init;
      //    }
      //  }
      //
      //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
      //    "not enough room for search");
    };
    /* ===========================================================================
     * Copy without compression as much as possible from the input stream, return
     * the current block state.
     * This function does not insert new strings in the dictionary since
     * uncompressible data is probably not useful. This function is used
     * only for the level=0 compression option.
     * NOTE: this function should be optimized to avoid extra copying from
     * window to pending_buf.
     */
    var deflate_stored = function deflate_stored(s, flush) {
      /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
       * to pending_buf_size, and each stored block has a 5 byte header:
       */
      var max_block_size = 0xffff;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      /* Copy as much as possible from input to output: */
      for (;;) {
        /* Fill the window as much as possible: */
        if (s.lookahead <= 1) {
          // Assert(s->strstart < s->w_size+MAX_DIST(s) ||
          //  s->block_start >= (long)s->w_size, "slide too late");
          //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
          //        s.block_start >= s.w_size)) {
          //        throw  new Error("slide too late");
          //      }
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
          /* flush the current block */
        } // Assert(s->block_start >= 0L, "block gone");
        //    if (s.block_start < 0) throw new Error("block gone");
        s.strstart += s.lookahead;
        s.lookahead = 0;
        /* Emit a stored block if pending_buf will be full: */
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          /* strstart == 0 is possible when wraparound on 16-bit machine */
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          /** * FLUSH_BLOCK(s, 0); ** */
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
        /* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          /** * FLUSH_BLOCK(s, 0); ** */
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }

      s.insert = 0;
      if (flush === Z_FINISH) {
        /** * FLUSH_BLOCK(s, 1); ** */
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        /** * FLUSH_BLOCK(s, 0); ** */
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

      return BS_NEED_MORE;
    };
    /* ===========================================================================
     * Compress as much as possible from the input stream, return the current
     * block state.
     * This function does not perform lazy evaluation of matches and inserts
     * new strings in the dictionary only for unmatched strings or for short
     * matches. It is used only for the fast compression options.
     */
    var deflate_fast = function deflate_fast(s, flush) {
      var hash_head;
      /* head of the hash chain */
      var bflush;
      /* set if current block must be flushed */
      for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
            /* flush the current block */
          }
        }
        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = 0;
        /* NIL */
        if (s.lookahead >= MIN_MATCH$1) {
          /** * INSERT_STRING(s, s.strstart, hash_head); ** */
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */
        if (hash_head !== 0 && /* NIL */
        s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          /* To simplify the code, we prevent matches with the string
           * of window index 0 (in particular we have to avoid a match
           * of the string with itself at the start of the input file).
           */
          s.match_length = longest_match(s, hash_head);
          /* longest_match() sets match_start */
        }

        if (s.match_length >= MIN_MATCH$1) {
          // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only
          /** * _tr_tally_dist(s, s.strstart - s.match_start,
                       s.match_length - MIN_MATCH, bflush); ** */
          bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);
          s.lookahead -= s.match_length;
          /* Insert new strings in the hash table only if the match length
           * is not too large. This saves time but degrades compression.
           */
          if (s.match_length <= s.max_lazy_match && /* max_insert_length */
          s.lookahead >= MIN_MATCH$1) {
            s.match_length--;
            /* string at strstart already in table */
            do {
              s.strstart++;
              /** * INSERT_STRING(s, s.strstart, hash_head); ** */
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
              /***/
              /* strstart never exceeds WSIZE-MAX_MATCH, so there are
               * always MIN_MATCH bytes ahead.
               */
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]); // #if MIN_MATCH != 3
            //                Call UPDATE_HASH() MIN_MATCH-3 more times
            // #endif
            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
             * matter since it will be recomputed at next deflate call.
             */
          }
        } else {
          /* No match, output a literal byte */
          // Tracevv((stderr,"%c", s.window[s.strstart]));
          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */
          bflush = _tr_tally$1(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          /** * FLUSH_BLOCK(s, 0); ** */
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }

      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
      if (flush === Z_FINISH) {
        /** * FLUSH_BLOCK(s, 1); ** */
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /** * FLUSH_BLOCK(s, 0); ** */
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

      return BS_BLOCK_DONE;
    };
    /* ===========================================================================
     * Same as above, but achieves better compression. We use a lazy
     * evaluation for matches: a match is finally adopted only if there is
     * no better match at the next window position.
     */
    var deflate_slow = function deflate_slow(s, flush) {
      var hash_head;
      /* head of hash chain */
      var bflush;
      /* set if current block must be flushed */
      var max_insert;
      /* Process the input block. */
      for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
          /* flush the current block */
        }
        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = 0;
        /* NIL */
        if (s.lookahead >= MIN_MATCH$1) {
          /** * INSERT_STRING(s, s.strstart, hash_head); ** */
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
        /* Find the longest match, discarding those <= prev_length.
         */
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH$1 - 1;
        if (hash_head !== 0 && /* NIL */
        s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
        /* MAX_DIST(s) */) {
          /* To simplify the code, we prevent matches with the string
           * of window index 0 (in particular we have to avoid a match
           * of the string with itself at the start of the input file).
           */
          s.match_length = longest_match(s, hash_head);
          /* longest_match() sets match_start */
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096)
          /* TOO_FAR */) {
            /* If prev_match is also MIN_MATCH, match_start is garbage
             * but we will ignore the current match anyway.
             */
            s.match_length = MIN_MATCH$1 - 1;
          }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH$1;
          /* Do not insert strings in hash table beyond this. */
          // check_match(s, s.strstart-1, s.prev_match, s.prev_length);
          /** *_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                       s.prev_length - MIN_MATCH, bflush);** */
          bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);
          /* Insert in hash table all strings up to the end of the match.
           * strstart-1 and strstart are already inserted. If there is not
           * enough lookahead, the last two strings are not inserted in
           * the hash table.
           */
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              /** * INSERT_STRING(s, s.strstart, hash_head); ** */
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
              /***/
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH$1 - 1;
          s.strstart++;
          if (bflush) {
            /** * FLUSH_BLOCK(s, 0); ** */
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/
          }
        } else if (s.match_available) {
          /* If there was no match at the previous position, output a
           * single literal. If there was a match but the current match
           * is longer, truncate the previous match to a single literal.
           */
          // Tracevv((stderr,"%c", s->window[s->strstart-1]));
          /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */
          bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            /** * FLUSH_BLOCK_ONLY(s, 0) ** */
            flush_block_only(s, false);
            /***/
          }

          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          /* There is no previous match to compare with, wait for
           * the next step to decide.
           */
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      } // Assert (flush != Z_NO_FLUSH, "no flush?");
      if (s.match_available) {
        // Tracevv((stderr,"%c", s->window[s->strstart-1]));
        /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */
        bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
      if (flush === Z_FINISH) {
        /** * FLUSH_BLOCK(s, 1); ** */
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /** * FLUSH_BLOCK(s, 0); ** */
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

      return BS_BLOCK_DONE;
    };
    /* ===========================================================================
     * For Z_RLE, simply look for runs of bytes, generate matches only of distance
     * one.  Do not maintain a hash table.  (It will be regenerated if this run of
     * deflate switches away from Z_RLE.)
     */
    var deflate_rle = function deflate_rle(s, flush) {
      var bflush;
      /* set if current block must be flushed */
      var prev;
      /* byte at distance one to match */
      var scan;
      var strend;
      /* scan goes up to strend for length of run */
      var _win = s.window;
      for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the longest run, plus one for the unrolled loop.
         */
        if (s.lookahead <= MAX_MATCH$1) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
          /* flush the current block */
        }
        /* See how many times the previous byte repeats */
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH$1;
            do {
              /* jshint noempty:false */
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH$1 - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          } // Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
        }
        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
        if (s.match_length >= MIN_MATCH$1) {
          // check_match(s, s.strstart, s.strstart - 1, s.match_length);
          /** * _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ** */
          bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          /* No match, output a literal byte */
          // Tracevv((stderr,"%c", s->window[s->strstart]));
          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */
          bflush = _tr_tally$1(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          /** * FLUSH_BLOCK(s, 0); ** */
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }

      s.insert = 0;
      if (flush === Z_FINISH) {
        /** * FLUSH_BLOCK(s, 1); ** */
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /** * FLUSH_BLOCK(s, 0); ** */
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

      return BS_BLOCK_DONE;
    };
    /* ===========================================================================
     * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
     * (It will be regenerated if this run of deflate switches away from Huffman.)
     */
    var deflate_huff = function deflate_huff(s, flush) {
      var bflush;
      /* set if current block must be flushed */
      for (;;) {
        /* Make sure that we have a literal to write. */
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
            /* flush the current block */
          }
        }
        /* Output a literal byte */
        s.match_length = 0; // Tracevv((stderr,"%c", s->window[s->strstart]));
        /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */
        bflush = _tr_tally$1(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          /** * FLUSH_BLOCK(s, 0); ** */
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }

      s.insert = 0;
      if (flush === Z_FINISH) {
        /** * FLUSH_BLOCK(s, 1); ** */
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /** * FLUSH_BLOCK(s, 0); ** */
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

      return BS_BLOCK_DONE;
    };
    /* Values for max_lazy_match, good_match and max_chain_length, depending on
     * the desired pack level (0..9). The values given below have been tuned to
     * exclude worst case performance for pathological files. Better values may be
     * found for specific files.
     */
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [/*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast), /* 2 */
    new Config(4, 6, 32, 32, deflate_fast), /* 3 */
    new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow), /* 5 */
    new Config(8, 16, 128, 128, deflate_slow), /* 6 */
    new Config(8, 32, 128, 256, deflate_slow), /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow), /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */];
    /* ===========================================================================
     * Initialize the "longest match" routines for a new zlib stream
     */
    var lm_init = function lm_init(s) {
      s.window_size = 2 * s.w_size;
      /** * CLEAR_HASH(s); ** */
      zero$1(s.head); // Fill with NIL (= 0);
      /* Set the default configuration parameters:
       */
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH$1 - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      /* pointer back to this zlib stream */
      this.status = 0;
      /* as the name implies */
      this.pending_buf = null;
      /* output still pending */
      this.pending_buf_size = 0;
      /* size of pending_buf */
      this.pending_out = 0;
      /* next pending byte to output to the stream */
      this.pending = 0;
      /* nb of bytes in the pending buffer */
      this.wrap = 0;
      /* bit 0 true for zlib, bit 1 true for gzip */
      this.gzhead = null;
      /* gzip header information to write */
      this.gzindex = 0;
      /* where in extra, name, or comment */
      this.method = Z_DEFLATED;
      /* can only be DEFLATED */
      this.last_flush = -1;
      /* value of flush param for previous deflate call */
      this.w_size = 0;
      /* LZ77 window size (32K by default) */
      this.w_bits = 0;
      /* log2(w_size)  (8..16) */
      this.w_mask = 0;
      /* w_size - 1 */
      this.window = null;
      /* Sliding window. Input bytes are read into the second half of the window,
       * and move to the first half later to keep a dictionary of at least wSize
       * bytes. With this organization, matches are limited to a distance of
       * wSize-MAX_MATCH bytes, but this ensures that IO is always
       * performed with a length multiple of the block size.
       */
      this.window_size = 0;
      /* Actual size of window: 2*wSize, except when the user input buffer
       * is directly used as sliding window.
       */
      this.prev = null;
      /* Link to older string with same hash index. To limit the size of this
       * array to 64K, this link is maintained only for the last 32K strings.
       * An index in this array is thus a window index modulo 32K.
       */
      this.head = null;
      /* Heads of the hash chains or NIL. */
      this.ins_h = 0;
      /* hash index of string to be inserted */
      this.hash_size = 0;
      /* number of elements in hash table */
      this.hash_bits = 0;
      /* log2(hash_size) */
      this.hash_mask = 0;
      /* hash_size-1 */
      this.hash_shift = 0;
      /* Number of bits by which ins_h must be shifted at each input
       * step. It must be such that after MIN_MATCH steps, the oldest
       * byte no longer takes part in the hash key, that is:
       *   hash_shift * MIN_MATCH >= hash_bits
       */
      this.block_start = 0;
      /* Window position at the beginning of the current output block. Gets
       * negative when the window is moved backwards.
       */
      this.match_length = 0;
      /* length of best match */
      this.prev_match = 0;
      /* previous match */
      this.match_available = 0;
      /* set if previous match exists */
      this.strstart = 0;
      /* start of string to insert */
      this.match_start = 0;
      /* start of matching string */
      this.lookahead = 0;
      /* number of valid bytes ahead in window */
      this.prev_length = 0;
      /* Length of the best match at previous step. Matches not greater than this
       * are discarded. This is used in the lazy match evaluation.
       */
      this.max_chain_length = 0;
      /* To speed up deflation, hash chains are never searched beyond this
       * length.  A higher limit improves compression ratio but degrades the
       * speed.
       */
      this.max_lazy_match = 0;
      /* Attempt to find a better match only when the current match is strictly
       * smaller than this value. This mechanism is used only for compression
       * levels >= 4.
       */
      // That's alias to max_lazy_match, don't use directly
      // this.max_insert_length = 0;
      /* Insert new strings in the hash table only if the match length is not
       * greater than this length. This saves time but degrades compression.
       * max_insert_length is used only for compression levels <= 3.
       */
      this.level = 0;
      /* compression level (1..9) */
      this.strategy = 0;
      /* favor or force Huffman coding */
      this.good_match = 0;
      /* Use a faster search when the previous match is longer than this */
      this.nice_match = 0;
      /* Stop searching when current match exceeds this */
      /* used by trees.c: */
      /* Didn't use ct_data typedef below to suppress compiler warning */
      // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
      // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
      // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
      // Use flat array of DOUBLE size, with interleaved fata,
      // because JS does not support effective
      this.dyn_ltree = new Uint16Array(HEAP_SIZE$1 * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES$1 + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES$1 + 1) * 2);
      zero$1(this.dyn_ltree);
      zero$1(this.dyn_dtree);
      zero$1(this.bl_tree);
      this.l_desc = null;
      /* desc. for literal tree */
      this.d_desc = null;
      /* desc. for distance tree */
      this.bl_desc = null;
      /* desc. for bit length tree */
      // ush bl_count[MAX_BITS+1];
      this.bl_count = new Uint16Array(MAX_BITS$1 + 1);
      /* number of codes at each bit length for an optimal tree */
      // int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
      this.heap = new Uint16Array(2 * L_CODES$1 + 1);
      /* heap used to build the Huffman trees */
      zero$1(this.heap);
      this.heap_len = 0;
      /* number of elements in the heap */
      this.heap_max = 0;
      /* element of largest frequency */
      /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
       * The same heap array is used to build all trees.
       */
      this.depth = new Uint16Array(2 * L_CODES$1 + 1); // uch depth[2*L_CODES+1];
      zero$1(this.depth);
      /* Depth of each subtree used as tie breaker for trees of equal frequency
       */
      this.l_buf = 0;
      /* buffer index for literals or lengths */
      this.lit_bufsize = 0;
      /* Size of match buffer for literals/lengths.  There are 4 reasons for
       * limiting lit_bufsize to 64K:
       *   - frequencies can be kept in 16 bit counters
       *   - if compression is not successful for the first block, all input
       *     data is still in the window so we can still emit a stored block even
       *     when input comes from standard input.  (This can also be done for
       *     all blocks if lit_bufsize is not greater than 32K.)
       *   - if compression is not successful for a file smaller than 64K, we can
       *     even emit a stored file instead of a stored block (saving 5 bytes).
       *     This is applicable only for zip (not gzip or zlib).
       *   - creating new Huffman trees less frequently may not provide fast
       *     adaptation to changes in the input data statistics. (Take for
       *     example a binary file with poorly compressible code followed by
       *     a highly compressible string table.) Smaller buffer sizes give
       *     fast adaptation but have of course the overhead of transmitting
       *     trees more frequently.
       *   - I can't count above 4
       */
      this.last_lit = 0;
      /* running index in l_buf */
      this.d_buf = 0;
      /* Buffer index for distances. To simplify the code, d_buf and l_buf have
       * the same number of elements. To use different lengths, an extra flag
       * array would be necessary.
       */
      this.opt_len = 0;
      /* bit length of current block with optimal trees */
      this.static_len = 0;
      /* bit length of current block with static trees */
      this.matches = 0;
      /* number of string matches in current block */
      this.insert = 0;
      /* bytes at end of window left to insert */
      this.bi_buf = 0;
      /* Output buffer. bits are inserted starting at the bottom (least
       * significant bits).
       */
      this.bi_valid = 0;
      /* Number of valid bits in bi_buf.  All bits above the last valid bit
       * are always zero.
       */
      // Used for window memory init. We safely ignore it for JS. That makes
      // sense only for pointers and memory check tools.
      // this.high_water = 0;
      /* High water mark offset in window for initialized bytes -- bytes above
       * this are set to zero in order to avoid memory check warnings when
       * longest match routines access bytes past the input.  This is then
       * updated to the new high water mark.
       */
    }

    var deflateResetKeep = function deflateResetKeep(strm) {
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN$1;
      var s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
        /* was made negative by deflate(..., Z_FINISH); */
      }

      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
      : 1; // adler32(0, Z_NULL, 0)
      s.last_flush = Z_NO_FLUSH;
      _tr_init$1(s);
      return Z_OK;
    };
    var deflateReset = function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    };
    var deflateInit2 = function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        // === Z_NULL
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        /* suppress zlib wrapper */
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        /* write gzip wrapper instead */
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED$1) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      /* until 256-byte window bug fixed */
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size); // Don't need mem init magic for JS.
      // s.high_water = 0;  /* nothing written to s->window yet */
      s.lit_bufsize = 1 << memLevel + 6;
      /* 16K elements by default */
      s.pending_buf_size = s.lit_bufsize * 4;
      // overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
      // s->pending_buf = (uchf *) overlay;
      // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      // s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
      s.d_buf = 1 * s.lit_bufsize; // s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    var deflateInit = function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    };
    var deflate = function deflate(strm, flush) {
      var beg;
      var val; // for gzip header write only
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      var s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      /* just in case */
      var old_flush = s.last_flush;
      s.last_flush = flush;
      /* Write the header */
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          // GZIP header
          strm.adler = 0; // crc32(0L, Z_NULL, 0);
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            // s->gzhead == Z_NULL
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 0xff);
            put_byte(s, s.gzhead.time >> 8 & 0xff);
            put_byte(s, s.gzhead.time >> 16 & 0xff);
            put_byte(s, s.gzhead.time >> 24 & 0xff);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 0xff);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 0xff);
              put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } // DEFLATE header
        else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          /* Save the adler32 of the preset dictionary: */
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
          }
          strm.adler = 1; // adler32(0L, Z_NULL, 0);
        }
      } // #ifdef GZIP
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra
        /* != Z_NULL */) {
          beg = s.pending;
          /* start of bytes to update crc */
          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name
        /* != Z_NULL */) {
          beg = s.pending;
          /* start of bytes to update crc */
          // int val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            } // JS specific: little magic to add zero terminator to end of string
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment
        /* != Z_NULL */) {
          beg = s.pending;
          /* start of bytes to update crc */
          // int val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            } // JS specific: little magic to add zero terminator to end of string
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, strm.adler >> 8 & 0xff);
            strm.adler = 0; // crc32(0L, Z_NULL, 0);
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      } // #endif
      /* Flush as much pending output as possible */
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          /* Since avail_out is 0, deflate will be called again with
           * more output space, but possibly with both pending and
           * avail_in equal to zero. There won't be anything to do,
           * but this is not an error situation so make sure we
           * return OK instead of BUF_ERROR at next call of deflate:
           */
          s.last_flush = -1;
          return Z_OK;
        }
        /* Make sure there is something to do and avoid duplicate consecutive
         * flushes. For repeated and useless calls with Z_FINISH, we keep
         * returning Z_STREAM_END instead of Z_BUF_ERROR.
         */
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      /* User must not provide more input after the first FINISH: */
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      /* Start a new block or continue the current one.
       */
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            /* avoid BUF_ERROR next call, see above */
          }

          return Z_OK;
          /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
           * of deflate should use the same flush parameter to make sure
           * that the flush is complete. So we don't have to output an
           * empty block here, this will be done at next call. This also
           * ensures that for a very small output buffer, we emit at most
           * one empty block.
           */
        }

        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align$1(s);
          } else if (flush !== Z_BLOCK) {
            /* FULL_FLUSH or SYNC_FLUSH */
            _tr_stored_block$1(s, 0, 0, false);
            /* For a full flush, this empty block will be recognized
             * as a special marker by inflate_sync().
             */
            if (flush === Z_FULL_FLUSH) {
              /** * CLEAR_HASH(s); ** */
              /* forget history */
              zero$1(s.head); // Fill with NIL (= 0);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            /* avoid BUF_ERROR at next call, see above */
            return Z_OK;
          }
        }
      } // Assert(strm->avail_out > 0, "bug2");
      // if (strm.avail_out <= 0) { throw new Error("bug2");}
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      /* Write the trailer */
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        put_byte(s, strm.adler >> 16 & 0xff);
        put_byte(s, strm.adler >> 24 & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, strm.total_in >> 8 & 0xff);
        put_byte(s, strm.total_in >> 16 & 0xff);
        put_byte(s, strm.total_in >> 24 & 0xff);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      flush_pending(strm);
      /* If avail_out is zero, the application will call deflate again
       * to flush the rest.
       */
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      /* write the trailer only once! */
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    };
    var deflateEnd = function deflateEnd(strm) {
      if (!strm || /* == Z_NULL */
      !strm.state
      /* == Z_NULL */) {
        return Z_STREAM_ERROR;
      }
      var status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    };
    /* =========================================================================
     * Initializes the compression dictionary from the given byte
     * sequence without producing any compressed output.
     */
    var deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      if (!strm || /* == Z_NULL */
      !strm.state
      /* == Z_NULL */) {
        return Z_STREAM_ERROR;
      }
      var s = strm.state;
      var wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      /* when using zlib wrappers, compute Adler-32 for provided dictionary */
      if (wrap === 1) {
        /* adler32(strm->adler, dictionary, dictLength); */
        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      /* avoid computing Adler-32 in read_buf */
      /* if dictionary would fill window, just replace the history */
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          /* already empty otherwise */
          /** * CLEAR_HASH(s); ** */
          zero$1(s.head); // Fill with NIL (= 0);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        /* use the tail */
        // dictionary = dictionary.slice(dictLength - s.w_size);
        var tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      /* insert dictionary into window and hash */
      var avail = strm.avail_in;
      var next = strm.next_in;
      var input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH$1) {
        var str = s.strstart;
        var n = s.lookahead - (MIN_MATCH$1 - 1);
        do {
          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH$1 - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH$1 - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    };
    var deflateInit_1 = deflateInit;
    var deflateInit2_1 = deflateInit2;
    var deflateReset_1 = deflateReset;
    var deflateResetKeep_1 = deflateResetKeep;
    var deflateSetHeader_1 = deflateSetHeader;
    var deflate_2 = deflate;
    var deflateEnd_1 = deflateEnd;
    var deflateSetDictionary_1 = deflateSetDictionary;
    var deflateInfo = 'pako deflate (from Nodeca project)';
    /* Not implemented
    module.exports.deflateBound = deflateBound;
    module.exports.deflateCopy = deflateCopy;
    module.exports.deflateParams = deflateParams;
    module.exports.deflatePending = deflatePending;
    module.exports.deflatePrime = deflatePrime;
    module.exports.deflateTune = deflateTune;
    */
    var deflate_1 = {
      deflateInit: deflateInit_1,
      deflateInit2: deflateInit2_1,
      deflateReset: deflateReset_1,
      deflateResetKeep: deflateResetKeep_1,
      deflateSetHeader: deflateSetHeader_1,
      deflate: deflate_2,
      deflateEnd: deflateEnd_1,
      deflateSetDictionary: deflateSetDictionary_1,
      deflateInfo: deflateInfo
    };
    // Join array of chunks to single array.
    function flattenChunks(chunks) {
      // calculate data length
      var len = 0;
      for (var i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      } // join chunks
      var result = new Uint8Array(len);
      for (var _i = 0, pos = 0, _l = chunks.length; _i < _l; _i++) {
        var chunk = chunks[_i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
    // String encode/decode helpers
    //
    // - apply(Array) can fail on Android 2.2
    // - apply(Uint8Array) can fail on iOS 5.1 Safari
    //
    // Table with utf8 lengths (calculated by first byte of sequence)
    // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
    // because max possible codepoint is 0x10ffff
    var _utf8len = new Uint8Array(256);
    for (var q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start
    // convert string to array (typed, when possible)
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.
    function ZStream() {
      /* next input byte */
      this.input = null; // JS specific, because we have no pointers
      this.next_in = 0;
      /* number of bytes available at input */
      this.avail_in = 0;
      /* total number of input bytes read so far */
      this.total_in = 0;
      /* next output byte should be put there */
      this.output = null; // JS specific, because we have no pointers
      this.next_out = 0;
      /* remaining free space at output */
      this.avail_out = 0;
      /* total number of bytes output so far */
      this.total_out = 0;
      /* last error message, NULL if no error */
      this.msg = '';
      /* Z_NULL */
      /* not visible by applications */
      this.state = null;
      /* best guess about the data type: binary or text */
      this.data_type = 2;
      /* Z_UNKNOWN */
      /* adler32 value of the uncompressed data */
      this.adler = 0;
    }
    var zstream = ZStream;
    // eslint-disable-next-line @typescript-eslint/unbound-method
    var toString = Object.prototype.toString;
    /* Public constants ========================================================== */
    /* =========================================================================== */
    var Z_NO_FLUSH$1 = constants.Z_NO_FLUSH;
    var Z_SYNC_FLUSH = constants.Z_SYNC_FLUSH;
    var Z_FULL_FLUSH$1 = constants.Z_FULL_FLUSH;
    var Z_FINISH$1 = constants.Z_FINISH;
    var Z_OK$1 = constants.Z_OK;
    var Z_STREAM_END$1 = constants.Z_STREAM_END;
    var Z_DEFAULT_COMPRESSION$1 = constants.Z_DEFAULT_COMPRESSION;
    var Z_DEFAULT_STRATEGY$1 = constants.Z_DEFAULT_STRATEGY;
    var Z_DEFLATED$1 = constants.Z_DEFLATED;
    /* =========================================================================== */
    /**
     * class Deflate
     *
     * Generic JS-style wrapper for zlib calls. If you don't need
     * streaming behaviour - use more simple functions: [[deflate]],
     * [[deflateRaw]] and [[gzip]].
     * */
    /* internal
     * Deflate.chunks -> Array
     *
     * Chunks of output data, if [[Deflate#onData]] not overridden.
     * */
    /**
     * Deflate.result -> Uint8Array
     *
     * Compressed result, generated by default [[Deflate#onData]]
     * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
     * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
     * */
    /**
     * Deflate.err -> Number
     *
     * Error code after deflate finished. 0 (Z_OK) on success.
     * You will not need it in real life, because deflate errors
     * are possible only on wrong options or bad `onData` / `onEnd`
     * custom handlers.
     * */
    /**
     * Deflate.msg -> String
     *
     * Error message, if [[Deflate.err]] != 0
     * */
    /**
     * new Deflate(options)
     * - options (Object): zlib deflate options.
     *
     * Creates new deflator instance with specified params. Throws exception
     * on bad params. Supported options:
     *
     * - `level`
     * - `windowBits`
     * - `memLevel`
     * - `strategy`
     * - `dictionary`
     *
     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
     * for more information on these.
     *
     * Additional options, for internal needs:
     *
     * * `chunkSize` - size of generated data chunks (16K by default)
     * * `raw` (Boolean) - do raw deflate
     * * `gzip` (Boolean) - create gzip wrapper
     * * `header` (Object) - custom header for gzip
     * ** `text` (Boolean) - true if compressed data believed to be text
     * ** `time` (Number) - modification time, unix timestamp
     * ** `os` (Number) - operation system code
     * ** `extra` (Array) - array of bytes with extra data (max 65536)
     * ** `name` (String) - file name (binary string)
     * ** `comment` (String) - comment (binary string)
     * ** `hcrc` (Boolean) - true if header crc should be added
     *
     * ##### Example:
     *
     * ```javascript
     * const pako = require('pako')
     *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
     *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
     *
     * const deflate = new pako.Deflate({ level: 3});
     *
     * deflate.push(chunk1, false);
     * deflate.push(chunk2, true);  // true -> last chunk
     *
     * if (deflate.err) { throw new Error(deflate.err); }
     *
     * console.log(deflate.result);
     * ```
     * */
    function Deflate() {
      this.options = {
        level: Z_DEFAULT_COMPRESSION$1,
        method: Z_DEFLATED$1,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY$1
      };
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0; // error code, if happens (0 = Z_OK)
      this.msg = ''; // error message
      this.ended = false; // used to avoid multiple onEnd() calls
      this.chunks = []; // chunks of compressed data
      this.strm = new zstream();
      this.strm.avail_out = 0;
      var status = deflate_1.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
      if (status !== Z_OK$1) {
        throw new Error(messages[status]);
      }
      if (opt.header) {
        deflate_1.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict; // Convert data if needed
        if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = deflate_1.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK$1) {
          throw new Error(messages[status]);
        }
        this._dict_set = true;
      }
    }
    /**
     * Deflate#push(data[, flush_mode]) -> Boolean
     * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
     * converted to utf8 byte sequence.
     * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
     * See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
     *
     * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
     * new compressed chunks. Returns `true` on success. The last data block must
     * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
     * buffers and call [[Deflate#onEnd]].
     *
     * On fail call [[Deflate#onEnd]] with error code and return false.
     *
     * ##### Example
     *
     * ```javascript
     * push(chunk, false); // push one of data chunks
     * ...
     * push(chunk, true);  // push last chunk
     * ```
     * */
    Deflate.prototype.push = function (data, flush_mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status;
      var _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode) {
        _flush_mode = flush_mode;
      } else {
        _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1;
      } // Convert data if needed
      if (toString.call(data) === '[object ArrayBuffer]') {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (;;) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        } // Make sure avail_out > 6 to avoid repeating markers
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = deflate_1.deflate(strm, _flush_mode); // Ended => flush and finish
        if (status === Z_STREAM_END$1) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = deflate_1.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK$1;
        } // Flush if out buffer full
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        } // Flush if requested and has data
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0) {
          break;
        }
      }
      return true;
    };
    /**
     * Deflate#onData(chunk) -> Void
     * - chunk (Uint8Array): output data.
     *
     * By default, stores data blocks in `chunks[]` property and glue
     * those in `onEnd`. Override this handler, if you need another behaviour.
     * */
    Deflate.prototype.onData = function (chunk) {
      this.chunks.push(chunk);
    };
    /**
     * Deflate#onEnd(status) -> Void
     * - status (Number): deflate status. 0 (Z_OK) on success,
     * other if not.
     *
     * Called once after you tell deflate that the input stream is
     * complete (Z_FINISH). By default - join collected chunks,
     * free memory and fill `results` / `err` properties.
     * */
    Deflate.prototype.onEnd = function (status) {
      // On success - join
      if (status === Z_OK$1) {
        this.result = flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    // https://github.com/nodeca/pako/blob/26dff4fb3472c5532b3bd8856421146d35ab7592/lib/utils/strings.js#L26
    function string2buf(str) {
      if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      var buf;
      var c;
      var c2;
      var m_pos;
      var i;
      var str_len = str.length;
      var buf_len = 0;
      // count binary size
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
      }
      // allocate buffer
      buf = new Uint8Array(buf_len);
      // convert
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        if (c < 0x80) {
          /* one byte */
          buf[i++] = c;
        } else if (c < 0x800) {
          /* two bytes */
          buf[i++] = 0xc0 | c >>> 6;
          buf[i++] = 0x80 | c & 0x3f;
        } else if (c < 0x10000) {
          /* three bytes */
          buf[i++] = 0xe0 | c >>> 12;
          buf[i++] = 0x80 | c >>> 6 & 0x3f;
          buf[i++] = 0x80 | c & 0x3f;
        } else {
          /* four bytes */
          buf[i++] = 0xf0 | c >>> 18;
          buf[i++] = 0x80 | c >>> 12 & 0x3f;
          buf[i++] = 0x80 | c >>> 6 & 0x3f;
          buf[i++] = 0x80 | c & 0x3f;
        }
      }
      return buf;
    }
    return {
      Deflate: Deflate,
      constants: constants,
      string2buf: string2buf
    };
  }
}
//# sourceMappingURL=deflateWorker.js.map

/***/ }),

/***/ 888490:
/*!*********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/segmentCollection/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SEGMENT_BYTES_LIMIT": () => (/* reexport safe */ _segmentCollection__WEBPACK_IMPORTED_MODULE_0__.SEGMENT_BYTES_LIMIT),
/* harmony export */   "setSegmentBytesLimit": () => (/* reexport safe */ _segmentCollection__WEBPACK_IMPORTED_MODULE_0__.setSegmentBytesLimit),
/* harmony export */   "startDeflateWorker": () => (/* reexport safe */ _startDeflateWorker__WEBPACK_IMPORTED_MODULE_1__.startDeflateWorker),
/* harmony export */   "startSegmentCollection": () => (/* reexport safe */ _segmentCollection__WEBPACK_IMPORTED_MODULE_0__.startSegmentCollection)
/* harmony export */ });
/* harmony import */ var _segmentCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./segmentCollection */ 891455);
/* harmony import */ var _startDeflateWorker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./startDeflateWorker */ 229047);



//# sourceMappingURL=index.js.map

/***/ }),

/***/ 271252:
/*!***********************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segment.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Segment": () => (/* binding */ Segment)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 822006);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 931942);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 413464);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types */ 938168);
/* harmony import */ var _replayStats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../replayStats */ 157818);



var nextId = 0;
var Segment = /** @class */function () {
  function Segment(worker, context, creationReason, initialRecord, onWrote, onFlushed) {
    var _this = this;
    this.worker = worker;
    this.id = nextId++;
    var viewId = context.view.id;
    this.metadata = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.assign)({
      start: initialRecord.timestamp,
      end: initialRecord.timestamp,
      creation_reason: creationReason,
      records_count: 1,
      has_full_snapshot: initialRecord.type === _types__WEBPACK_IMPORTED_MODULE_0__.RecordType.FullSnapshot,
      index_in_view: _replayStats__WEBPACK_IMPORTED_MODULE_1__.getSegmentsCount(viewId),
      source: 'browser'
    }, context);
    _replayStats__WEBPACK_IMPORTED_MODULE_1__.addSegment(viewId);
    _replayStats__WEBPACK_IMPORTED_MODULE_1__.addRecord(viewId);
    var removeMessageListener = (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.addEventListener)(worker, 'message', function (_a) {
      var data = _a.data;
      if (data.type === 'errored' || data.type === 'initialized') {
        return;
      }
      if (data.id === _this.id) {
        _replayStats__WEBPACK_IMPORTED_MODULE_1__.addWroteData(viewId, data.additionalBytesCount);
        if (data.type === 'flushed') {
          onFlushed(data.result, data.rawBytesCount);
          removeMessageListener();
        } else {
          onWrote(data.compressedBytesCount);
        }
      } else if (data.id > _this.id) {
        // Messages should be received in the same order as they are sent, so if we receive a
        // message with an id superior to this Segment instance id, we know that another, more
        // recent Segment instance is being used.
        //
        // In theory, a "flush" response should have been received at this point, so the listener
        // should already have been removed. But if something goes wrong and we didn't receive a
        // "flush" response, remove the listener to avoid any leak, and send a monitor message to
        // help investigate the issue.
        removeMessageListener();
        (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.addTelemetryDebug)("Segment did not receive a 'flush' response before being replaced.");
      }
    }).stop;
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.sendToExtension)('record', {
      record: initialRecord,
      segment: this.metadata
    });
    this.worker.postMessage({
      data: "{\"records\":[".concat(JSON.stringify(initialRecord)),
      id: this.id,
      action: 'write'
    });
  }
  Segment.prototype.addRecord = function (record) {
    var _a;
    this.metadata.start = Math.min(this.metadata.start, record.timestamp);
    this.metadata.end = Math.max(this.metadata.end, record.timestamp);
    this.metadata.records_count += 1;
    _replayStats__WEBPACK_IMPORTED_MODULE_1__.addRecord(this.metadata.view.id);
    (_a = this.metadata).has_full_snapshot || (_a.has_full_snapshot = record.type === _types__WEBPACK_IMPORTED_MODULE_0__.RecordType.FullSnapshot);
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.sendToExtension)('record', {
      record: record,
      segment: this.metadata
    });
    this.worker.postMessage({
      data: ",".concat(JSON.stringify(record)),
      id: this.id,
      action: 'write'
    });
  };
  Segment.prototype.flush = function (reason) {
    this.worker.postMessage({
      data: "],".concat(JSON.stringify(this.metadata).slice(1), "\n"),
      id: this.id,
      action: 'flush'
    });
    this.flushReason = reason;
  };
  return Segment;
}();

//# sourceMappingURL=segment.js.map

/***/ }),

/***/ 891455:
/*!*********************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segmentCollection.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SEGMENT_BYTES_LIMIT": () => (/* binding */ SEGMENT_BYTES_LIMIT),
/* harmony export */   "SEGMENT_DURATION_LIMIT": () => (/* binding */ SEGMENT_DURATION_LIMIT),
/* harmony export */   "computeSegmentContext": () => (/* binding */ computeSegmentContext),
/* harmony export */   "doStartSegmentCollection": () => (/* binding */ doStartSegmentCollection),
/* harmony export */   "setSegmentBytesLimit": () => (/* binding */ setSegmentBytesLimit),
/* harmony export */   "startSegmentCollection": () => (/* binding */ startSegmentCollection)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 573647);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 631128);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 37215);
/* harmony import */ var _buildReplayPayload__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buildReplayPayload */ 866802);
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./segment */ 271252);



var SEGMENT_DURATION_LIMIT = 30 * _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.ONE_SECOND;
/**
 * beacon payload max queue size implementation is 64kb
 * ensure that we leave room for logs, rum and potential other users
 */
var SEGMENT_BYTES_LIMIT = 60000;
// Segments are the main data structure for session replays. They contain context information used
// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing
// namings). They are stored without any processing from the intake, and fetched one after the
// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow
// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to
// build segments containing as many records as possible while complying with the various flush
// strategies to guarantee a good replay quality.
//
// When the recording starts, a segment is initially created.  The segment is flushed (finalized and
// sent) based on various events (non-exhaustive list):
//
// * the page visibility change or becomes to unload
// * the segment duration reaches a limit
// * the encoded segment bytes count reaches a limit
// * ...
//
// A segment cannot be created without its context.  If the RUM session ends and no session id is
// available when creating a new segment, records will be ignored, until the session is renewed and
// a new session id is available.
//
// Empty segments (segments with no record) aren't useful and should be ignored.
//
// To help investigate session replays issues, each segment is created with a "creation reason",
// indicating why the session has been created.
function startSegmentCollection(lifeCycle, applicationId, sessionManager, viewContexts, httpRequest, worker) {
  return doStartSegmentCollection(lifeCycle, function () {
    return computeSegmentContext(applicationId, sessionManager, viewContexts);
  }, httpRequest, worker);
}
function doStartSegmentCollection(lifeCycle, getSegmentContext, httpRequest, worker) {
  var state = {
    status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,
    nextSegmentCreationReason: 'init'
  };
  var unsubscribeViewCreated = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, function () {
    flushSegment('view_change');
  }).unsubscribe;
  var unsubscribePageExited = lifeCycle.subscribe(9 /* LifeCycleEventType.PAGE_EXITED */, function (pageExitEvent) {
    flushSegment(pageExitEvent.reason);
  }).unsubscribe;
  function flushSegment(flushReason) {
    if (state.status === 1 /* SegmentCollectionStatus.SegmentPending */) {
      state.segment.flush(flushReason);
      (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.clearTimeout)(state.expirationTimeoutId);
    }
    if (flushReason !== 'stop') {
      state = {
        status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,
        nextSegmentCreationReason: flushReason
      };
    } else {
      state = {
        status: 2 /* SegmentCollectionStatus.Stopped */
      };
    }
  }

  function createNewSegment(creationReason, initialRecord) {
    var context = getSegmentContext();
    if (!context) {
      return;
    }
    var segment = new _segment__WEBPACK_IMPORTED_MODULE_1__.Segment(worker, context, creationReason, initialRecord, function (compressedSegmentBytesCount) {
      if (!segment.flushReason && compressedSegmentBytesCount > SEGMENT_BYTES_LIMIT) {
        flushSegment('segment_bytes_limit');
      }
    }, function (data, rawSegmentBytesCount) {
      var payload = (0,_buildReplayPayload__WEBPACK_IMPORTED_MODULE_0__.buildReplayPayload)(data, segment.metadata, rawSegmentBytesCount);
      if ((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.isPageExitReason)(segment.flushReason)) {
        httpRequest.sendOnExit(payload);
      } else {
        httpRequest.send(payload);
      }
    });
    state = {
      status: 1 /* SegmentCollectionStatus.SegmentPending */,
      segment: segment,
      expirationTimeoutId: (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.setTimeout)(function () {
        flushSegment('segment_duration_limit');
      }, SEGMENT_DURATION_LIMIT)
    };
  }
  return {
    addRecord: function (record) {
      switch (state.status) {
        case 0 /* SegmentCollectionStatus.WaitingForInitialRecord */:
          createNewSegment(state.nextSegmentCreationReason, record);
          break;
        case 1 /* SegmentCollectionStatus.SegmentPending */:
          state.segment.addRecord(record);
          break;
      }
    },
    stop: function () {
      flushSegment('stop');
      unsubscribeViewCreated();
      unsubscribePageExited();
    }
  };
}
function computeSegmentContext(applicationId, sessionManager, viewContexts) {
  var session = sessionManager.findTrackedSession();
  var viewContext = viewContexts.findView();
  if (!session || !viewContext) {
    return undefined;
  }
  return {
    application: {
      id: applicationId
    },
    session: {
      id: session.id
    },
    view: {
      id: viewContext.id
    }
  };
}
function setSegmentBytesLimit(newSegmentBytesLimit) {
  if (newSegmentBytesLimit === void 0) {
    newSegmentBytesLimit = 60000;
  }
  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit;
}
//# sourceMappingURL=segmentCollection.js.map

/***/ }),

/***/ 229047:
/*!**********************************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/domain/segmentCollection/startDeflateWorker.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "doStartDeflateWorker": () => (/* binding */ doStartDeflateWorker),
/* harmony export */   "resetDeflateWorkerState": () => (/* binding */ resetDeflateWorkerState),
/* harmony export */   "startDeflateWorker": () => (/* binding */ startDeflateWorker)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-core */ 822006);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datadog/browser-core */ 700959);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 931942);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 777760);
/* harmony import */ var _deflateWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./deflateWorker */ 312188);


var state = {
  status: 0 /* DeflateWorkerStatus.Nil */
};
function startDeflateWorker(callback, createDeflateWorkerImpl) {
  if (createDeflateWorkerImpl === void 0) {
    createDeflateWorkerImpl = _deflateWorker__WEBPACK_IMPORTED_MODULE_0__.createDeflateWorker;
  }
  switch (state.status) {
    case 0 /* DeflateWorkerStatus.Nil */:
      state = {
        status: 1 /* DeflateWorkerStatus.Loading */,
        callbacks: [callback]
      };
      doStartDeflateWorker(createDeflateWorkerImpl);
      break;
    case 1 /* DeflateWorkerStatus.Loading */:
      state.callbacks.push(callback);
      break;
    case 2 /* DeflateWorkerStatus.Error */:
      callback();
      break;
    case 3 /* DeflateWorkerStatus.Initialized */:
      callback(state.worker);
      break;
  }
}
function resetDeflateWorkerState() {
  state = {
    status: 0 /* DeflateWorkerStatus.Nil */
  };
}
/**
 * Starts the deflate worker and handle messages and errors
 *
 * The spec allow browsers to handle worker errors differently:
 * - Chromium throws an exception
 * - Firefox fires an error event
 *
 * more details: https://bugzilla.mozilla.org/show_bug.cgi?id=1736865#c2
 */
function doStartDeflateWorker(createDeflateWorkerImpl) {
  if (createDeflateWorkerImpl === void 0) {
    createDeflateWorkerImpl = _deflateWorker__WEBPACK_IMPORTED_MODULE_0__.createDeflateWorker;
  }
  try {
    var worker_1 = createDeflateWorkerImpl();
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.addEventListener)(worker_1, 'error', onError);
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_1__.addEventListener)(worker_1, 'message', function (_a) {
      var data = _a.data;
      if (data.type === 'errored') {
        onError(data.error);
      } else if (data.type === 'initialized') {
        onInitialized(worker_1);
      }
    });
    worker_1.postMessage({
      action: 'init'
    });
    return worker_1;
  } catch (error) {
    onError(error);
  }
}
function onInitialized(worker) {
  if (state.status === 1 /* DeflateWorkerStatus.Loading */) {
    state.callbacks.forEach(function (callback) {
      return callback(worker);
    });
    state = {
      status: 3 /* DeflateWorkerStatus.Initialized */,
      worker: worker
    };
  }
}
function onError(error) {
  if (state.status === 1 /* DeflateWorkerStatus.Loading */) {
    _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.display.error('Session Replay recording failed to start: an error occurred while creating the Worker:', error);
    if (error instanceof Event || error instanceof Error && isMessageCspRelated(error.message)) {
      _datadog_browser_core__WEBPACK_IMPORTED_MODULE_2__.display.error('Please make sure CSP is correctly configured ' + 'https://docs.datadoghq.com/real_user_monitoring/faq/content_security_policy');
    } else {
      (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.addTelemetryError)(error);
    }
    state.callbacks.forEach(function (callback) {
      return callback();
    });
    state = {
      status: 2 /* DeflateWorkerStatus.Error */
    };
  } else {
    (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.addTelemetryError)(error);
  }
}
function isMessageCspRelated(message) {
  return (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.includes)(message, 'Content Security Policy') ||
  // Related to `require-trusted-types-for` CSP: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/require-trusted-types-for
  (0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.includes)(message, "requires 'TrustedScriptURL'");
}
//# sourceMappingURL=startDeflateWorker.js.map

/***/ }),

/***/ 262886:
/*!***************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/entries/main.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultPrivacyLevel": () => (/* reexport safe */ _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__.DefaultPrivacyLevel),
/* harmony export */   "datadogRum": () => (/* binding */ datadogRum)
/* harmony export */ });
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datadog/browser-core */ 464929);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datadog/browser-core */ 909428);
/* harmony import */ var _datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-rum-core */ 454959);
/* harmony import */ var _boot_startRecording__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../boot/startRecording */ 76816);
/* harmony import */ var _boot_recorderApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../boot/recorderApi */ 795540);
/* harmony import */ var _datadog_browser_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datadog/browser-core */ 351540);
// Keep the following in sync with packages/rum-slim/src/entries/main.ts





var recorderApi = (0,_boot_recorderApi__WEBPACK_IMPORTED_MODULE_2__.makeRecorderApi)(_boot_startRecording__WEBPACK_IMPORTED_MODULE_1__.startRecording);
var datadogRum = (0,_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.makeRumPublicApi)(_datadog_browser_rum_core__WEBPACK_IMPORTED_MODULE_0__.startRum, recorderApi);
(0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_4__.defineGlobal)((0,_datadog_browser_core__WEBPACK_IMPORTED_MODULE_5__.getGlobalObject)(), 'DD_RUM', datadogRum);
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 938168:
/*!**************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/types/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IncrementalSource": () => (/* reexport safe */ _sessionReplayConstants__WEBPACK_IMPORTED_MODULE_1__.IncrementalSource),
/* harmony export */   "MediaInteractionType": () => (/* reexport safe */ _sessionReplayConstants__WEBPACK_IMPORTED_MODULE_1__.MediaInteractionType),
/* harmony export */   "MouseInteractionType": () => (/* reexport safe */ _sessionReplayConstants__WEBPACK_IMPORTED_MODULE_1__.MouseInteractionType),
/* harmony export */   "NodeType": () => (/* reexport safe */ _sessionReplayConstants__WEBPACK_IMPORTED_MODULE_1__.NodeType),
/* harmony export */   "RecordType": () => (/* reexport safe */ _sessionReplayConstants__WEBPACK_IMPORTED_MODULE_1__.RecordType)
/* harmony export */ });
/* harmony import */ var _sessionReplay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sessionReplay */ 415130);
/* harmony import */ var _sessionReplayConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sessionReplayConstants */ 383239);


//# sourceMappingURL=index.js.map

/***/ }),

/***/ 415130:
/*!**********************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/types/sessionReplay.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* eslint-disable */
/**
 * DO NOT MODIFY IT BY HAND. Run `yarn rum-events-format:sync` instead.
 */

//# sourceMappingURL=sessionReplay.js.map

/***/ }),

/***/ 383239:
/*!*******************************************************************************!*\
  !*** ./node_modules/@datadog/browser-rum/esm/types/sessionReplayConstants.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IncrementalSource": () => (/* binding */ IncrementalSource),
/* harmony export */   "MediaInteractionType": () => (/* binding */ MediaInteractionType),
/* harmony export */   "MouseInteractionType": () => (/* binding */ MouseInteractionType),
/* harmony export */   "NodeType": () => (/* binding */ NodeType),
/* harmony export */   "RecordType": () => (/* binding */ RecordType)
/* harmony export */ });
var RecordType = {
  FullSnapshot: 2,
  IncrementalSnapshot: 3,
  Meta: 4,
  Focus: 6,
  ViewEnd: 7,
  VisualViewport: 8,
  FrustrationRecord: 9
};
var NodeType = {
  Document: 0,
  DocumentType: 1,
  Element: 2,
  Text: 3,
  CDATA: 4,
  DocumentFragment: 11
};
var IncrementalSource = {
  Mutation: 0,
  MouseMove: 1,
  MouseInteraction: 2,
  Scroll: 3,
  ViewportResize: 4,
  Input: 5,
  TouchMove: 6,
  MediaInteraction: 7,
  StyleSheetRule: 8
  // CanvasMutation : 9,
  // Font : 10,
};

var MouseInteractionType = {
  MouseUp: 0,
  MouseDown: 1,
  Click: 2,
  ContextMenu: 3,
  DblClick: 4,
  Focus: 5,
  Blur: 6,
  TouchStart: 7,
  TouchEnd: 9
};
var MediaInteractionType = {
  Play: 0,
  Pause: 1
};
//# sourceMappingURL=sessionReplayConstants.js.map

/***/ }),

/***/ 893430:
/*!**************************************************!*\
  !*** ./libs/business-logic/actions/src/index.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Action": () => (/* reexport safe */ _src_lib_Action__WEBPACK_IMPORTED_MODULE_1__.Action),
/* harmony export */   "ActionResult": () => (/* reexport safe */ _lib_action_result__WEBPACK_IMPORTED_MODULE_0__.ActionResult)
/* harmony export */ });
/* harmony import */ var _lib_action_result__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/action-result */ 655162);
/* harmony import */ var _src_lib_Action__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/lib/Action */ 323612);



/***/ }),

/***/ 323612:
/*!*******************************************************!*\
  !*** ./libs/business-logic/actions/src/lib/Action.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Action": () => (/* binding */ Action)
/* harmony export */ });
/* harmony import */ var _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @schema-driven/rules-engine */ 266710);
/* harmony import */ var _action_result__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./action-result */ 655162);


/**
 * This is the framework Action class that provides the pipeline of pre/post
 * execution methods. This class implements the [Template Method] pattern. Use
 * it to create and manage the life cycle of an action.
 *
 * The pre-execute functions that can be implemented are:
 *		1. start();
 *		2. audit();
 *		3. preValidateAction();
 *		4. evaluateRules();
 *		5. postValidateAction();
 *		6. preExecuteAction();
 *
 *If the status of action is good, the business logic will be executed using the:
 *		7. processAction();
 *
 * The post-execution functions that can be implemented are:
 *		8. postExecuteAction();
 *		9. validateActionResult();
 *		10. finish();
 */
// export abstract class Action implements IAction {
class Action {
  constructor() {
    /**
     * Indicates if the action is allowed execution. If there are any rule
     * violations in the validation context, the action is not allowed to
     * execute.
     */
    this.allowExecution = true;
    /**
     * The validation context for the specified action instance.
     */
    this._validationContext = new _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__.ValidationContext();
    /**
     * The result of the action. The default value is [Unknown], until the action
     * is executed.
     */
    this.actionResult = _action_result__WEBPACK_IMPORTED_MODULE_1__.ActionResult.Unknown;
  }
  /**
   * Use to retrieve the [ValidationContext] for the specified action.
   */
  get validationContext() {
    return this._validationContext;
  }
  /**
   * Use this method to execute a concrete action. A concrete action must implement
   * the [processAction] and the [validateActionResult] functions to be a valid
   * action.
   */
  execute() {
    this.processActionPipeline();
  }
  /**
   * Use this method to process the action pipeline methods.
   */
  processActionPipeline() {
    this.startAction();
    if (this.allowExecution) {
      this.processAction();
    }
    this.finishAction();
  }
  /**
   * Use this method to call the pipeline methods for the [start] or beginning
   * process of the action pipeline.
   */
  startAction() {
    this.start();
    this.audit();
    this.preValidateAction();
    this.evaluateRules();
    this.postValidateAction();
    this.preExecuteAction();
  }
  /**
   * Use this method to execute the methods at the end of the action pipeline.
   */
  finishAction() {
    this.postExecuteAction();
    this.validateActionResult();
    this.finish();
  }
  /**
   * Use this method to process the action. This will only be called if the action's
   * validation context is in a valid state (no rule violations).
   *
   * All concrete actions are required to provide an implementation of the [performAction]
   * method that is called for this part of the action pipeline.
   */
  processAction() {
    this.performAction();
  }
  /**
   * Use this function to implement the execution of the validation and business rules. This
   * function is called after [preValidateAction].
   */
  evaluateRules() {
    const context = this.validateAction();
    if (context.isValid) {
      this.allowExecution = true;
      this.validationContext.state = _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__.ValidationContextState.Success;
    } else {
      this.allowExecution = false;
      this.validationContext.state = _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__.ValidationContextState.Failure;
    }
  }
  /**
   * Implement this function to perform validation of business rules and data.
   */
  validateAction() {
    return this.validationContext;
  }
}

/***/ }),

/***/ 655162:
/*!**************************************************************!*\
  !*** ./libs/business-logic/actions/src/lib/action-result.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActionResult": () => (/* binding */ ActionResult)
/* harmony export */ });
/**
 * Use to indicate the result of the action (i.e., Success, Fail, or Unknown).
 */
var ActionResult;
(function (ActionResult) {
  /**
   * Use to indicate that the action's result is success.
   */
  ActionResult["Success"] = "Success";
  /**
   * Use to indicate that the action's result is failure.
   */
  ActionResult["Fail"] = "Fail";
  /**
   * Use to indicate that the action's result is unknown.
   */
  ActionResult["Unknown"] = "Unknown";
})(ActionResult || (ActionResult = {}));

/***/ }),

/***/ 526375:
/*!***********************************************!*\
  !*** ./libs/business-logic/core/src/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiErrorMessage": () => (/* reexport safe */ _lib_api_api_error_message__WEBPACK_IMPORTED_MODULE_0__.ApiErrorMessage),
/* harmony export */   "ApiMessage": () => (/* reexport safe */ _lib_api_api_message__WEBPACK_IMPORTED_MODULE_1__.ApiMessage),
/* harmony export */   "ApiMessageType": () => (/* reexport safe */ _lib_api_api_message_type_enum__WEBPACK_IMPORTED_MODULE_2__.ApiMessageType),
/* harmony export */   "ApiResponse": () => (/* reexport safe */ _lib_api_api_response__WEBPACK_IMPORTED_MODULE_3__.ApiResponse),
/* harmony export */   "VersionInfo": () => (/* reexport safe */ _lib_version_version_info_model__WEBPACK_IMPORTED_MODULE_4__.VersionInfo)
/* harmony export */ });
/* harmony import */ var _lib_api_api_error_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/api/api-error-message */ 610640);
/* harmony import */ var _lib_api_api_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/api/api-message */ 481347);
/* harmony import */ var _lib_api_api_message_type_enum__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/api/api-message-type.enum */ 499866);
/* harmony import */ var _lib_api_api_response__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/api/api-response */ 611041);
/* harmony import */ var _lib_version_version_info_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/version/version-info.model */ 253674);






/***/ }),

/***/ 610640:
/*!*******************************************************************!*\
  !*** ./libs/business-logic/core/src/lib/api/api-error-message.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiErrorMessage": () => (/* binding */ ApiErrorMessage)
/* harmony export */ });
/* harmony import */ var _api_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api-message */ 481347);
/* harmony import */ var _api_message_type_enum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api-message-type.enum */ 499866);


class ApiErrorMessage extends _api_message__WEBPACK_IMPORTED_MODULE_0__.ApiMessage {
  /**
   * Use to create a new [ApiErrorMessage].
   *
   * @param message The error from the API.
   * @param code An optional identifier for the error.
   */
  constructor(message, code) {
    super();
    this.messageType = _api_message_type_enum__WEBPACK_IMPORTED_MODULE_1__.ApiMessageType.Error;
    this.message = message;
    if (code) {
      this.code = code;
    }
  }
}

/***/ }),

/***/ 499866:
/*!***********************************************************************!*\
  !*** ./libs/business-logic/core/src/lib/api/api-message-type.enum.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiMessageType": () => (/* binding */ ApiMessageType)
/* harmony export */ });
var ApiMessageType;
(function (ApiMessageType) {
  /**
   * Use to indicate the message type is informational.
   */
  ApiMessageType["Information"] = "Information";
  /**
   * Use to indicate the message type is warning.
   */
  ApiMessageType["Warning"] = "Warning";
  /**
   * Use to indicate the message type is error.
   */
  ApiMessageType["Error"] = "Error";
})(ApiMessageType || (ApiMessageType = {}));

/***/ }),

/***/ 481347:
/*!*************************************************************!*\
  !*** ./libs/business-logic/core/src/lib/api/api-message.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiMessage": () => (/* binding */ ApiMessage)
/* harmony export */ });
/* harmony import */ var _api_message_type_enum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api-message-type.enum */ 499866);

/**
 * Use this class to define messages for the application. The source of the message
 * may be the server API or even the application domain. The default
 * [message type] is [Information] if not specified (e.g., Warning, Error).
 */
class ApiMessage {
  constructor(code, message, messageType = _api_message_type_enum__WEBPACK_IMPORTED_MODULE_0__.ApiMessageType.Information) {
    code ? this.code = code : this.code = '';
    messageType ? this.messageType = messageType : this.messageType = _api_message_type_enum__WEBPACK_IMPORTED_MODULE_0__.ApiMessageType.Information; //default;
  }
}

/***/ }),

/***/ 611041:
/*!**************************************************************!*\
  !*** ./libs/business-logic/core/src/lib/api/api-response.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiResponse": () => (/* binding */ ApiResponse)
/* harmony export */ });
class ApiResponse {
  constructor() {
    /** A boolean indicator of success for the response. */
    this.isSuccess = false;
    /**
     * A message from the application API. Should not be used for general user notifications.
     */
    this.message = '';
    /**
     * A list of [ApiMessage] items.
     */
    this.messages = new Array();
    /**
     * Use to provide the timestamp the response was processed by the API.
     */
    this.timestamp = new Date();
  }
}

/***/ }),

/***/ 253674:
/*!************************************************************************!*\
  !*** ./libs/business-logic/core/src/lib/version/version-info.model.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VersionInfo": () => (/* binding */ VersionInfo)
/* harmony export */ });
class VersionInfo {
  constructor(application, version, buildDate, hash) {
    this.application = application;
    this.version = version;
    this.buildDate = buildDate;
    this.hash = hash;
  }
}

/***/ }),

/***/ 933886:
/*!*****************************************************!*\
  !*** ./libs/business-logic/foundation/src/index.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActionBase": () => (/* reexport safe */ _lib_action_base_action__WEBPACK_IMPORTED_MODULE_1__.ActionBase),
/* harmony export */   "AlertNotification": () => (/* reexport safe */ _lib_models_alert_notification_model__WEBPACK_IMPORTED_MODULE_2__.AlertNotification),
/* harmony export */   "AlertTypes": () => (/* reexport safe */ _lib_models_alert_types_constants__WEBPACK_IMPORTED_MODULE_3__.AlertTypes),
/* harmony export */   "BusinessProviderBase": () => (/* reexport safe */ _lib_business_provider_base_service__WEBPACK_IMPORTED_MODULE_4__.BusinessProviderBase),
/* harmony export */   "ComponentBase": () => (/* reexport safe */ _lib_component_base_component__WEBPACK_IMPORTED_MODULE_5__.ComponentBase),
/* harmony export */   "ErrorResponse": () => (/* reexport safe */ _lib_models_error_response_model__WEBPACK_IMPORTED_MODULE_6__.ErrorResponse),
/* harmony export */   "FoundationModule": () => (/* reexport safe */ _lib_foundation_module__WEBPACK_IMPORTED_MODULE_0__.FoundationModule),
/* harmony export */   "MessageType": () => (/* reexport safe */ _lib_models_MessageType__WEBPACK_IMPORTED_MODULE_7__.MessageType),
/* harmony export */   "ServiceBase": () => (/* reexport safe */ _lib_service_base__WEBPACK_IMPORTED_MODULE_8__.ServiceBase),
/* harmony export */   "ServiceContext": () => (/* reexport safe */ _lib_models_ServiceContext__WEBPACK_IMPORTED_MODULE_9__.ServiceContext),
/* harmony export */   "ServiceError": () => (/* reexport safe */ _lib_models_service_error_model__WEBPACK_IMPORTED_MODULE_10__.ServiceError),
/* harmony export */   "ServiceMessage": () => (/* reexport safe */ _lib_models_ServiceMessage__WEBPACK_IMPORTED_MODULE_11__.ServiceMessage),
/* harmony export */   "ServiceResponse": () => (/* reexport safe */ _lib_models_service_response_model__WEBPACK_IMPORTED_MODULE_12__.ServiceResponse),
/* harmony export */   "SingletonServiceBase": () => (/* reexport safe */ _lib_singleton_service_base__WEBPACK_IMPORTED_MODULE_13__.SingletonServiceBase)
/* harmony export */ });
/* harmony import */ var _lib_foundation_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/foundation.module */ 636063);
/* harmony import */ var _lib_action_base_action__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/action-base.action */ 730726);
/* harmony import */ var _lib_models_alert_notification_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/models/alert-notification.model */ 862360);
/* harmony import */ var _lib_models_alert_types_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/models/alert-types.constants */ 587033);
/* harmony import */ var _lib_business_provider_base_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/business-provider-base.service */ 467691);
/* harmony import */ var _lib_component_base_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/component-base.component */ 136727);
/* harmony import */ var _lib_models_error_response_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/models/error-response.model */ 342022);
/* harmony import */ var _lib_models_MessageType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/models/MessageType */ 126500);
/* harmony import */ var _lib_service_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/service-base */ 225162);
/* harmony import */ var _lib_models_ServiceContext__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/models/ServiceContext */ 933325);
/* harmony import */ var _lib_models_service_error_model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/models/service-error.model */ 973342);
/* harmony import */ var _lib_models_ServiceMessage__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/models/ServiceMessage */ 537171);
/* harmony import */ var _lib_models_service_response_model__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/models/service-response.model */ 34117);
/* harmony import */ var _lib_singleton_service_base__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/singleton-service-base */ 848011);















/***/ }),

/***/ 730726:
/*!**********************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/action-base.action.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActionBase": () => (/* binding */ ActionBase)
/* harmony export */ });
/* harmony import */ var _schema_driven_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @schema-driven/actions */ 893430);
/* harmony import */ var _schema_driven_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @schema-driven/core */ 526375);
/* harmony import */ var _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @schema-driven/logging */ 494391);
/* harmony import */ var _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @schema-driven/rules-engine */ 266710);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ 439646);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs */ 862843);
/* harmony import */ var _models_error_response_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./models/error-response.model */ 342022);
/* harmony import */ var _models_MessageType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./models/MessageType */ 126500);
/* harmony import */ var _models_ServiceContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./models/ServiceContext */ 933325);
/* harmony import */ var _models_ServiceMessage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models/ServiceMessage */ 537171);









/**
 * This is the application's base Action class that provides implementation of pipeline methods - pre/post
 * execution methods.
 *
 * The pre-execute methods that can be implemented are:
 *		1. start();
 *		2. audit();
 *		3. preValidateAction();
 *		4. evaluateRules();
 *		5. postValidateAction();
 *		6. preExecuteAction();
 *
 *If the status of action is good, the business logic will be executed using the:
 *		1. processAction();
 *
 * The post-execution methods that can be implemented are:
 *		1. postExecuteAction();
 *		2. validateActionResult();
 *		3. finish();
 */
class ActionBase extends _schema_driven_actions__WEBPACK_IMPORTED_MODULE_0__.Action {
  constructor(actionName) {
    super();
    this.serviceContext = new _models_ServiceContext__WEBPACK_IMPORTED_MODULE_6__.ServiceContext();
    this.response = this.createUnknownResponse();
    this.actionName = actionName !== null && actionName !== void 0 ? actionName : '';
  }
  start() {
    // this.loggingService?.log(
    //   this.actionName,
    //   Severity.Information,
    //   `Preparing to [start] action.`
    // );
    this.serviceContext.Messages = [];
  }
  audit() {
    var _a;
    (_a = this.loggingService) === null || _a === void 0 ? void 0 : _a.log(this.actionName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__.Severity.Information, `Preparing to [audit] action.`);
  }
  createUnknownResponse() {
    const response = new _schema_driven_core__WEBPACK_IMPORTED_MODULE_1__.ApiResponse();
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.of)(response);
  }
  preExecuteAction() {
    var _a;
    (_a = this.loggingService) === null || _a === void 0 ? void 0 : _a.log(this.actionName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__.Severity.Information, `Preparing to [preExecuteAction] action.`);
  }
  performAction() {
    var _a;
    (_a = this.loggingService) === null || _a === void 0 ? void 0 : _a.log(this.actionName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__.Severity.Information, `Preparing to perform [${this.actionName}].`);
  }
  preValidateAction() {
    var _a;
    (_a = this.loggingService) === null || _a === void 0 ? void 0 : _a.log(this.actionName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__.Severity.Information, `Preparing to preValidateAction [${this.actionName}].`);
  }
  finish() {
    var _a;
    (_a = this.loggingService) === null || _a === void 0 ? void 0 : _a.log(this.actionName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__.Severity.Information, `Preparing to [finish] action.`);
  }
  /**
   * This is a required implementation if you want to render/execute the rules that
   * are associated to the specified action.
   */
  validateAction() {
    return this.validationContext.renderRules();
  }
  postValidateAction() {
    var _a, _b;
    (_a = this.loggingService) === null || _a === void 0 ? void 0 : _a.log(this.actionName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__.Severity.Information, `Preparing to determine if the action contains validation errors in ${this.actionName}`);
    if (this.validationContext.hasRuleViolations()) {
      (_b = this.loggingService) === null || _b === void 0 ? void 0 : _b.log(this.actionName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__.Severity.Information, `The target contains validation errors in ${this.actionName}`);
      // Load the error/rule violations into the ServiceContext so that the information bubbles up to the caller of the service;
      this.validationContext.results.forEach(result => {
        if (!result.isValid) {
          this.publishRuleResult(result);
          this.retrieveRuleDetails(result);
        }
      });
      this.response = this.createFailResponse();
    }
  }
  createFailResponse(message = null) {
    // const apiResponse = new ApiResponse<T>();
    // apiResponse.isSuccess = false;
    // apiResponse.message = message ?? `Request failed.`;
    // const messages = new Array<ApiMessage>();
    // if (this.serviceContext.hasErrors() && this.serviceContext.Messages.length > 0) {
    //   this.serviceContext.Messages.map((m) => {
    //     const error = new ApiMessage();
    //     error.message = m.Message;
    //     error.messageType = ApiMessageType.Error;
    //     error.code = m.Name;
    //     messages.push(error);
    //   });
    // }
    // apiResponse.messages = messages.length > 0 ? messages : [];
    // return of(apiResponse);
    const errorResponse = new _models_error_response_model__WEBPACK_IMPORTED_MODULE_4__.ErrorResponse();
    errorResponse.IsSuccess = false;
    errorResponse.Message = message !== null && message !== void 0 ? message : `Request failed.`;
    const errorData = {};
    this.serviceContext.Messages.forEach(e => {
      if (e.MessageType === _models_MessageType__WEBPACK_IMPORTED_MODULE_5__.MessageType.Error) {
        errorData[e.Name] = e.Message;
      }
    });
    errorResponse.Data = errorData;
    this.response = (0,rxjs__WEBPACK_IMPORTED_MODULE_9__.throwError)(errorResponse);
  }
  postExecuteAction() {
    if (this.actionResult === _schema_driven_actions__WEBPACK_IMPORTED_MODULE_0__.ActionResult.Fail) {
      this.serviceContext.Messages.forEach(e => {
        var _a;
        if (e.MessageType === _models_MessageType__WEBPACK_IMPORTED_MODULE_5__.MessageType.Error) {
          (_a = this.loggingService) === null || _a === void 0 ? void 0 : _a.log(this.actionName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__.Severity.Error, e.toString());
        }
      });
    }
  }
  /**
   * All concrete actions must override and implement this method. It is defined in the [Action] framework class.
   */
  validateActionResult() {
    var _a, _b, _c, _d;
    (_a = this.loggingService) === null || _a === void 0 ? void 0 : _a.log(this.actionName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__.Severity.Information, `Running [validateActionResult] for ${this.actionName}.`);
    // determine the status of the action based on any rule violations;
    if (this.validationContext.hasRuleViolations()) {
      (_b = this.loggingService) === null || _b === void 0 ? void 0 : _b.log(this.actionName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__.Severity.Error, `The ${this.actionName} contains rule violations.`);
      this.actionResult = _schema_driven_actions__WEBPACK_IMPORTED_MODULE_0__.ActionResult.Fail;
      const errorResponse = new _models_error_response_model__WEBPACK_IMPORTED_MODULE_4__.ErrorResponse();
      errorResponse.IsSuccess = false;
      errorResponse.Message = (_d = (_c = this.serviceContext.Messages[0]) === null || _c === void 0 ? void 0 : _c.Message) !== null && _d !== void 0 ? _d : 'Validation errors exist'; //'Validation errors exist'; // ;
      const errorData = {};
      this.serviceContext.Messages.forEach(e => {
        if (e.MessageType === _models_MessageType__WEBPACK_IMPORTED_MODULE_5__.MessageType.Error) {
          errorData[e.Name] = e.Message;
        }
      });
      errorResponse.Data = errorData;
      this.response = (0,rxjs__WEBPACK_IMPORTED_MODULE_9__.throwError)(errorResponse);
    }
    this.actionResult = this.serviceContext.isGood() ? _schema_driven_actions__WEBPACK_IMPORTED_MODULE_0__.ActionResult.Success : _schema_driven_actions__WEBPACK_IMPORTED_MODULE_0__.ActionResult.Fail;
    return this.actionResult;
  }
  /**
   * Use to process rule results for composite rules. Note, that this function is recursive
   * and will process all composite rules in the rule set contained in the ValidationContext.
   * @param ruleResult The result of a rendered rule.
   */
  retrieveRuleDetails(ruleResult) {
    if (ruleResult.rulePolicy instanceof _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_3__.CompositeRule) {
      const composite = ruleResult.rulePolicy;
      if (composite && composite.hasErrors) {
        const errors = composite.results.filter(result => !result.isValid && result.rulePolicy && result.rulePolicy.isDisplayable);
        errors.forEach(errorResult => {
          this.publishRuleResult(errorResult);
          if (errorResult.rulePolicy instanceof _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_3__.CompositeRule) {
            this.retrieveRuleDetails(errorResult);
          }
        });
      }
    }
  }
  /**
   * A helper function to publish a new [ServiceMessage] to the [ServiceContext.Messages] list.
   * @param ruleResult
   */
  publishRuleResult(ruleResult) {
    var _a;
    const serviceMessage = new _models_ServiceMessage__WEBPACK_IMPORTED_MODULE_7__.ServiceMessage(ruleResult.rulePolicy.name, ruleResult.rulePolicy.message, _models_MessageType__WEBPACK_IMPORTED_MODULE_5__.MessageType.Error);
    serviceMessage.DisplayToUser = ruleResult.rulePolicy.isDisplayable;
    serviceMessage.Source = this.actionName;
    this.serviceContext.Messages.push(serviceMessage);
    (_a = this.loggingService) === null || _a === void 0 ? void 0 : _a.log(this.actionName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_2__.Severity.Error, `${serviceMessage.toString()}`);
  }
}

/***/ }),

/***/ 467691:
/*!**********************************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/business-provider-base.service.ts ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BusinessProviderBase": () => (/* binding */ BusinessProviderBase)
/* harmony export */ });
/* harmony import */ var _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @schema-driven/logging */ 494391);
/* harmony import */ var _models_MessageType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models/MessageType */ 126500);
/* harmony import */ var _models_ServiceMessage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models/ServiceMessage */ 537171);



/**
 * Use the business provider base class to access common elements of the business provider.
 *
 * serviceContext: This is initialized for each instance of a business provider - its purpose is to collect information during the processing of business logic.
 */
class BusinessProviderBase {
  constructor(providerName, loggingService) {
    this.loggingService = loggingService;
    this.providerName = providerName;
    this.loggingService.log(this.providerName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Running constructor for the [${this.providerName}].`);
  }
  /**
   * Use to handle an unexpected error in the application. The error should implement
   * the specified interface. The method will add a new [ServiceMessage] to the
   * specified [ServiceContext].
   * @param error An unexpected application error that implements the [Error] interface.
   *
   * interface Error {
   *  name: string;
   *  message: string;
   *  stack?: string;
   * }
   */
  handleUnexpectedError(error) {
    const message = new _models_ServiceMessage__WEBPACK_IMPORTED_MODULE_2__.ServiceMessage(error.name, error.message).WithDisplayToUser(true).WithMessageType(_models_MessageType__WEBPACK_IMPORTED_MODULE_1__.MessageType.Error).WithSource(this.providerName);
    const logItem = `${message.toString()}; ${error.stack}`;
    this.loggingService.log(this.providerName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Error, logItem);
    this.serviceContext.addMessage(message);
  }
  finishRequest(sourceName) {
    this.loggingService.log(this.providerName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Request for [${sourceName}] by ${this.providerName} is complete.`);
    if (this.serviceContext.hasErrors()) {
      this.loggingService.log(this.providerName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Preparing to write out the errors.`);
      this.serviceContext.Messages.filter(f => f.DisplayToUser && f.MessageType === _models_MessageType__WEBPACK_IMPORTED_MODULE_1__.MessageType.Error).forEach(e => this.loggingService.log(this.providerName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Error, e.toString()));
    }
  }
}

/***/ }),

/***/ 136727:
/*!****************************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/component-base.component.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComponentBase": () => (/* binding */ ComponentBase)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tslib */ 570655);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/core */ 94650);
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/router */ 134793);
/* harmony import */ var _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @schema-driven/logging */ 494391);
/* harmony import */ var guid_typescript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! guid-typescript */ 653098);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ 596921);
/* harmony import */ var _models_alert_notification_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models/alert-notification.model */ 862360);
/* harmony import */ var _models_alert_types_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./models/alert-types.constants */ 587033);
/* harmony import */ var _models_error_response_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./models/error-response.model */ 342022);
/* harmony import */ var _models_MessageType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./models/MessageType */ 126500);

/* eslint-disable @typescript-eslint/no-explicit-any */









let ComponentBase = class ComponentBase {
  constructor(componentName, loggingService, router) {
    this.loggingService = loggingService;
    this.router = router;
    this.navSubscription = new rxjs__WEBPACK_IMPORTED_MODULE_6__.Subscription();
    this.id = guid_typescript__WEBPACK_IMPORTED_MODULE_1__.Guid.create();
    this.subscriptions = [];
    this.componentName = componentName;
    this.alertNotification = new _models_alert_notification_model__WEBPACK_IMPORTED_MODULE_2__.AlertNotification('', '');
    this.loggingService.log(this.componentName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Preparing to load [${this.componentName}] component.`, [`ComponentId:${this.id}`]);
  }
  /**
   * Add a subscription to the component
   * @param subscription
   */
  subscribe(subscription) {
    this.subscriptions.push(subscription);
  }
  /**
   * Unsubscribe to any registered subscriptions
   */
  ngOnDestroy() {
    this.subscriptions.forEach(sub => {
      if (sub && typeof sub.unsubscribe === 'function') {
        sub.unsubscribe();
      }
    });
  }
  /**
   * Use to set the URLs for when navigation ends. Provides the values
   * for the current and previous URL paths.
   * @param event Is a [NavigationEnd] type.
   */
  updateUrls(event) {
    if (event.urlAfterRedirects) {
      this.previousUrl = this.currentUrl;
      this.currentUrl = event.urlAfterRedirects;
    }
  }
  /**
   * Use to send an analytic event to [Google Analytics].
   * @param category A category is a name that you supply as a way to group objects that you want to track. Typically,
   * you will use the same category name multiple times over related UI elements that you want to group under a given category.
   * @param action Use the action parameter to name the type of event or interaction you want to track for a particular
   * web object (i.e., play, stop, pause, download). A unique event is determined by a unique action name. You can use
   * duplicate action names across categories, but this can affect how unique events are calculated. See the suggestions
   * below and the Implicit Count section for more details.
   * @param label Provide additional information for events that you want to track, such as the movie title in the
   * video examples above, or the name of a file when tracking downloads. All labels are listed independently from
   * their parent categories and actions. This provides you with another useful way to segment the event data for
   * your reports. All labels are listed independently from their parent categories and actions. This provides you
   * with another useful way to segment the event data for your reports.
   * @param value Any numeric value indicating a [value] that will be summarized for the analytic item(s).
   *
   * More information at: https://support.google.com/analytics/answer/1033068
   * or https://developers.google.com/analytics/devguides/collection/analyticsjs/events
   */
  googleAnalyticsSendEvent(category, action, label, value) {
    window.gtag('event', action, {
      event_category: category,
      event_label: label,
      value: value
    });
  }
  /**
   * Use to create a simple [ErrorResponse] with the specified message.
   * @param message The message to display to the user.
   */
  createErrorResponse(message) {
    this.loggingService.log(this.componentName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Preparing to create error response for component.`);
    const errorResponse = new _models_error_response_model__WEBPACK_IMPORTED_MODULE_4__.ErrorResponse();
    errorResponse.Message = message;
    return errorResponse;
  }
  /**
   * Use to handle service errors. These are error response [See: ErrorResponse] from
   * the application business layers (Action(s) or Http) that will bubble up to the
   * caller (i.e., a component) in a specified format:
   *
   * IsSuccess = false; // default for ErrorResponse
   * Message: string;
   * Errors: Array<ServiceError> = new Array<ServiceError>();
   * Exception: any;
   */
  handleServiceErrors(errorResponse, serviceContext) {
    this.loggingService.log(this.componentName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Preparing to handle service errors for component.`);
    if (serviceContext && serviceContext.hasErrors()) {
      this.loggingService.log(this.componentName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Retrieving error messages from the ServiceContext/ValidationContext;`);
      const messages = this.retrieveServiceContextErrorMessages(serviceContext);
      this.alertNotification = new _models_alert_notification_model__WEBPACK_IMPORTED_MODULE_2__.AlertNotification('Errors', errorResponse.Message, messages, _models_alert_types_constants__WEBPACK_IMPORTED_MODULE_3__.AlertTypes.Warning);
    } else {
      if (errorResponse && errorResponse.Message) {
        this.loggingService.log(this.componentName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Retrieving error messages from the [ErrorResponse].`);
        const errors = this.retrieveResponseErrorMessages(errorResponse);
        this.alertNotification = new _models_alert_notification_model__WEBPACK_IMPORTED_MODULE_2__.AlertNotification('Error', errorResponse.Message, errors, _models_alert_types_constants__WEBPACK_IMPORTED_MODULE_3__.AlertTypes.Warning);
        this.loggingService.log(this.componentName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Error, `Error: ${errorResponse.Message}`);
      }
    }
  }
  /**
   * Use to mark the form as touched; includes all form controls;
   */
  markFormAsTouched(form) {
    form.markAsTouched({
      onlySelf: false
    });
    Object.values(form.controls).forEach(control => {
      control.markAsTouched();
    });
  }
  /**
   * Use to log an unexpected error.
   */
  logError(error, message) {
    if (error instanceof Error) {
      this.loggingService.log(this.componentName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Error, message, [`${error.stack}`]);
    } else {
      this.loggingService.log(this.componentName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Error, message);
    }
  }
  /**
   * Use to retrieve the error messages from the specified [ServiceContext].
   *
   * @parm: serviceContext: A context object containing messages for the specified request.
   */
  retrieveServiceContextErrorMessages(serviceContext) {
    const messages = Array();
    serviceContext.Messages.forEach(e => {
      if (e.MessageType === _models_MessageType__WEBPACK_IMPORTED_MODULE_5__.MessageType.Error && e.DisplayToUser) {
        messages.push(e.Message);
      }
    });
    return messages;
  }
  /**
   * Use to retrieve the error messages from the specified Web API response.
   */
  retrieveResponseErrorMessages(errorResponse) {
    const errors = new Array();
    if (errorResponse && errorResponse.Errors) {
      errorResponse.Errors.forEach(e => {
        if (e.DisplayToUser) {
          errors.push(e.Message);
        }
      });
    }
    return errors;
  }
  /**
   * Use to reset the [AlertNotification] to the initial state. Removes
   * existing messages and hides the AlertComponent.
   */
  resetAlertNotifications() {
    this.alertNotification = new _models_alert_notification_model__WEBPACK_IMPORTED_MODULE_2__.AlertNotification('', '');
  }
  /**
   * Use to navigate to the specified route.
   * @parm routeName The name of the target route.
   */
  routeTo(routeName) {
    try {
      this.router.navigate([routeName]);
    } catch (error) {
      this.loggingService.log(this.componentName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Error, `Error while attempting to navigate to [${routeName}] route from ${this.componentName}. Error: ${error.message.toString()}`);
    }
  }
  /**
   * Use to retrieve and show any response error messages.
   */
  showResponseErrors(response) {
    this.handleServiceErrors(response, undefined);
  }
  finishRequest(message) {
    this.loggingService.log(this.componentName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `${this.componentName}: ${message}`);
  }
  showAlertMessage(message) {
    alert(message);
  }
};
ComponentBase = (0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject)({}), (0,tslib__WEBPACK_IMPORTED_MODULE_7__.__metadata)("design:paramtypes", [String, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.LoggingService, _angular_router__WEBPACK_IMPORTED_MODULE_9__.Router])], ComponentBase);


/***/ }),

/***/ 636063:
/*!*********************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/foundation.module.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FoundationModule": () => (/* binding */ FoundationModule)
/* harmony export */ });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ 836895);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 94650);


class FoundationModule {}
FoundationModule.ɵfac = function FoundationModule_Factory(t) {
  return new (t || FoundationModule)();
};
FoundationModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
  type: FoundationModule
});
FoundationModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
  imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]
});
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](FoundationModule, {
    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]
  });
})();

/***/ }),

/***/ 126500:
/*!**********************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/models/MessageType.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageType": () => (/* binding */ MessageType)
/* harmony export */ });
/**
 * Use to indicate the type for the [ServiceMessage].
 */
var MessageType;
(function (MessageType) {
  /**
   * Use to indicate the message type is informational.
   */
  MessageType[MessageType["Information"] = 1] = "Information";
  /**
   * Use to indicate the message type is warning.
   */
  MessageType[MessageType["Warning"] = 2] = "Warning";
  /**
   * Use to indicate the message type is error.
   */
  MessageType[MessageType["Error"] = 3] = "Error";
})(MessageType || (MessageType = {}));

/***/ }),

/***/ 933325:
/*!*************************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/models/ServiceContext.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ServiceContext": () => (/* binding */ ServiceContext)
/* harmony export */ });
/* harmony import */ var _MessageType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MessageType */ 126500);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 94650);


/**
 * Use this class to manage the context of a single service call. This
 * class will contain a list of any service messages added during the processing
 * of a service request.
 */
class ServiceContext {
  constructor() {
    /**
     * A list of service messages added by the application during the processing of the
     * specified service request.
     */
    this.Messages = new Array();
  }
  /**
   * Use this method to add a new message to the [ServiceContext].
   */
  addMessage(message) {
    this.Messages.push(message);
  }
  /**
   * Use to determine if the current [ServiceContext] contains any messages with type of [Error].
   */
  hasErrors() {
    if (this.Messages && this.Messages.length > 0) {
      const errorMessages = this.Messages.filter(f => f.MessageType === _MessageType__WEBPACK_IMPORTED_MODULE_0__.MessageType.Error);
      if (errorMessages.length > 0) {
        return true;
      }
    }
    return false;
  }
  /**
   * Use to determine if the current [ServiceContext] does not contain any errors.
   */
  isGood() {
    if (this.Messages && this.Messages.length > 0) {
      const errorMessages = this.Messages.filter(f => f.MessageType === _MessageType__WEBPACK_IMPORTED_MODULE_0__.MessageType.Error);
      if (errorMessages.length > 0) {
        return false;
      }
    }
    return true;
  }
}
ServiceContext.ɵfac = function ServiceContext_Factory(t) {
  return new (t || ServiceContext)();
};
ServiceContext.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
  token: ServiceContext,
  factory: ServiceContext.ɵfac,
  providedIn: 'root'
});

/***/ }),

/***/ 537171:
/*!*************************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/models/ServiceMessage.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ServiceMessage": () => (/* binding */ ServiceMessage)
/* harmony export */ });
/* harmony import */ var _MessageType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MessageType */ 126500);

/**
 * Use this class to create a message for the current [ServiceContext].
 */
class ServiceMessage {
  /**
   *
   * @param name The name of the message.
   * @param message The display text of the message.
   * @param messageType: Indicates the type of message.
   * @param source: Indicates the source of the message.
   * @param displayToUser Use to indicate if the specified message should be displayed to the user.
   */
  constructor(name, message, messageType, source, displayToUser = false) {
    /** Use to specify  */
    this.MessageType = _MessageType__WEBPACK_IMPORTED_MODULE_0__.MessageType.Information;
    /** Use to indicate the source of the message. */
    this.Source = '';
    /** Use to indicate if the specified message should be displayed to the user. */
    this.DisplayToUser = false;
    this.Name = name;
    this.Message = message;
    if (message) {
      this.MessageType = messageType;
    }
    if (source) {
      this.Source = source;
    }
    this.DisplayToUser = displayToUser;
  }
  /**
   * Use this extension method to add the name of the message.
   * @param name The name of the service message.
   */
  WithName(name) {
    this.Name = name;
    return this;
  }
  /**
   * Use this extension method to add the message text to the ServiceMessage item.
   * @param message The display text of the service message.
   */
  WithMessage(message) {
    this.Message = message;
    return this;
  }
  /**
   * Use this extension method to set the [MessageType] of the ServiceMessage item.
   * @param messageType: Use to indicate the message type.
   */
  WithMessageType(messageType) {
    this.MessageType = messageType;
    return this;
  }
  /**
   * Use this extension method to set the [Source] of the ServiceMessage item.
   * @param source: Use to indicate the source of the message.
   */
  WithSource(source) {
    this.Source = source;
    return this;
  }
  /**
   * Use this extension method to set the [DisplayToUser] indicator of the ServiceMessage.
   * @param displayToUser: A boolean value to indicate if the message can be displayed to the user.
   */
  WithDisplayToUser(displayToUser) {
    this.DisplayToUser = displayToUser;
    return this;
  }
  /**
   * Use this method return a string representing the ServiceMessage.
   */
  toString() {
    return `Name: ${this.Name}; Message: ${this.Message}; MessageType: ${this.MessageType.toString()}; Source: ${this.Source}; DisplayToUser: ${this.DisplayToUser}`;
  }
}

/***/ }),

/***/ 862360:
/*!***********************************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/models/alert-notification.model.ts ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlertNotification": () => (/* binding */ AlertNotification)
/* harmony export */ });
/* harmony import */ var _alert_types_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alert-types.constants */ 587033);

class AlertNotification {
  constructor(header, title, messages, type) {
    this.type = _alert_types_constants__WEBPACK_IMPORTED_MODULE_0__.AlertTypes.Information; // alert-warning, alert-success, alert-info, alert-danger
    this.messages = new Array();
    this.showAlert = false;
    if (type) {
      this.type = type;
    }
    this.header = header;
    this.title = title;
    if (messages) {
      this.messages = messages;
    }
    if (this.header && this.title) {
      this.showAlert = true; // used to trigger the display of the notification.
    }
  }
}

/***/ }),

/***/ 587033:
/*!********************************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/models/alert-types.constants.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlertTypes": () => (/* binding */ AlertTypes)
/* harmony export */ });
/**
 * Use to provide the alert type information for the AlertNotification and AlertComponent.
 */
class AlertTypes {}
AlertTypes.Information = 'alert-info';
AlertTypes.Warning = 'alert-warning';
AlertTypes.Danger = 'alert-danger';
AlertTypes.Success = 'alert-success';

/***/ }),

/***/ 342022:
/*!*******************************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/models/error-response.model.ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorResponse": () => (/* binding */ ErrorResponse)
/* harmony export */ });
/* harmony import */ var _service_response_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./service-response.model */ 34117);

class ErrorResponse extends _service_response_model__WEBPACK_IMPORTED_MODULE_0__.ServiceResponse {
  constructor() {
    super();
    this.IsSuccess = false;
  }
}

/***/ }),

/***/ 973342:
/*!******************************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/models/service-error.model.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ServiceError": () => (/* binding */ ServiceError)
/* harmony export */ });
/**
 * Use this model to represent service error/message information from the
 * application's service APIs.
 *
 * The DisplayToUser boolean value indicates whether the message should be
 * displayed to the user if desired.
 */
class ServiceError {}

/***/ }),

/***/ 34117:
/*!*********************************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/models/service-response.model.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ServiceResponse": () => (/* binding */ ServiceResponse)
/* harmony export */ });
class ServiceResponse {
  constructor() {
    this.Errors = new Array();
  }
}

/***/ }),

/***/ 225162:
/*!****************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/service-base.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ServiceBase": () => (/* binding */ ServiceBase)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tslib */ 570655);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/core */ 94650);
/* harmony import */ var _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @schema-driven/logging */ 494391);
/* harmony import */ var guid_typescript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! guid-typescript */ 653098);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ 439646);
/* harmony import */ var _models_error_response_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models/error-response.model */ 342022);
/* harmony import */ var _models_MessageType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./models/MessageType */ 126500);
/* harmony import */ var _models_ServiceContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./models/ServiceContext */ 933325);
/* harmony import */ var _models_ServiceMessage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./models/ServiceMessage */ 537171);









/**
 * Use the [ServiceBase] to provide common behavior for Angular
 * services.
 */
let ServiceBase = class ServiceBase {
  /**
   * Use the constructor to provide required elements to the base class.
   *
   * @param loggingService The [LoggingService] is a required dependency of this
   * class. It should be injected into any Angular Services that extend from
   * this base class. It will allow the members of the base class to log information
   * using the common LoggingService.
   */
  constructor(serviceName, loggingService, serviceContext) {
    this.serviceName = serviceName;
    this.loggingService = loggingService;
    this.serviceContext = serviceContext;
    this.accessToken = '';
    this.id = guid_typescript__WEBPACK_IMPORTED_MODULE_1__.Guid.create().toString();
    this.subscriptions = [];
    this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Initializing ${this.serviceName} at ${Date.now()} with id: ${this.id}`);
  }
  /**
   * Use to extract the contents of the HTTP body and return a JSON
   * representation of the data.
   * @param response: contains the HTTP response.
   */
  extractData(response) {
    const body = response.json();
    return body || {};
  }
  /**
   * Use to handle an unexpected error in the application. The error should implement
   * the specified interface. The method will add a new [ServiceMessage] to the
   * specified [ServiceContext].
   * @param error An unexpected application error that implements the [Error] interface.
   *
   * interface Error {
   *  name: string;
   *  message: string;
   *  stack?: string;
   * }
   */
  handleUnexpectedError(error) {
    const message = new _models_ServiceMessage__WEBPACK_IMPORTED_MODULE_5__.ServiceMessage(error.name, error.message).WithDisplayToUser(false).WithMessageType(_models_MessageType__WEBPACK_IMPORTED_MODULE_3__.MessageType.Error).WithSource(this.serviceName);
    const tags = [`${this.serviceName}`];
    const logItem = `${message.toString()}; ${error.stack}`;
    this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Error, logItem, tags);
    this.serviceContext.addMessage(message);
  }
  /**
   * Use to handle an error that contains a [name] and a [message].
   * @param error
   */
  handleError(error) {
    const message = new _models_ServiceMessage__WEBPACK_IMPORTED_MODULE_5__.ServiceMessage(error.name, error.message).WithDisplayToUser(false).WithMessageType(_models_MessageType__WEBPACK_IMPORTED_MODULE_3__.MessageType.Error).WithSource(this.serviceName);
    const tags = [`${this.serviceName}`];
    this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Error, message.toString(), tags);
    this.serviceContext.addMessage(message);
  }
  /**
   * Use to create a new [ErrorResponse] with the specified message.
   * @param message The message for the specified [ErrorResponse].
   */
  createErrorResponse(message) {
    const response = new _models_error_response_model__WEBPACK_IMPORTED_MODULE_2__.ErrorResponse();
    response.Message = message;
    return response;
  }
  /**
   * Use to create a API Response.
   *
   * @param message a simple message related to the operation (not for user notifications).
   * @param data the data payload (if any) for the response.
   * @returns Observable<ApiResponse<T>>
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  createAPIResponse(message, data, isSuccess = true) {
    const response = {
      id: guid_typescript__WEBPACK_IMPORTED_MODULE_1__.Guid.create().toString(),
      isSuccess: isSuccess,
      data: data,
      message,
      messages: [],
      timestamp: new Date()
    };
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.of)(response);
  }
  /**
   * Use a generic method to finish service requests that return [Observables].
   * @param sourceName
   */
  finishRequest(sourceName) {
    this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Request for [${sourceName}] by ${this.serviceName} is complete.`);
    if (this.serviceContext.hasErrors()) {
      this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Preparing to write any messages.`);
      this.serviceContext.Messages.filter(f => f.MessageType === _models_MessageType__WEBPACK_IMPORTED_MODULE_3__.MessageType.Error && f.DisplayToUser).forEach(e => this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Error, e.toString()));
    }
  }
  logError(error, errorMessage) {
    this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Error, `${errorMessage}; Error: ${error.message}`);
  }
  ngOnDestroy() {
    this.unsubscribeAllSubscriptions();
  }
  /**
   * Use to reset the service context when you want to clear messages from the [ServiceContext]. If you want to
   * append messages from subsequent service calls, do not use this method.
   */
  resetServiceContext() {
    this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Preparing to reset the Messages of the current [ServiceContext].`);
    if (this.serviceContext && this.serviceContext.Messages) {
      if (this.serviceContext.Messages.length > 0) {
        this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Resetting the Messages of the current [ServiceContext].`);
        this.serviceContext.Messages = new Array();
      } else {
        this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `The current [ServiceContext] does not contain any [Messages].`);
      }
    } else {
      this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Warning, `The current [ServiceContext] is not valid.`);
    }
    this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Information, `Finished  processing request to [reset] the Messages of the current [ServiceContext].`);
  }
  /**
   * Register a Subscription
   * @param subscription
   */
  subscribe(subscription) {
    this.subscriptions.push(subscription);
  }
  /**
   * Unsubscribe all Subjections
   */
  unsubscribeAllSubscriptions() {
    this.subscriptions.forEach(sub => {
      if (sub && typeof sub.unsubscribe === 'function') {
        sub.unsubscribe();
      }
    });
  }
  /**
   * Use to write the current messages contained in the [ServiceContext]. Written messages are limited
   * to items that are marked as [DisplayToUser = true].
   */
  writeMessages() {
    if (this.serviceContext && this.serviceContext.Messages) {
      this.serviceContext.Messages.forEach(e => {
        if (e.MessageType === _models_MessageType__WEBPACK_IMPORTED_MODULE_3__.MessageType.Error && e.DisplayToUser) {
          this.loggingService.log(this.serviceName, _schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.Severity.Error, e.toString());
        }
      });
    }
  }
};
ServiceBase = (0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject)({}), (0,tslib__WEBPACK_IMPORTED_MODULE_7__.__param)(1, (0,_angular_core__WEBPACK_IMPORTED_MODULE_8__.Inject)(_schema_driven_logging__WEBPACK_IMPORTED_MODULE_0__.LoggingService)), (0,tslib__WEBPACK_IMPORTED_MODULE_7__.__metadata)("design:paramtypes", [String, Object, _models_ServiceContext__WEBPACK_IMPORTED_MODULE_4__.ServiceContext])], ServiceBase);


/***/ }),

/***/ 848011:
/*!**************************************************************************!*\
  !*** ./libs/business-logic/foundation/src/lib/singleton-service-base.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SingletonServiceBase": () => (/* binding */ SingletonServiceBase)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 94650);
/* harmony import */ var _service_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./service-base */ 225162);


class SingletonServiceBase extends _service_base__WEBPACK_IMPORTED_MODULE_0__.ServiceBase {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(type, loggingService, serviceName, serviceContext) {
    super(serviceName, loggingService, serviceContext);
    // eslint-disable-next-line no-bitwise
    const parent = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(type, _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectFlags.Optional | _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectFlags.SkipSelf);
    if (parent) {
      throw Error(`Cannot create multiple instances of provider: [${type}]`);
    }
  }
}

/***/ }),

/***/ 494391:
/*!**************************************************!*\
  !*** ./libs/business-logic/logging/src/index.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConsoleWriter": () => (/* reexport safe */ _lib_log_writers_console_writer__WEBPACK_IMPORTED_MODULE_0__.ConsoleWriter),
/* harmony export */   "DataDogOptions": () => (/* reexport safe */ _lib_data_dog_options__WEBPACK_IMPORTED_MODULE_1__.DataDogOptions),
/* harmony export */   "DataDogWriterService": () => (/* reexport safe */ _lib_log_writers_data_dog_writer_service__WEBPACK_IMPORTED_MODULE_2__.DataDogWriterService),
/* harmony export */   "LogEntry": () => (/* reexport safe */ _lib_log_entry__WEBPACK_IMPORTED_MODULE_3__.LogEntry),
/* harmony export */   "LogWriter": () => (/* reexport safe */ _lib_log_writers_log_writer__WEBPACK_IMPORTED_MODULE_8__.LogWriter),
/* harmony export */   "LoggingConfig": () => (/* reexport safe */ _lib_logging_config__WEBPACK_IMPORTED_MODULE_10__.LoggingConfig),
/* harmony export */   "LoggingModule": () => (/* reexport safe */ _lib_logging_module__WEBPACK_IMPORTED_MODULE_4__.LoggingModule),
/* harmony export */   "LoggingService": () => (/* reexport safe */ _lib_logging_service__WEBPACK_IMPORTED_MODULE_5__.LoggingService),
/* harmony export */   "LoggingServiceConfig": () => (/* reexport safe */ _lib_logging_service_config__WEBPACK_IMPORTED_MODULE_6__.LoggingServiceConfig),
/* harmony export */   "LoggingServiceMock": () => (/* reexport safe */ _lib_logging_service_mock__WEBPACK_IMPORTED_MODULE_7__.LoggingServiceMock),
/* harmony export */   "Severity": () => (/* reexport safe */ _lib_severity_enum__WEBPACK_IMPORTED_MODULE_9__.Severity)
/* harmony export */ });
/* harmony import */ var _lib_log_writers_console_writer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/log-writers/console-writer */ 90375);
/* harmony import */ var _lib_data_dog_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/data-dog-options */ 432095);
/* harmony import */ var _lib_log_writers_data_dog_writer_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/log-writers/data-dog-writer.service */ 652633);
/* harmony import */ var _lib_log_entry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/log-entry */ 378409);
/* harmony import */ var _lib_logging_module__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/logging.module */ 273926);
/* harmony import */ var _lib_logging_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/logging.service */ 9076);
/* harmony import */ var _lib_logging_service_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/logging.service.config */ 390272);
/* harmony import */ var _lib_logging_service_mock__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/logging.service.mock */ 305569);
/* harmony import */ var _lib_log_writers_log_writer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/log-writers/log-writer */ 16058);
/* harmony import */ var _lib_severity_enum__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/severity.enum */ 121157);
/* harmony import */ var _lib_logging_config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/logging-config */ 910303);












/***/ }),

/***/ 432095:
/*!*****************************************************************!*\
  !*** ./libs/business-logic/logging/src/lib/data-dog-options.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataDogOptions": () => (/* binding */ DataDogOptions)
/* harmony export */ });
class DataDogOptions {}

/***/ }),

/***/ 378409:
/*!**********************************************************!*\
  !*** ./libs/business-logic/logging/src/lib/log-entry.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LogEntry": () => (/* binding */ LogEntry)
/* harmony export */ });
class LogEntry {
  constructor(application, source, severity, message, tags) {
    this.application = application;
    this.source = source;
    this.severity = severity;
    this.message = message;
    this.timestamp = new Date(Date.now());
    this.tags = tags;
  }
}

/***/ }),

/***/ 90375:
/*!***************************************************************************!*\
  !*** ./libs/business-logic/logging/src/lib/log-writers/console-writer.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConsoleWriter": () => (/* binding */ ConsoleWriter)
/* harmony export */ });
/* harmony import */ var _log_writer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log-writer */ 16058);
/* harmony import */ var _logging_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logging.service */ 9076);
/* harmony import */ var _severity_enum__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../severity.enum */ 121157);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 725032);
/* harmony import */ var _logging_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logging-config */ 910303);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/core */ 94650);








/**
 * Use this writer to log information to the browser console.
 */
class ConsoleWriter extends _log_writer__WEBPACK_IMPORTED_MODULE_0__.LogWriter {
  constructor(loggingService, loggingConfig) {
    super();
    this.loggingService = loggingService;
    this.loggingConfig = loggingConfig;
    if (this.loggingConfig.isProduction === false) {
      this.loggingService.logEntries$.subscribe(logEntry => this.handleLogEntry(logEntry));
    }
  }
  handleLogEntry(logEntry) {
    this.targetEntry = logEntry;
    this.execute();
  }
  /**
   * No setup required for the console writer.
   */
  setup() {
    (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.noop)();
  }
  /**
   * Implementation of the abstract method. This will perform the
   * actual `write` action for the specified writer.
   */
  write() {
    switch (this.targetEntry.severity) {
      /* eslint-disable no-restricted-syntax */
      /* eslint-disable no-console */
      case _severity_enum__WEBPACK_IMPORTED_MODULE_2__.Severity.Debug:
        console.debug(this.targetEntry);
        break;
      case _severity_enum__WEBPACK_IMPORTED_MODULE_2__.Severity.Information:
        console.info(this.targetEntry);
        break;
      case _severity_enum__WEBPACK_IMPORTED_MODULE_2__.Severity.Warning:
        console.warn(this.targetEntry);
        break;
      case _severity_enum__WEBPACK_IMPORTED_MODULE_2__.Severity.Error:
        console.error(this.targetEntry);
        break;
      case _severity_enum__WEBPACK_IMPORTED_MODULE_2__.Severity.Critical:
        console.error(this.targetEntry);
        break;
      default:
        break;
      /* eslint-enable no-restricted-syntax */
      /* eslint-enable no-console */
    }
  }
}

ConsoleWriter.ɵfac = function ConsoleWriter_Factory(t) {
  return new (t || ConsoleWriter)(_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵinject"](_logging_service__WEBPACK_IMPORTED_MODULE_1__.LoggingService), _angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵinject"](_logging_config__WEBPACK_IMPORTED_MODULE_3__.LoggingConfig));
};
ConsoleWriter.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineInjectable"]({
  token: ConsoleWriter,
  factory: ConsoleWriter.ɵfac
});

/***/ }),

/***/ 652633:
/*!************************************************************************************!*\
  !*** ./libs/business-logic/logging/src/lib/log-writers/data-dog-writer.service.ts ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataDogWriterService": () => (/* binding */ DataDogWriterService)
/* harmony export */ });
/* harmony import */ var _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datadog/browser-logs */ 377480);
/* harmony import */ var _datadog_browser_rum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datadog/browser-rum */ 262886);
/* harmony import */ var _data_dog_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data-dog-options */ 432095);
/* harmony import */ var _logging_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logging.service */ 9076);
/* harmony import */ var _severity_enum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../severity.enum */ 121157);
/* harmony import */ var _log_writer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./log-writer */ 16058);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/core */ 94650);









class DataDogWriterService extends _log_writer__WEBPACK_IMPORTED_MODULE_5__.LogWriter {
  constructor(options, loggingService) {
    super();
    this.options = options;
    this.loggingService = loggingService;
    this.initialize();
  }
  initialize() {
    if (this.options && this.loggingService) {
      this.loggingService.logEntries$.subscribe(entry => this.handleLogEntry(entry));
    } else {
      throw new Error(`Failed to initialize error handler for application. Please verify DataDog options.`);
    }
  }
  handleLogEntry(entry) {
    if (this.hasWriter) {
      this.targetEntry = entry;
      this.execute();
    }
  }
  handleSettings() {
    if (this.options) {
      this.hasWriter = true;
      console.log(`Initializing [DataDog] writer for logging.`);
      /**
       * Use to initialize client-browser log transfer to DataDog;
       */
      _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__.datadogLogs.init({
        clientToken: this.options.logs.clientToken,
        site: this.options.logs.site,
        forwardErrorsToLogs: this.options.logs.forwardErrorsToLogs,
        sampleRate: this.options.logs.sampleRate
      });
      /**
       * Note: The trackInteractions initialization parameter enables the automatic collection of user
       * clicks in your application.Sensitive and private data contained on your pages may be included to
       * identify the elements interacted with.
       *
       * version: Specify a version number to identify the deployed version of your application in Datadog
       */
      _datadog_browser_rum__WEBPACK_IMPORTED_MODULE_1__.datadogRum.init({
        applicationId: this.options.realUserMonitoring.applicationId,
        clientToken: this.options.realUserMonitoring.clientToken,
        site: this.options.realUserMonitoring.site,
        service: this.options.realUserMonitoring.service,
        env: this.options.realUserMonitoring.env,
        // Specify a version number to identify the deployed version of your application in Datadog
        version: this.options.realUserMonitoring.version,
        sampleRate: this.options.realUserMonitoring.sampleRate,
        trackInteractions: this.options.realUserMonitoring.trackInteractions
      });
    }
  }
  /**
   * Use to perform an setup or configuration of the [writer].
   * The [setup] method runs on all executions of the writer - and
   * is called before the [write] method.
   */
  setup() {
    var _a, _b;
    if (this.hasWriter && this.options && this.targetEntry) {
      try {
        // FIXME: DO WE NEED TO SOMETHING HERE? Nope.
      } catch (error) {
        if (error && error instanceof Error) {
          const message = `${this.targetEntry.application}.DataDogWriter: ${(_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : ''}, ${(_b = error === null || error === void 0 ? void 0 : error.stack) !== null && _b !== void 0 ? _b : error.stack}`;
          console.error(message);
        }
      }
    }
  }
  /**
   * Use to implement the actual write of the [Log Entry].
   */
  write() {
    if (this.targetEntry) {
      switch (this.targetEntry.severity) {
        case _severity_enum__WEBPACK_IMPORTED_MODULE_4__.Severity.Information:
          _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__.datadogLogs.logger.info(this.targetEntry.application, Object.assign({}, this.targetEntry));
          break;
        case _severity_enum__WEBPACK_IMPORTED_MODULE_4__.Severity.Warning:
          _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__.datadogLogs.logger.warn(this.targetEntry.application, Object.assign({}, this.targetEntry));
          break;
        case _severity_enum__WEBPACK_IMPORTED_MODULE_4__.Severity.Error:
          _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__.datadogLogs.logger.error(this.targetEntry.application, Object.assign({}, this.targetEntry));
          break;
        case _severity_enum__WEBPACK_IMPORTED_MODULE_4__.Severity.Critical:
          _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__.datadogLogs.logger.error(this.targetEntry.application, Object.assign({}, this.targetEntry));
          break;
        case _severity_enum__WEBPACK_IMPORTED_MODULE_4__.Severity.Debug:
          _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__.datadogLogs.logger.info(this.targetEntry.application, Object.assign({}, this.targetEntry));
          break;
        default:
          _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__.datadogLogs.logger.info(this.targetEntry.application, Object.assign({}, this.targetEntry));
      }
    }
  }
}
DataDogWriterService.ɵfac = function DataDogWriterService_Factory(t) {
  return new (t || DataDogWriterService)(_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵinject"](_data_dog_options__WEBPACK_IMPORTED_MODULE_2__.DataDogOptions, 8), _angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵinject"](_logging_service__WEBPACK_IMPORTED_MODULE_3__.LoggingService));
};
DataDogWriterService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_6__["ɵɵdefineInjectable"]({
  token: DataDogWriterService,
  factory: DataDogWriterService.ɵfac,
  providedIn: 'root'
});

/***/ }),

/***/ 16058:
/*!***********************************************************************!*\
  !*** ./libs/business-logic/logging/src/lib/log-writers/log-writer.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LogWriter": () => (/* binding */ LogWriter)
/* harmony export */ });
/* harmony import */ var _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @schema-driven/rules-engine */ 266710);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ 725032);


class LogWriter {
  /**
   * Use this method to execute the write process for the
   * specified [Log Entry] item.
   *
   * Using the [template method] design pattern.
   */
  execute() {
    this.setup();
    if (this.validateEntry()) {
      this.write();
    }
    this.finish();
  }
  /**
   * Use to validate the [log entry] before attempting to write
   * using the specified [log writer].
   *
   * Returns a [false] boolean to indicate the item is not valid.
   */
  validateEntry() {
    const validationContext = new _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__.ValidationContext();
    validationContext.addRule(new _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__.IsTrue('LogWriterExists', 'The log writer is not configured.', this.hasWriter));
    validationContext.addRule(new _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__.IsNotNullOrUndefined('EntryIsNotNull', 'The entry cannot be null.', this.targetEntry));
    validationContext.addRule(new _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__.StringIsNotNullEmptyRange('SourceIsRequired', 'The entry source is not valid.', this.targetEntry.source, 1, 100));
    validationContext.addRule(new _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__.StringIsNotNullEmptyRange('MessageIsValid', 'The message is required for the [Log Entry].', this.targetEntry.message, 1, 2000));
    validationContext.addRule(new _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__.IsNotNullOrUndefined('TimestampIsRequired', 'The timestamp must be a valid DateTime value.', this.targetEntry.timestamp));
    return validationContext.renderRules().isValid;
  }
  /**
   * Use to finish the process or clean-up any resources.
   */
  finish() {
    (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.noop)();
  }
}

/***/ }),

/***/ 910303:
/*!***************************************************************!*\
  !*** ./libs/business-logic/logging/src/lib/logging-config.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoggingConfig": () => (/* binding */ LoggingConfig)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 94650);

class LoggingConfig {
  constructor() {
    this.isProduction = false;
  }
}
LoggingConfig.ɵfac = function LoggingConfig_Factory(t) {
  return new (t || LoggingConfig)();
};
LoggingConfig.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
  token: LoggingConfig,
  factory: LoggingConfig.ɵfac
});

/***/ }),

/***/ 273926:
/*!***************************************************************!*\
  !*** ./libs/business-logic/logging/src/lib/logging.module.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoggingModule": () => (/* binding */ LoggingModule)
/* harmony export */ });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ 836895);
/* harmony import */ var _data_dog_options__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-dog-options */ 432095);
/* harmony import */ var _logging_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logging-config */ 910303);
/* harmony import */ var _logging_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging.service */ 9076);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ 94650);






class LoggingModule {
  static forRoot(options, loggingConfig) {
    return {
      ngModule: LoggingModule,
      providers: [{
        provide: _data_dog_options__WEBPACK_IMPORTED_MODULE_0__.DataDogOptions,
        useValue: options
      }, {
        provide: _logging_config__WEBPACK_IMPORTED_MODULE_1__.LoggingConfig,
        useValue: loggingConfig
      }, _logging_service__WEBPACK_IMPORTED_MODULE_2__.LoggingService]
    };
  }
}
LoggingModule.ɵfac = function LoggingModule_Factory(t) {
  return new (t || LoggingModule)();
};
LoggingModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineNgModule"]({
  type: LoggingModule
});
LoggingModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjector"]({
  imports: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.CommonModule]
});
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵsetNgModuleScope"](LoggingModule, {
    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.CommonModule]
  });
})();

/***/ }),

/***/ 390272:
/*!***********************************************************************!*\
  !*** ./libs/business-logic/logging/src/lib/logging.service.config.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoggingServiceConfig": () => (/* binding */ LoggingServiceConfig)
/* harmony export */ });
class LoggingServiceConfig {
  constructor() {
    this.applicationName = 'APP_NAME_NOT_PROVIDED';
  }
}

/***/ }),

/***/ 305569:
/*!*********************************************************************!*\
  !*** ./libs/business-logic/logging/src/lib/logging.service.mock.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoggingServiceMock": () => (/* binding */ LoggingServiceMock)
/* harmony export */ });
/* harmony import */ var guid_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! guid-typescript */ 653098);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ 746758);
/* harmony import */ var _severity_enum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./severity.enum */ 121157);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ 94650);




class LoggingServiceMock {
  constructor() {
    this.applicationName = 'application';
    this.id = guid_typescript__WEBPACK_IMPORTED_MODULE_0__.Guid.create();
    this.logEntries$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
    this.serviceName = 'LoggingServiceMock';
    this.version = '0.0.0';
  }
  setupConfiguration(settings) {
    if (settings) {
      this.log(this.serviceName, _severity_enum__WEBPACK_IMPORTED_MODULE_1__.Severity.Information, `Logging for [${settings.applicationName}].`);
    }
    this.isProduction = false;
  }
  log(source, severity, message) {
    this.source = source;
    this.severity = severity;
    this.message = message;
  }
}
LoggingServiceMock.ɵfac = function LoggingServiceMock_Factory(t) {
  return new (t || LoggingServiceMock)();
};
LoggingServiceMock.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"]({
  token: LoggingServiceMock,
  factory: LoggingServiceMock.ɵfac
});

/***/ }),

/***/ 9076:
/*!****************************************************************!*\
  !*** ./libs/business-logic/logging/src/lib/logging.service.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoggingService": () => (/* binding */ LoggingService)
/* harmony export */ });
/* harmony import */ var guid_typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! guid-typescript */ 653098);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ 604707);
/* harmony import */ var _log_entry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log-entry */ 378409);
/* harmony import */ var _logging_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logging-config */ 910303);
/* harmony import */ var _severity_enum__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./severity.enum */ 121157);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/core */ 94650);







class LoggingService {
  /**
   * The [LoggingService] constructor.
   */
  constructor(loggingConfig) {
    this.loggingConfig = loggingConfig;
    this.serviceName = 'LoggingService';
    this.timestamp = new Date();
    this.id = guid_typescript__WEBPACK_IMPORTED_MODULE_0__.Guid.create();
    this.logEntriesSubject = new rxjs__WEBPACK_IMPORTED_MODULE_4__.ReplaySubject(1);
    this.logEntries$ = this.logEntriesSubject.asObservable();
    this.log(this.serviceName, _severity_enum__WEBPACK_IMPORTED_MODULE_3__.Severity.Information, `Starting logging service [${this.id.toString()}] at: ${this.timestamp}`);
    this.initializeService(loggingConfig);
  }
  /**
   * Use to initialize the logging service. Retrieves
   * application configuration settings.
   *
   * @param configService contains the configuration settings for the application
   */
  initializeService(loggingConfig) {
    if (loggingConfig) {
      this.isProduction = this.loggingConfig.isProduction;
      this.applicationName = this.loggingConfig.applicationName ? this.loggingConfig.applicationName : 'Angular';
    }
  }
  /**
   * Use to handle settings from the configuration service.
   * @param settings
   */
  handleSettings(settings) {
    if (!settings) {
      throw new Error('The logging service configuration is not valid. Cannot initialize - you can do better, really.');
    }
  }
  /**
   * Use this method to send a log message with severity and source information
   * to the application's logger.
   *
   * If the application environment mode is [Production], the information will
   * be sent to a centralized repository.
   *
   * @param source
   * @param severity
   * @param message
   */
  log(source, severity, message, tags) {
    this.source = this.applicationName !== source ? `${this.applicationName}.${source}` : this.applicationName;
    this.severity = severity;
    this.message = message;
    this.timestamp = new Date();
    if (tags) {
      tags.push(`LoggerId:${this.id.toString()}`);
    } else {
      tags = [`LoggerId:${this.id.toString()}`];
    }
    const logEntry = new _log_entry__WEBPACK_IMPORTED_MODULE_1__.LogEntry(this.applicationName, this.source, this.severity, this.message, tags);
    this.logEntriesSubject.next(logEntry);
  }
}
LoggingService.ɵfac = function LoggingService_Factory(t) {
  return new (t || LoggingService)(_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵinject"](_logging_config__WEBPACK_IMPORTED_MODULE_2__.LoggingConfig, 8));
};
LoggingService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineInjectable"]({
  token: LoggingService,
  factory: LoggingService.ɵfac,
  providedIn: 'root'
});

/***/ }),

/***/ 121157:
/*!**************************************************************!*\
  !*** ./libs/business-logic/logging/src/lib/severity.enum.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Severity": () => (/* binding */ Severity)
/* harmony export */ });
var Severity;
(function (Severity) {
  Severity["Information"] = "Information";
  Severity["Warning"] = "Warning";
  Severity["Error"] = "Error";
  Severity["Critical"] = "Critical";
  Severity["Debug"] = "Debug";
})(Severity || (Severity = {}));

/***/ }),

/***/ 266710:
/*!*******************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/index.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AreEqual": () => (/* reexport safe */ _lib_rules_AreEqual__WEBPACK_IMPORTED_MODULE_0__.AreEqual),
/* harmony export */   "AreNotEqual": () => (/* reexport safe */ _lib_rules_AreNotEqual__WEBPACK_IMPORTED_MODULE_1__.AreNotEqual),
/* harmony export */   "CellIdIsValidRule": () => (/* reexport safe */ _lib_rules_CellIdIsValid__WEBPACK_IMPORTED_MODULE_28__.CellIdIsValidRule),
/* harmony export */   "CompareDatesLessRule": () => (/* reexport safe */ _lib_rules_compareDatesLessRule__WEBPACK_IMPORTED_MODULE_31__.CompareDatesLessRule),
/* harmony export */   "CompositeRule": () => (/* reexport safe */ _lib_rules_CompositeRule__WEBPACK_IMPORTED_MODULE_2__.CompositeRule),
/* harmony export */   "DateIsGreaterThanComparisonDate": () => (/* reexport safe */ _lib_rules_DateIsGreaterThanComparisonDate__WEBPACK_IMPORTED_MODULE_3__.DateIsGreaterThanComparisonDate),
/* harmony export */   "Enum": () => (/* reexport safe */ _lib_rules_Enum__WEBPACK_IMPORTED_MODULE_4__.Enum),
/* harmony export */   "GuidIsValid": () => (/* reexport safe */ _lib_rules_GuidIsValid__WEBPACK_IMPORTED_MODULE_5__.GuidIsValid),
/* harmony export */   "ImportDuplicateRule": () => (/* reexport safe */ _lib_rules_import_duplicate_rule__WEBPACK_IMPORTED_MODULE_30__.ImportDuplicateRule),
/* harmony export */   "ImportRowHasRequiredFields": () => (/* reexport safe */ _lib_rules_ImportRowHasRequiredFields__WEBPACK_IMPORTED_MODULE_19__.ImportRowHasRequiredFields),
/* harmony export */   "ImportSolutionRule": () => (/* reexport safe */ _lib_rules_import_solution_rule__WEBPACK_IMPORTED_MODULE_29__.ImportSolutionRule),
/* harmony export */   "IsExcelFile": () => (/* reexport safe */ _lib_rules_IsExcelFile__WEBPACK_IMPORTED_MODULE_6__.IsExcelFile),
/* harmony export */   "IsFalse": () => (/* reexport safe */ _lib_rules_IsFalse__WEBPACK_IMPORTED_MODULE_7__.IsFalse),
/* harmony export */   "IsNotNullOrUndefined": () => (/* reexport safe */ _lib_rules_IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_8__.IsNotNullOrUndefined),
/* harmony export */   "IsNullOrUndefined": () => (/* reexport safe */ _lib_rules_IsNullOrUndefined__WEBPACK_IMPORTED_MODULE_9__.IsNullOrUndefined),
/* harmony export */   "IsNumber": () => (/* reexport safe */ _lib_rules_IsNumber__WEBPACK_IMPORTED_MODULE_10__.IsNumber),
/* harmony export */   "IsTrue": () => (/* reexport safe */ _lib_rules_IsTrue__WEBPACK_IMPORTED_MODULE_11__.IsTrue),
/* harmony export */   "Max": () => (/* reexport safe */ _lib_rules_Max__WEBPACK_IMPORTED_MODULE_12__.Max),
/* harmony export */   "Min": () => (/* reexport safe */ _lib_rules_Min__WEBPACK_IMPORTED_MODULE_13__.Min),
/* harmony export */   "Range": () => (/* reexport safe */ _lib_rules_Range__WEBPACK_IMPORTED_MODULE_14__.Range),
/* harmony export */   "RenderType": () => (/* reexport safe */ _lib_rules_RenderType__WEBPACK_IMPORTED_MODULE_15__.RenderType),
/* harmony export */   "RuleConstants": () => (/* reexport safe */ _lib_rule_constants__WEBPACK_IMPORTED_MODULE_16__.RuleConstants),
/* harmony export */   "RulePolicy": () => (/* reexport safe */ _lib_rules_RulePolicy__WEBPACK_IMPORTED_MODULE_17__.RulePolicy),
/* harmony export */   "RuleResult": () => (/* reexport safe */ _lib_rules_RuleResult__WEBPACK_IMPORTED_MODULE_18__.RuleResult),
/* harmony export */   "Severity": () => (/* reexport safe */ _lib_rules_Severity__WEBPACK_IMPORTED_MODULE_20__.Severity),
/* harmony export */   "SimpleRule": () => (/* reexport safe */ _lib_rules_SimpleRule__WEBPACK_IMPORTED_MODULE_21__.SimpleRule),
/* harmony export */   "StringIsNotNullEmptyRange": () => (/* reexport safe */ _lib_rules_StringIsNotNullEmptyRange__WEBPACK_IMPORTED_MODULE_22__.StringIsNotNullEmptyRange),
/* harmony export */   "StringIsRegExArrayMatch": () => (/* reexport safe */ _lib_rules_StringIsRegExArrayMatch__WEBPACK_IMPORTED_MODULE_23__.StringIsRegExArrayMatch),
/* harmony export */   "StringIsRegExMatch": () => (/* reexport safe */ _lib_rules_StringIsRegExMatch__WEBPACK_IMPORTED_MODULE_24__.StringIsRegExMatch),
/* harmony export */   "StringIsValidDateString": () => (/* reexport safe */ _lib_rules_StringIsValidDateString__WEBPACK_IMPORTED_MODULE_25__.StringIsValidDateString),
/* harmony export */   "ValidationContext": () => (/* reexport safe */ _lib_validation_ValidationContext__WEBPACK_IMPORTED_MODULE_26__.ValidationContext),
/* harmony export */   "ValidationContextState": () => (/* reexport safe */ _lib_validation_ValidationContextState__WEBPACK_IMPORTED_MODULE_27__.ValidationContextState)
/* harmony export */ });
/* harmony import */ var _lib_rules_AreEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/rules/AreEqual */ 204728);
/* harmony import */ var _lib_rules_AreNotEqual__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/rules/AreNotEqual */ 590478);
/* harmony import */ var _lib_rules_CompositeRule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/rules/CompositeRule */ 472460);
/* harmony import */ var _lib_rules_DateIsGreaterThanComparisonDate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/rules/DateIsGreaterThanComparisonDate */ 488673);
/* harmony import */ var _lib_rules_Enum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/rules/Enum */ 881771);
/* harmony import */ var _lib_rules_GuidIsValid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/rules/GuidIsValid */ 61237);
/* harmony import */ var _lib_rules_IsExcelFile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/rules/IsExcelFile */ 824247);
/* harmony import */ var _lib_rules_IsFalse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/rules/IsFalse */ 259193);
/* harmony import */ var _lib_rules_IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/rules/IsNotNullOrUndefined */ 891113);
/* harmony import */ var _lib_rules_IsNullOrUndefined__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/rules/IsNullOrUndefined */ 331179);
/* harmony import */ var _lib_rules_IsNumber__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/rules/IsNumber */ 950433);
/* harmony import */ var _lib_rules_IsTrue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/rules/IsTrue */ 711870);
/* harmony import */ var _lib_rules_Max__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/rules/Max */ 621838);
/* harmony import */ var _lib_rules_Min__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/rules/Min */ 997381);
/* harmony import */ var _lib_rules_Range__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/rules/Range */ 368203);
/* harmony import */ var _lib_rules_RenderType__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/rules/RenderType */ 563264);
/* harmony import */ var _lib_rule_constants__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/rule-constants */ 786497);
/* harmony import */ var _lib_rules_RulePolicy__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lib/rules/RulePolicy */ 961808);
/* harmony import */ var _lib_rules_RuleResult__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./lib/rules/RuleResult */ 326439);
/* harmony import */ var _lib_rules_ImportRowHasRequiredFields__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./lib/rules/ImportRowHasRequiredFields */ 571442);
/* harmony import */ var _lib_rules_Severity__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lib/rules/Severity */ 629827);
/* harmony import */ var _lib_rules_SimpleRule__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./lib/rules/SimpleRule */ 701902);
/* harmony import */ var _lib_rules_StringIsNotNullEmptyRange__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lib/rules/StringIsNotNullEmptyRange */ 557417);
/* harmony import */ var _lib_rules_StringIsRegExArrayMatch__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lib/rules/StringIsRegExArrayMatch */ 937305);
/* harmony import */ var _lib_rules_StringIsRegExMatch__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./lib/rules/StringIsRegExMatch */ 816397);
/* harmony import */ var _lib_rules_StringIsValidDateString__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lib/rules/StringIsValidDateString */ 247351);
/* harmony import */ var _lib_validation_ValidationContext__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./lib/validation/ValidationContext */ 227538);
/* harmony import */ var _lib_validation_ValidationContextState__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./lib/validation/ValidationContextState */ 945143);
/* harmony import */ var _lib_rules_CellIdIsValid__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./lib/rules/CellIdIsValid */ 377249);
/* harmony import */ var _lib_rules_import_solution_rule__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./lib/rules/import-solution.rule */ 864450);
/* harmony import */ var _lib_rules_import_duplicate_rule__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./lib/rules/import-duplicate.rule */ 722418);
/* harmony import */ var _lib_rules_compareDatesLessRule__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./lib/rules/compareDatesLessRule */ 477075);

































/***/ }),

/***/ 786497:
/*!********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rule-constants.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RuleConstants": () => (/* binding */ RuleConstants)
/* harmony export */ });
class RuleConstants {}
/* eslint-disable max-len, no-control-regex, no-useless-escape */
RuleConstants.emailAddressFormatRegEx = /(?:[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-zA-Z0-9-]*[a-zA-Z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/;
RuleConstants.alphaNumericCaseInsensitiveRegEx = /^[a-zA-Z0-9\-\s]*$/;
RuleConstants.lowercaseAlphaCharacterRegEx = /[a-z]+/;
RuleConstants.numericCharactersRegEx = /[0-9]+/;
/**
 * Use to determine if the target string contains a special character:
 * !@#$%^&*()-_+=.,<>'"|
 */
// eslint-disable-next-line no-control-regex, no-useless-escape
RuleConstants.specialCharacterRegEx = /[!@#$%^&*()\-_\+=.,<>'"\|]+/;
RuleConstants.uppercaseAlphaCharacterRegEx = /[A-Z]+/;
RuleConstants.unicodeName = /^([\p{L}'][ \p{L}'-]*[\p{L}])*$/u;
RuleConstants.phoneNumberRegEx = /^[+]*[(]?[0-9]{1,4}[)]?[-\s./0-9]*$/;

/***/ }),

/***/ 204728:
/*!********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/AreEqual.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AreEqual": () => (/* binding */ AreEqual)
/* harmony export */ });
/* harmony import */ var _core_Compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Compare */ 81604);
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RuleResult */ 326439);
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SimpleRule */ 701902);



/**
 * Use to determine if the target is equal to the comparison target.
 */
class AreEqual extends _SimpleRule__WEBPACK_IMPORTED_MODULE_2__.SimpleRule {
  /**
   * The constructor for the [AreEqualRule] rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rules are evaluated against.
   * @param comparison The comparison target the rules are evaluated against.
   * @param isDisplayable: Indicates if the rule violation is displayable. Default value is [true].
   */
  constructor(name, message, target, comparison, isDisplayable = true) {
    super(name, message, isDisplayable);
    this.target = target;
    this.comparison = comparison;
  }
  /**
   * Use to render the evaluated result for the specified rule. This method
   * returns a [RuleResult] with the evaluated result and rule information.
   */
  render() {
    if ((0,_core_Compare__WEBPACK_IMPORTED_MODULE_0__.compare)(this.target, this.comparison, true) !== 0 /* CompareResult.Equal */) {
      this.isValid = false;
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_1__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 590478:
/*!***********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/AreNotEqual.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AreNotEqual": () => (/* binding */ AreNotEqual)
/* harmony export */ });
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleRule */ 701902);
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RuleResult */ 326439);
/* harmony import */ var _core_Compare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/Compare */ 81604);



/**
 * Use to determine if the target is not equal to the comparison target.
 */
class AreNotEqual extends _SimpleRule__WEBPACK_IMPORTED_MODULE_0__.SimpleRule {
  /**
   * The constructor for the [AreNotEqualRule] rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rules are evaluated against.
   * @param comparison The comparison target the rules are evaluated against.
   * @param isDisplayable: (Optional) Indicates if the rule violation is displayable. Default is [true].
   */
  constructor(name, message, target, comparison, isDisplayable = true) {
    super(name, message, isDisplayable);
    this.target = target;
    this.comparison = comparison;
  }
  /**
   * Use to render the evaluated result for the specified rule. This method
   * returns a [RuleResult] with the evaluated result and rule information.
   */
  render() {
    if ((0,_core_Compare__WEBPACK_IMPORTED_MODULE_2__.compare)(this.target, this.comparison, true) === 0 /* CompareResult.Equal */) {
      this.isValid = false;
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_1__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 377249:
/*!*************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/CellIdIsValid.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CellIdIsValidRule": () => (/* binding */ CellIdIsValidRule)
/* harmony export */ });
/* harmony import */ var _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @schema-driven/rules-engine */ 266710);

class CellIdIsValidRule extends _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__.SimpleRule {
  constructor(name, message, target, isDisplayable) {
    super(name, message, isDisplayable);
    this.target = target;
  }
  render() {
    this.isValid = this.target === '' || isNaN(Number(this.target));
    return new _schema_driven_rules_engine__WEBPACK_IMPORTED_MODULE_0__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 472460:
/*!*************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/CompositeRule.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CompositeRule": () => (/* binding */ CompositeRule)
/* harmony export */ });
/* harmony import */ var _RulePolicy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RulePolicy */ 961808);
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RuleResult */ 326439);


/**
 * Use the [CompositeRule] as a base class for a complex rule - a rule that contains
 * other rules.
 *
 * A [RulePolicy] is an abstraction of the "composite" pattern
 *
 * A [CompositeRule] --> [RulePolicy]
 * - has a list of [RulePolicy] items; it is the [composite] of the "composite" pattern
 *
 * A [SimpleRule]    --> [RulePolicy]
 * - does NOT have a list of rules; it is the [leaf] of the "composite" pattern.
 */
class CompositeRule extends _RulePolicy__WEBPACK_IMPORTED_MODULE_0__.RulePolicy {
  /**
   *
   * @param name The name of the rule.
   * @param message The message to display if the rule is violated.
   * @param isDisplayable Indicates if the rule is displayable.
   */
  constructor(name, message, isDisplayable) {
    super(name, message, isDisplayable);
    /**
     * Indicates if the rule has any rule violations.
     */
    this.hasErrors = false;
    /**
     * A list of results for evaluated rules. Rules must be rendered/executed before
     * any results are available.
     */
    this.results = new Array();
    /**
     * A list of rules for the specified composite rule.
     */
    this.rules = new Array();
  }
  /**
   * Use to render the evaluated result for the specified rule. This method
   * returns a [RuleResult] with the evaluated result and rule information.
   */
  render() {
    this.rules.sort(s => s.priority).forEach(r => this.results.push(r.execute()));
    return this.processResults();
  }
  /**
   * Use to determine if the composite rule has child-rules that are
   * members of the specified rule.
   */
  hasRules() {
    if (this.rules && this.rules.length > 0) {
      return true;
    }
    return false;
  }
  /**
   * Use to process the results of the specified rule result collection. Composite
   * rules will have one or more rule results for all child-rules.
   *
   * This method will return result with the evaluation summary and rule information.
   */
  processResults() {
    if (this.results.filter(r => r.isValid === false).length > 0) {
      this.isValid = false;
      this.hasErrors = true;
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_1__.RuleResult(this);
  }
}

/***/ }),

/***/ 488673:
/*!*******************************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/DateIsGreaterThanComparisonDate.ts ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DateIsGreaterThanComparisonDate": () => (/* binding */ DateIsGreaterThanComparisonDate)
/* harmony export */ });
/* harmony import */ var _CompositeRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompositeRule */ 472460);
/* harmony import */ var _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IsNotNullOrUndefined */ 891113);
/* harmony import */ var _IsTrue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IsTrue */ 711870);
/* harmony import */ var _StringIsValidDateString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StringIsValidDateString */ 247351);




/**
 * Use this rule to determine if a string value represents a valid Date/Time
 * string value - that can be used to hydrate a [Date] object.
 *
 * Example: '2022-01-31T07:08:00.000Z'
 *
 * 24 characters
 * contains year, month, date, hours, minutes, and seconds, TZ offset
 */
class DateIsGreaterThanComparisonDate extends _CompositeRule__WEBPACK_IMPORTED_MODULE_0__.CompositeRule {
  /**
   * The constructor for the [StringIsNotNullEmptyRangeRule].
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rule(s) will be evaluated against.
   */
  constructor(name, message, target, comparisonDate, isDisplayable = false) {
    super(name, message, isDisplayable);
    this.target = target;
    this.comparisonDate = comparisonDate;
    this.configureRules();
  }
  /**
   * A helper method to configure/add rules to the validation context.
   */
  configureRules() {
    this.rules.push(new _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_1__.IsNotNullOrUndefined('StringIsNotNull', 'The target cannot be null or undefined.', this.target));
    this.rules.push(new _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_1__.IsNotNullOrUndefined('StringIsNotNull', 'The comparison date cannot be null or undefined.', this.comparisonDate));
    if (this.target != null && this.comparisonDate != null) {
      // target and comparison date values are valid
      this.rules.push(new _StringIsValidDateString__WEBPACK_IMPORTED_MODULE_3__.StringIsValidDateString('TargetDateStringIsValidDateString', `The target date value [${this.target.toString()}] is not valid.`, this.target, true));
      this.rules.push(new _StringIsValidDateString__WEBPACK_IMPORTED_MODULE_3__.StringIsValidDateString('ComparisonDateStringIsValidDateString', `The comparison date value [${this.comparisonDate.toString()}] is not valid.`, this.comparisonDate, true));
      // target date is greater than the comparison date;
      this.rules.push(new _IsTrue__WEBPACK_IMPORTED_MODULE_2__.IsTrue('TargetDateIsGreater', `The target date [${this.target.toLocaleString()}] is not greater than the comparison date [${this.comparisonDate.toLocaleString()}].`, this.target.valueOf() > this.comparisonDate.valueOf()));
    }
  }
}

/***/ }),

/***/ 881771:
/*!****************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/Enum.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Enum": () => (/* binding */ Enum)
/* harmony export */ });
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RuleResult */ 326439);
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SimpleRule */ 701902);


/**
 * Use to determine if the target is equal to the comparison target.
 */
class Enum extends _SimpleRule__WEBPACK_IMPORTED_MODULE_1__.SimpleRule {
  /**
   * The constructor for the [AreEqualRule] rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rules are evaluated against.
   * @param comparison The comparison target the rules are evaluated against.
   * @param isDisplayable: Indicates if the rule violation is displayable. Default value is [true].
   */
  constructor(name, message, target, comparison, isDisplayable = true) {
    super(name, message, isDisplayable);
    this.target = target;
    this.comparison = comparison;
  }
  /**
   * Use to render the evaluated result for the specified rule. This method
   * returns a [RuleResult] with the evaluated result and rule information.
   */
  render() {
    if (!this.comparison.includes(this.target)) {
      this.isValid = false;
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_0__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 61237:
/*!***********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/GuidIsValid.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GuidIsValid": () => (/* binding */ GuidIsValid)
/* harmony export */ });
/* harmony import */ var _CompositeRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompositeRule */ 472460);
/* harmony import */ var _StringIsNotNullEmptyRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StringIsNotNullEmptyRange */ 557417);
/* harmony import */ var _StringIsRegExMatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StringIsRegExMatch */ 816397);



/**
 * Use this rule to validate the target to determine if it is a valid
 * GUID value.
 */
class GuidIsValid extends _CompositeRule__WEBPACK_IMPORTED_MODULE_0__.CompositeRule {
  /**
   * Constructor for the [GuidIsValid] composite rule.
   * @param name Use to indicate the name of the rule.
   * @param message Use to indicate the message to display for a false evaluation.
   * @param target Use to specify the target value to evaluate.
   * @param isDisplayable Use to indicate if the rule result is displayable.
   */
  constructor(name, message, target, isDisplayable) {
    super(name, message, isDisplayable);
    this.target = target;
    this.configureRules();
  }
  /**
   * Use to configure the rules for evaluation.
   */
  configureRules() {
    const doNotShowRuleViolation = false;
    const guidLength = 36; // Length with hyphens.
    const guidExpression = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i; // Guid RegExp (with hyphens)
    // determine if the target is a valid guid;
    this.rules.push(new _StringIsNotNullEmptyRange__WEBPACK_IMPORTED_MODULE_1__.StringIsNotNullEmptyRange('GuidStringIsNotNullOrUndefined', 'The target value is null or undefined.', this.target, guidLength, guidLength, doNotShowRuleViolation));
    if (this.target) {
      this.rules.push(new _StringIsRegExMatch__WEBPACK_IMPORTED_MODULE_2__.StringIsRegExMatch('GuidIsValid', 'The target value is not a valid guid.', this.target, guidExpression, doNotShowRuleViolation));
    }
  }
}

/***/ }),

/***/ 571442:
/*!**************************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/ImportRowHasRequiredFields.ts ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImportRowHasRequiredFields": () => (/* binding */ ImportRowHasRequiredFields)
/* harmony export */ });
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RuleResult */ 326439);
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SimpleRule */ 701902);


class ImportRowHasRequiredFields extends _SimpleRule__WEBPACK_IMPORTED_MODULE_1__.SimpleRule {
  constructor(name, message, target, requiredFields, isDisplayable) {
    super(name, message, isDisplayable);
    this.target = target;
    this.requiredFeilds = requiredFields;
  }
  render() {
    for (let i = 0; i < this.requiredFeilds.length; i++) {
      const field = this.requiredFeilds[i];
      if (!this.target[field]) {
        this.isValid = false;
        break;
      }
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_0__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 824247:
/*!***********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/IsExcelFile.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsExcelFile": () => (/* binding */ IsExcelFile)
/* harmony export */ });
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RuleResult */ 326439);
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SimpleRule */ 701902);


const allowedExtesions = ['xlsx', 'csv'];
class IsExcelFile extends _SimpleRule__WEBPACK_IMPORTED_MODULE_1__.SimpleRule {
  constructor(name, message, target, isDisplayable = true) {
    super(name, message, isDisplayable);
    this.target = target;
  }
  render() {
    if (this.target.length == 0) {
      this.isValid = false;
    } else {
      const dotIndex = this.target.lastIndexOf('.');
      if (dotIndex == -1) this.isValid = false;else {
        const extension = this.target.substring(dotIndex + 1).toLowerCase();
        this.isValid = allowedExtesions.includes(extension);
      }
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_0__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 259193:
/*!*******************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/IsFalse.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsFalse": () => (/* binding */ IsFalse)
/* harmony export */ });
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleRule */ 701902);
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RuleResult */ 326439);


/**
 * Use to indicate if the value is falsy.
 */
class IsFalse extends _SimpleRule__WEBPACK_IMPORTED_MODULE_0__.SimpleRule {
  /**
   * The constructor for the [IsFalse] rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rules are evaluated against.
   * @param isDisplayable: Indicates if the rule violation is displayable. Default value is [false].
   */
  constructor(name, message, target, isDisplayable = false) {
    super(name, message, isDisplayable);
    this.target = target;
  }
  /**
   * Use to render the evaluated result for the specified rule. This method
   * returns a [RuleResult] with the evaluated result and rule information.
   */
  render() {
    if (this.target) {
      //if(true)-->false;
      this.isValid = false;
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_1__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 891113:
/*!********************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/IsNotNullOrUndefined.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsNotNullOrUndefined": () => (/* binding */ IsNotNullOrUndefined)
/* harmony export */ });
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleRule */ 701902);
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RuleResult */ 326439);


/**
 * Use to determine if the target is NOT [null] or [undefined].
 */
class IsNotNullOrUndefined extends _SimpleRule__WEBPACK_IMPORTED_MODULE_0__.SimpleRule {
  /**
   * The constructor for the [IsNotNullOrUndefined] rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rules are evaluated against.
   * @param isDisplayable: Indicates if the rule violation is displayable. Default value is [false].
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(name, message, target, isDisplayable = false) {
    super(name, message, isDisplayable);
    this.target = target;
  }
  /**
   * Use to render the evaluated result for the specified rule. This method
   * returns a [RuleResult] with the evaluated result and rule information.
   */
  render() {
    if (this.target == null || this.target === null || typeof this.target === 'undefined') {
      this.isValid = false;
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_1__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 331179:
/*!*****************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/IsNullOrUndefined.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsNullOrUndefined": () => (/* binding */ IsNullOrUndefined)
/* harmony export */ });
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleRule */ 701902);
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RuleResult */ 326439);


/**
 * Use to determine if the target is [null] or [undefined].
 */
class IsNullOrUndefined extends _SimpleRule__WEBPACK_IMPORTED_MODULE_0__.SimpleRule {
  /**
   * The constructor for the [IsNullOrUndefined] rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rules are evaluated against.
   * @param isDisplayable: Indicates if the rule violation is displayable. Default value is [false].
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(name, message, target, isDisplayable = false) {
    super(name, message, isDisplayable);
    this.target = target;
  }
  /**
   * Use to render the evaluated result for the specified rule. This method
   * returns a [RuleResult] with the evaluated result and rule information.
   */
  render() {
    if (this.target == null || typeof this.target === undefined || typeof this.target === 'undefined') {
      this.isValid = true;
    } else {
      this.isValid = false;
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_1__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 950433:
/*!********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/IsNumber.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsNumber": () => (/* binding */ IsNumber)
/* harmony export */ });
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RuleResult */ 326439);
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SimpleRule */ 701902);


class IsNumber extends _SimpleRule__WEBPACK_IMPORTED_MODULE_1__.SimpleRule {
  constructor(name, message, taret, isDisplayable) {
    super(name, message, isDisplayable);
    this.target = taret;
  }
  render() {
    this.isValid = this.target !== '' && !isNaN(Number(this.target));
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_0__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 711870:
/*!******************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/IsTrue.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsTrue": () => (/* binding */ IsTrue)
/* harmony export */ });
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleRule */ 701902);
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RuleResult */ 326439);


/**
 * Use to determine if the target is truthy.
 */
class IsTrue extends _SimpleRule__WEBPACK_IMPORTED_MODULE_0__.SimpleRule {
  /**
   * The constructor for the [IsTrue] rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rules are evaluated against.
   * @param isDisplayable: Indicates if the rule violation is displayable. Default value is [true].
   */
  constructor(name, message, target, isDisplayable = true) {
    super(name, message, isDisplayable);
    this.target = target;
  }
  /**
   * Use to render the evaluated result for the specified rule. This method
   * returns a [RuleResult] with the evaluated result and rule information.
   */
  render() {
    this.isValid = true;
    if (this.target === false) {
      //if(not true)-->false;
      this.isValid = false;
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_1__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 621838:
/*!***************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/Max.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Max": () => (/* binding */ Max)
/* harmony export */ });
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleRule */ 701902);
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RuleResult */ 326439);
/* harmony import */ var _core_Compare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/Compare */ 81604);



/**
 * Use the [Max] rule to determine if the target value is equal to or less than
 * the comparison value.
 */
class Max extends _SimpleRule__WEBPACK_IMPORTED_MODULE_0__.SimpleRule {
  /**
   * The constructor for the [Max] rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rules are evaluated against.
   * @param comparison The comparison target the rules are evaluated against.
   * @param isDisplayable: Indicates if the rule violation is displayable. Default value is [false].
   */
  constructor(name, message, target, comparison, isDisplayable = false) {
    super(name, message, isDisplayable);
    this.target = target;
    this.comparison = comparison;
  }
  /**
   * Use to render the evaluated result for the specified rule. This method
   * returns a [RuleResult] with the evaluated result and rule information.
   */
  render() {
    const compareResult = (0,_core_Compare__WEBPACK_IMPORTED_MODULE_2__.compare)(this.target, this.comparison, true);
    if (compareResult === 1 /* CompareResult.Greater */) {
      this.isValid = false;
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_1__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 997381:
/*!***************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/Min.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Min": () => (/* binding */ Min)
/* harmony export */ });
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleRule */ 701902);
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RuleResult */ 326439);
/* harmony import */ var _core_Compare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/Compare */ 81604);



/**
 * Use the [Min] rule to determine if the target value is equal to or greater than the minimum
 * allowed value [comparison].
 */
class Min extends _SimpleRule__WEBPACK_IMPORTED_MODULE_0__.SimpleRule {
  /**
   * The constructor for the [Min] rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rules are evaluated against.
   * @param comparison The comparison target the rules are evaluated against.
   * @param isDisplayable: Indicates if the rule violation is displayable. Default value is [false].
   */
  constructor(name, message, target, comparison, isDisplayable = false) {
    super(name, message, isDisplayable);
    this.target = target;
    this.comparison = comparison;
  }
  /**
   * Use to render the evaluated result for the specified rule. This method
   * returns a [RuleResult] with the evaluated result and rule information.
   */
  render() {
    const compareResult = (0,_core_Compare__WEBPACK_IMPORTED_MODULE_2__.compare)(this.target, this.comparison, true);
    if (compareResult === -1 /* CompareResult.Less */) {
      this.isValid = false; //must be equal to or greater than the comparison value;
    }

    return new _RuleResult__WEBPACK_IMPORTED_MODULE_1__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 368203:
/*!*****************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/Range.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Range": () => (/* binding */ Range)
/* harmony export */ });
/* harmony import */ var _CompositeRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompositeRule */ 472460);
/* harmony import */ var _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IsNotNullOrUndefined */ 891113);
/* harmony import */ var _Max__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Max */ 621838);
/* harmony import */ var _Min__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Min */ 997381);




/**
 * Use this rule to determine if the specified target is within the specified range (start and end) values.
 *
 * The range values are inclusive.
 *
 * Ex: 1 is within 1 and 3. The target is valid.
 * Ex: 2 is within 1 and 3. The target is valid.
 * Ex: 0 is not within 1 and 3. The target is not valid.
 * Ex: 4 is not within 1 and 3. The target is not valid.
 */
class Range extends _CompositeRule__WEBPACK_IMPORTED_MODULE_0__.CompositeRule {
  /**
   * Constructor for the [Range] rule.
   * @param name The name of the rule.
   * @param message: A message to display if the rule is violated.
   * @param target The target object that the rules will be applied to.
   * @param start The start range value - the lowest allowed boundary value.
   * @param end The end range value - the highest allowed boundary value.
   * @param isDisplayable: (Optional) Indicates if the rule violation may be displayed or visible to the caller or client. Default is [false].
   */
  constructor(name, message, target, start, end, isDisplayable = false) {
    super(name, message, isDisplayable);
    this.target = target;
    this.start = start;
    this.end = end;
    this.isDisplayable = isDisplayable;
    this.rules.push(new _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_1__.IsNotNullOrUndefined('TargetIsNotNull', 'The target is null or undefined.', this.target));
    if (this.target != null) {
      this.rules.push(new _Min__WEBPACK_IMPORTED_MODULE_3__.Min('MinValue', 'The value must be equal to or greater than the start range value.', this.target, this.start));
      this.rules.push(new _Max__WEBPACK_IMPORTED_MODULE_2__.Max('MaxValue', 'The value must be equal to or less than the end range value.', this.target, this.end));
    }
  }
}

/***/ }),

/***/ 563264:
/*!**********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/RenderType.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RenderType": () => (/* binding */ RenderType)
/* harmony export */ });
/**
 * Use to indicate how the rule-set is rendered.
 */
var RenderType;
(function (RenderType) {
  /**
   * Use to indicate the rule rendering stops when a rule's evaluation is false - rule contains violations.
   */
  RenderType["ExitOnFirstFalseEvaluation"] = "ExitOnFirstFalseEvaluation";
  /**
   * Use to indicate the rule rendering stops when a rule's evaluation is true (no rule violations).
   */
  RenderType["ExitOnFirstTrueEvaluation"] = "ExitOnFirstTrueEvaluation";
  /**
   * Use to indicate that all rules of the rule set are rendered - returns all rule results.
   */
  RenderType["EvaluateAllRules"] = "EvaluateAllRules";
})(RenderType || (RenderType = {}));

/***/ }),

/***/ 961808:
/*!**********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/RulePolicy.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RulePolicy": () => (/* binding */ RulePolicy)
/* harmony export */ });
/* harmony import */ var _RenderType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderType */ 563264);
/* harmony import */ var _Severity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Severity */ 629827);


/**
 * This is the base class for all rules. All rules will extend from this class. New rules
 * should extend [SimpleRule] or [CompositeRule] - these rule abstractions extend [RulePolicy].
 */
class RulePolicy {
  /**
   * Overloaded constructor for the [RulePolicy] class.
   * @param name The name of the rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param isDisplayable: Indicates if the rule violation is displayable.
   * @param severity (Optional) Use to indicate the rule violation severity. Default is [Exception].
   * @param priority (Optional) Use to indicate the rule's evaluation priority. Higher numeric values are priority. 0 is default and lowest priority.
   */
  constructor(name, message, isDisplayable = false, severity = _Severity__WEBPACK_IMPORTED_MODULE_1__.Severity.Exception, priority = 1) {
    /** Use to indicate the status of the rule. Value is false when the rule contains violations. */
    this.isValid = true;
    /** Use to indicate the display message for a rule violation. */
    this.message = '';
    /** Use to indicate the name of the specified rule. */
    this.name = '';
    /** Use to determine how the rule is evaluated. */
    this.renderType = _RenderType__WEBPACK_IMPORTED_MODULE_0__.RenderType.EvaluateAllRules;
    /** Use to indicate the severity for a rule violation. The default severity is [Exception]. */
    this.severity = _Severity__WEBPACK_IMPORTED_MODULE_1__.Severity.Exception;
    /** Use to indicate the source of the specified rule. */
    this.source = '';
    this.name = name;
    this.message = message;
    this.isDisplayable = isDisplayable;
    this.priority = priority;
    this.severity = severity;
  }
  /**
   * Use to execute the rule. This is the [template] method of the [template method] design
   * pattern. It will coordinate the execution of any required methods in the processing
   * pipeline.
   */
  execute() {
    return this.render();
  }
  /**
   * Each rule must implement this function and return a valid [RuleResult].
   */
  render() {
    throw new Error('Each concrete rule must implement this function and return a valid Result.');
  }
}

/***/ }),

/***/ 326439:
/*!**********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/RuleResult.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RuleResult": () => (/* binding */ RuleResult)
/* harmony export */ });
/* harmony import */ var _RulePolicy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RulePolicy */ 961808);
/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * This class defines the result of a single rule evaluation.
 */
class RuleResult {
  /**
   * Constructor for the RuleResult class.
   * @param rulePolicy Use to specify the rule.
   * @param target Use to specify the target to be evaluated by the rule.
   */
  constructor(rulePolicy, target) {
    /**
     * Use to indicate if the rule result is valid or not.
     */
    this.isValid = false;
    /**
     * The rule that was evaluated.
     */
    this.rulePolicy = new _RulePolicy__WEBPACK_IMPORTED_MODULE_0__.RulePolicy('', '', false);
    /**
     * The rule message to use when the evaluation [isValid] is [false].
     */
    this.message = '';
    if (rulePolicy != null && rulePolicy.name.length > 0 && rulePolicy.message.length > 0) {
      this.rulePolicy = rulePolicy;
      this.isValid = rulePolicy.isValid;
      this.message = rulePolicy.message;
    }
    this.target = target;
  }
}

/***/ }),

/***/ 629827:
/*!********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/Severity.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Severity": () => (/* binding */ Severity)
/* harmony export */ });
/**
 * Use to indicate the severity if the rule is violated.
 */
var Severity;
(function (Severity) {
  /**
   * Indicates the rule violation is an [Exception].
   */
  Severity["Exception"] = "Exception";
  /**
   * Indicates the rule violation is an [Warning].
   */
  Severity["Warning"] = "Warning";
  /**
   * Indicates the rule violation is an [Information].
   */
  Severity["Information"] = "Information";
})(Severity || (Severity = {}));

/***/ }),

/***/ 701902:
/*!**********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/SimpleRule.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SimpleRule": () => (/* binding */ SimpleRule)
/* harmony export */ });
/* harmony import */ var _RulePolicy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RulePolicy */ 961808);

/**
 * Use this class as a base [extends] class for simple rules. A simple rule contains
 * a single rule and target to evaluate.
 *
 * If you require a rule that will contain more than one rule, you should
 * use extend the [CompositeRule] class.
 */
class SimpleRule extends _RulePolicy__WEBPACK_IMPORTED_MODULE_0__.RulePolicy {
  /**
   * The constructor for the simple rule.
   * @param name The name of the rule.
   * @param message The message to display if the rule is violated.
   */
  constructor(name, message, isDisplayable) {
    super(name, message, isDisplayable);
  }
}

/***/ }),

/***/ 557417:
/*!*************************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/StringIsNotNullEmptyRange.ts ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringIsNotNullEmptyRange": () => (/* binding */ StringIsNotNullEmptyRange)
/* harmony export */ });
/* harmony import */ var _CompositeRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompositeRule */ 472460);
/* harmony import */ var _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IsNotNullOrUndefined */ 891113);
/* harmony import */ var _Range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Range */ 368203);



/**
 * Use this rule to validate a string target. A valid string is not null or undefined; and it
 * is within the specified minimum and maximum length.
 */
class StringIsNotNullEmptyRange extends _CompositeRule__WEBPACK_IMPORTED_MODULE_0__.CompositeRule {
  /**
   * The constructor for the [StringIsNotNullEmptyRangeRule].
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rule(s) will be evaluated against.
   * @param minLength The minimum allowed length of the target value.
   * @param maxLength The maximum allowed length of the target value.
   */
  constructor(name, message, target, minLength, maxLength, isDisplayable = false) {
    super(name, message, isDisplayable);
    this.target = target;
    this.minLength = minLength;
    this.maxLength = maxLength;
    this.configureRules();
  }
  /**
   * A helper method to configure/add rules to the validation context.
   */
  configureRules() {
    this.rules.push(new _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_1__.IsNotNullOrUndefined('StringIsNotNull', 'The string target is null or undefined.', this.target));
    if (this.target != null) {
      this.rules.push(new _Range__WEBPACK_IMPORTED_MODULE_2__.Range('TargetLengthIsWithinRange', 'The string value is not within the specified range.', this.target.toString().length, this.minLength, this.maxLength));
    }
  }
}

/***/ }),

/***/ 937305:
/*!***********************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/StringIsRegExArrayMatch.ts ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringIsRegExArrayMatch": () => (/* binding */ StringIsRegExArrayMatch)
/* harmony export */ });
/* harmony import */ var _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IsNotNullOrUndefined */ 891113);
/* harmony import */ var _IsTrue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IsTrue */ 711870);
/* harmony import */ var _CompositeRule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CompositeRule */ 472460);



/**
 * Use this rule to determine if the string value matches the specified
 * regular expression.
 */
class StringIsRegExArrayMatch extends _CompositeRule__WEBPACK_IMPORTED_MODULE_2__.CompositeRule {
  /**
   * The constructor for the [IsNotNullOrUndefined] rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rules are evaluated against.
   * @param isDisplayable: Indicates if the rule violation is displayable. Default value is [false].
   */
  constructor(name, message, target, expressions, isDisplayable) {
    super(name, message, isDisplayable);
    this.target = target;
    this.expressions = expressions;
    this.configureRules();
  }
  /**
   * Use to configure the rules to be evaluated.
   */
  configureRules() {
    const showRuleViolations = true;
    const doNotShowRuleViolation = false;
    // determine if the target is a valid object;
    this.rules.push(new _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_0__.IsNotNullOrUndefined('StringIsNotNullOrUndefined', 'The target value is null or undefined.', this.target, doNotShowRuleViolation));
    if (this.target) {
      this.expressions.forEach(e => {
        this.rules.push(new _IsTrue__WEBPACK_IMPORTED_MODULE_1__.IsTrue('StringIsReExMatch', `The target value does not match the regular expressions: \\${e}\\`, e.test(this.target), showRuleViolations));
      });
    }
  }
}

/***/ }),

/***/ 816397:
/*!******************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/StringIsRegExMatch.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringIsRegExMatch": () => (/* binding */ StringIsRegExMatch)
/* harmony export */ });
/* harmony import */ var _CompositeRule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompositeRule */ 472460);
/* harmony import */ var _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IsNotNullOrUndefined */ 891113);
/* harmony import */ var _IsTrue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IsTrue */ 711870);



/**
 * Use this rule to determine if the string value matches the specified
 * regular expression.
 */
class StringIsRegExMatch extends _CompositeRule__WEBPACK_IMPORTED_MODULE_0__.CompositeRule {
  /**
   * The constructor for the [IsNotNullOrUndefined] rule.
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rules are evaluated against.
   * @param isDisplayable: Indicates if the rule violation is displayable. Default value is [false].
   */
  constructor(name, message, target, expression, isDisplayable) {
    super(name, message, isDisplayable);
    this.target = target;
    this.expression = expression;
    this.configureRules();
  }
  /**
   * Use to configure the rules to be evaluated.
   */
  configureRules() {
    const doNotShowRuleViolation = false;
    // determine if the target is a valid object;
    this.rules.push(new _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_1__.IsNotNullOrUndefined('StringIsNotNullOrUndefined', 'The target value is null or undefined.', this.target, doNotShowRuleViolation));
    if (this.target) {
      this.rules.push(new _IsTrue__WEBPACK_IMPORTED_MODULE_2__.IsTrue('StringIsRegExpMatch', 'The target value is not a match.', this.expression.test(this.target), doNotShowRuleViolation));
    }
  }
}

/***/ }),

/***/ 247351:
/*!***********************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/StringIsValidDateString.ts ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringIsValidDateString": () => (/* binding */ StringIsValidDateString)
/* harmony export */ });
/* harmony import */ var _IsTrue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IsTrue */ 711870);
/* harmony import */ var _CompositeRule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CompositeRule */ 472460);
/* harmony import */ var _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IsNotNullOrUndefined */ 891113);



/**
 * Use this rule to determine if a string value represents a valid Date/Time
 * string value - that can be used to hydrate a [Date] object.
 *
 * Example: '2022-01-31T07:08:00.000Z'
 *
 * 24 characters
 * contains year, month, date, hours, minutes, and seconds, TZ offset
 */
class StringIsValidDateString extends _CompositeRule__WEBPACK_IMPORTED_MODULE_1__.CompositeRule {
  /**
   * The constructor for the [StringIsNotNullEmptyRangeRule].
   * @param name The name of the rule.
   * @param message The message to display when the rule is violated.
   * @param target The target that the rule(s) will be evaluated against.
   */
  constructor(name, message, target, isDisplayable = false) {
    super(name, message, isDisplayable);
    this.target = target;
    this.configureRules();
  }
  /**
   * A helper method to configure/add rules to the validation context.
   */
  configureRules() {
    this.rules.push(new _IsNotNullOrUndefined__WEBPACK_IMPORTED_MODULE_2__.IsNotNullOrUndefined('StringIsNotNull', 'The string target is null or undefined.', this.target));
    if (this.target != null) {
      this.rules.push(new _IsTrue__WEBPACK_IMPORTED_MODULE_0__.IsTrue('DateStringIsValid', `The date string value is not valid. Cannot create a date with value of [${this.target}]`, !isNaN(new Date(this.target).getDate())));
    }
  }
}

/***/ }),

/***/ 477075:
/*!********************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/compareDatesLessRule.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CompareDatesLessRule": () => (/* binding */ CompareDatesLessRule)
/* harmony export */ });
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RuleResult */ 326439);
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SimpleRule */ 701902);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moment */ 815439);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_2__);



class CompareDatesLessRule extends _SimpleRule__WEBPACK_IMPORTED_MODULE_1__.SimpleRule {
  constructor(name, message, target, comparison, isDisplayable = true) {
    super(name, message, isDisplayable);
    this.target = target;
    this.comparison = comparison;
  }
  render() {
    if (this.target && this.comparison) {
      if (moment__WEBPACK_IMPORTED_MODULE_2__(this.target).isBefore(moment__WEBPACK_IMPORTED_MODULE_2__(this.comparison))) {
        this.isValid = true;
      } else this.isValid = false;
    } else this.isValid = true;
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_0__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 81604:
/*!************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/core/Compare.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "areEqual": () => (/* binding */ areEqual),
/* harmony export */   "areEquivalent": () => (/* binding */ areEquivalent),
/* harmony export */   "compare": () => (/* binding */ compare)
/* harmony export */ });
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Types */ 972672);
/* eslint-disable @typescript-eslint/no-explicit-any */

var isTrueNaN = _Types__WEBPACK_IMPORTED_MODULE_0__.Type.isTrueNaN;
const VOID0 = void 0;
/**
 * Used for special comparison including NaN.
 * @param a
 * @param b
 * @param strict
 * @returns {boolean|any}
 */
function areEqual(a, b, strict = true) {
  return a === b || !strict && a == b || isTrueNaN(a) && isTrueNaN(b);
}
const COMPARE_TO = "compareTo";
function compare(a, b, strict = true) {
  if (areEqual(a, b, strict)) return 0 /* CompareResult.Equal */;
  if (a && _Types__WEBPACK_IMPORTED_MODULE_0__.Type.hasMember(a, COMPARE_TO)) return a.compareTo(b); // If a has compareTo, use it.
  else if (b && _Types__WEBPACK_IMPORTED_MODULE_0__.Type.hasMember(b, COMPARE_TO)) return -b.compareTo(a); // a doesn't have compareTo? check if b does and invert.
  // Allow for special inequality..
  if (a > b || strict && (a === 0 && b == 0 || a === null && b === VOID0)) return 1 /* CompareResult.Greater */;
  if (b > a || strict && (b === 0 && a == 0 || b === null && a === VOID0)) return -1 /* CompareResult.Less */;
  return NaN;
}
/**
 * Determines if two primitives are equal or if two objects have the same key/value combinations.
 * @param a
 * @param b
 * @param nullEquivalency If true, null/undefined will be equivalent to an empty object {}.
 * @param extraDepth
 * @returns {boolean}
 */
function areEquivalent(a, b, nullEquivalency = true, extraDepth = 0) {
  // Take a step by step approach to ensure efficiency.
  if (areEqual(a, b, true)) return true;
  if (a == null || b == null) {
    if (!nullEquivalency) return false;
    if (_Types__WEBPACK_IMPORTED_MODULE_0__.Type.isObject(a)) {
      return !Object.keys(a).length;
    }
    if (_Types__WEBPACK_IMPORTED_MODULE_0__.Type.isObject(b)) {
      return !Object.keys(b).length;
    }
    return a == null && b == null;
  }
  if (_Types__WEBPACK_IMPORTED_MODULE_0__.Type.isObject(a) && _Types__WEBPACK_IMPORTED_MODULE_0__.Type.isObject(b)) {
    const aKeys = Object.keys(a),
      bKeys = Object.keys(b),
      len = aKeys.length;
    if (len != bKeys.length) return false;
    aKeys.sort();
    bKeys.sort();
    for (let i = 0; i < len; i++) {
      const key = aKeys[i];
      if (key !== bKeys[i] || !areEqual(a[key], b[key], true)) return false;
    }
    // Doesn't track circular references but allows for controlling the amount of recursion.
    if (extraDepth > 0) {
      for (const key of aKeys) {
        if (!areEquivalent(a[key], b[key], nullEquivalency, extraDepth - 1)) return false;
      }
    }
    return true;
  }
  return false;
}

/***/ }),

/***/ 972672:
/*!**********************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/core/Types.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Type": () => (/* binding */ Type),
/* harmony export */   "TypeInfo": () => (/* binding */ TypeInfo),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/prefer-namespace-keyword */
/* eslint-disable @typescript-eslint/no-namespace */
const VOID0 = void 0,
  _BOOLEAN = typeof true,
  _NUMBER = typeof 0,
  _STRING = typeof "",
  _SYMBOL = "symbol",
  _OBJECT = typeof {},
  _UNDEFINED = typeof VOID0,
  _FUNCTION = typeof function () {},
  LENGTH = "length";
// Only used for primitives.
const typeInfoRegistry = {};
/**
 * Exposes easy access to type information including inquiring about members.
 */
class TypeInfo {
  constructor(target, onBeforeFreeze) {
    this.isBoolean = false;
    this.isNumber = false;
    this.isFinite = false;
    this.isValidNumber = false;
    this.isString = false;
    this.isTrueNaN = false;
    this.isObject = false;
    this.isFunction = false;
    this.isUndefined = false;
    this.isNull = false;
    this.isPrimitive = false;
    this.isSymbol = false;
    this.isArray = false;
    this.isNullOrUndefined = false;
    switch (this.type = typeof target) {
      case _BOOLEAN:
        this.isBoolean = true;
        this.isPrimitive = true;
        break;
      case _NUMBER:
        this.isNumber = true;
        this.isTrueNaN = isNaN(target);
        this.isFinite = isFinite(target);
        this.isValidNumber = !this.isTrueNaN;
        this.isPrimitive = true;
        break;
      case _STRING:
        this.isString = true;
        this.isPrimitive = true;
        break;
      case _SYMBOL:
        this.isSymbol = true;
        break;
      case _OBJECT:
        this.target = target;
        if (target === null) {
          this.isNull = true;
          this.isNullOrUndefined = true;
          this.isPrimitive = true;
        } else {
          this.isArray = target instanceof Array;
          this.isObject = true;
        }
        break;
      case _FUNCTION:
        this.target = target;
        this.isFunction = true;
        break;
      case _UNDEFINED:
        this.isUndefined = true;
        this.isNullOrUndefined = true;
        this.isPrimitive = true;
        break;
      default:
        throw "Fatal type failure.  Unknown type: " + this.type;
    }
    if (onBeforeFreeze) onBeforeFreeze(this);
    Object.freeze(this);
  }
  /**
   * Returns a TypeInfo for any member or non-member,
   * where non-members are of type undefined.
   * @param name
   * @returns {TypeInfo}
   */
  member(name) {
    const t = this.target;
    return TypeInfo.getFor(t && name in t ? t[name] : VOID0);
  }
  /**
   * Returns a TypeInfo for any target object.
   * If the target object is of a primitive type, it returns the TypeInfo instance assigned to that type.
   * @param target
   * @returns {TypeInfo}
   */
  static getFor(target) {
    const type = typeof target;
    switch (type) {
      case _OBJECT:
      case _FUNCTION:
        return new TypeInfo(target);
    }
    let info = typeInfoRegistry[type];
    if (!info) typeInfoRegistry[type] = info = new TypeInfo(target);
    return info;
  }
  /**
   * Returns true if the target matches the type (instanceof).
   * @param type
   * @returns {boolean}
   */
  is(type) {
    return this.target instanceof type;
  }
  /**
   * Returns null if the target does not match the type (instanceof).
   * Otherwise returns the target as the type.
   * @param type
   * @returns {T|null}
   */
  as(type) {
    return this.target instanceof type ? this.target : null;
  }
}
function Type(target) {
  return new TypeInfo(target);
}
(function (Type) {
  /**
   * typeof true
   * @type {string}
   */
  Type.BOOLEAN = _BOOLEAN;
  /**
   * typeof 0
   * @type {string}
   */
  Type.NUMBER = _NUMBER;
  /**
   * typeof ""
   * @type {string}
   */
  Type.STRING = _STRING;
  /**
   * typeof {}
   * @type {string}
   */
  Type.OBJECT = _OBJECT;
  /**
   * typeof Symbol
   * @type {string}
   */
  Type.SYMBOL = _SYMBOL;
  /**
   * typeof undefined
   * @type {string}
   */
  Type.UNDEFINED = _UNDEFINED;
  /**
   * typeof function
   * @type {string}
   */
  Type.FUNCTION = _FUNCTION;
  /**
   * Returns true if the target matches the type (instanceof).
   * @param target
   * @param type
   * @returns {T|null}
   */
  function is(target, type) {
    return target instanceof type;
  }
  Type.is = is;
  /**
   * Returns null if the target does not match the type (instanceof).
   * Otherwise returns the target as the type.
   * @param target
   * @param type
   * @returns {T|null}
   */
  function as(target, type) {
    return target instanceof type ? target : null;
  }
  Type.as = as;
  /**
   * Returns true if the value parameter is null or undefined.
   * @param value
   * @returns {boolean}
   */
  function isNullOrUndefined(value) {
    return value == null;
  }
  Type.isNullOrUndefined = isNullOrUndefined;
  /**
   * Returns true if the value parameter is a boolean.
   * @param value
   * @returns {boolean}
   */
  function isBoolean(value) {
    return typeof value === _BOOLEAN;
  }
  Type.isBoolean = isBoolean;
  /**
   * Returns true if the value parameter is a number.
   * @param value
   * @param ignoreNaN Default is false. When true, NaN is not considered a number and will return false.
   * @returns {boolean}
   */
  function isNumber(value, ignoreNaN = false) {
    return typeof value === _NUMBER && (!ignoreNaN || !isNaN(value));
  }
  Type.isNumber = isNumber;
  /**
   * Returns true if is a number and is NaN.
   * @param value
   * @returns {boolean}
   */
  function isTrueNaN(value) {
    return typeof value === _NUMBER && isNaN(value);
  }
  Type.isTrueNaN = isTrueNaN;
  /**
   * Returns true if the value parameter is a string.
   * @param value
   * @returns {boolean}
   */
  function isString(value) {
    return typeof value === _STRING;
  }
  Type.isString = isString;
  /**
   * Returns true if the value is a boolean, string, number, null, or undefined.
   * @param value
   * @param allowUndefined if set to true will return true if the value is undefined.
   * @returns {boolean}
   */
  function isPrimitive(value, allowUndefined = false) {
    const t = typeof value;
    switch (t) {
      case _BOOLEAN:
      case _STRING:
      case _NUMBER:
        return true;
      case _UNDEFINED:
        return allowUndefined;
      case _OBJECT:
        return value === null;
    }
    return false;
  }
  Type.isPrimitive = isPrimitive;
  /**
   * For detecting if the value can be used as a key.
   * @param value
   * @param allowUndefined
   * @returns {boolean|boolean}
   */
  function isPrimitiveOrSymbol(value, allowUndefined = false) {
    return typeof value === _SYMBOL ? true : isPrimitive(value, allowUndefined);
  }
  Type.isPrimitiveOrSymbol = isPrimitiveOrSymbol;
  /**
   * Returns true if the value is a string, number, or symbol.
   * @param value
   * @returns {boolean}
   */
  function isPropertyKey(value) {
    const t = typeof value;
    switch (t) {
      case _STRING:
      case _NUMBER:
      case _SYMBOL:
        return true;
    }
    return false;
  }
  Type.isPropertyKey = isPropertyKey;
  /**
   * Returns true if the value parameter is a function.
   * @param value
   * @returns {boolean}
   */
  function isFunction(value) {
    return typeof value === _FUNCTION;
  }
  Type.isFunction = isFunction;
  /**
   * Returns true if the value parameter is an object.
   * @param value
   * @param allowNull If false (default) null is not considered an object.
   * @returns {boolean}
   */
  function isObject(value, allowNull = false) {
    return typeof value === _OBJECT && (allowNull || value !== null);
  }
  Type.isObject = isObject;
  /**
   * Guarantees a number value or NaN instead.
   * @param value
   * @returns {number}
   */
  function numberOrNaN(value) {
    return isNaN(value) ? NaN : value;
  }
  Type.numberOrNaN = numberOrNaN;
  /**
   * Returns a TypeInfo object for the target.
   * @param target
   * @returns {TypeInfo}
   */
  function of(target) {
    return TypeInfo.getFor(target);
  }
  Type.of = of;
  /**
   * Will detect if a member exists (using 'in').
   * Returns true if a property or method exists on the object or its prototype.
   * @param instance
   * @param property Name of the member.
   * @param ignoreUndefined When ignoreUndefined is true, if the member exists but is undefined, it will return false.
   * @returns {boolean}
   */
  function hasMember(instance, property, ignoreUndefined = true) {
    return instance && !isPrimitive(instance) && property in instance && (ignoreUndefined || instance[property] !== VOID0);
  }
  Type.hasMember = hasMember;
  /**
   * Returns true if the member matches the type.
   * @param instance
   * @param property
   * @param type
   * @returns {boolean}
   */
  function hasMemberOfType(instance, property, type) {
    return hasMember(instance, property) && typeof instance[property] === type;
  }
  Type.hasMemberOfType = hasMemberOfType;
  function hasMethod(instance, property) {
    return hasMemberOfType(instance, property, _FUNCTION);
  }
  Type.hasMethod = hasMethod;
  function isArrayLike(instance) {
    /*
     * NOTE:
     *
     * Functions:
     * Enumerating a function although it has a .length property will yield nothing or unexpected results.
     * Effectively, a function is not like an array.
     *
     * Strings:
     * Behave like arrays but don't have the same exact methods.
     */
    return instance instanceof Array || Type.isString(instance) || !Type.isFunction(instance) && hasMember(instance, LENGTH);
  }
  Type.isArrayLike = isArrayLike;
})(Type || (Type = {}));
Object.freeze(Type);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Type);

/***/ }),

/***/ 722418:
/*!*********************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/import-duplicate.rule.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImportDuplicateRule": () => (/* binding */ ImportDuplicateRule)
/* harmony export */ });
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RuleResult */ 326439);
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SimpleRule */ 701902);


class ImportDuplicateRule extends _SimpleRule__WEBPACK_IMPORTED_MODULE_1__.SimpleRule {
  constructor(name, message, target, isDisplayable) {
    super(name, message, isDisplayable);
    this.conflicts = [];
    this.target = target;
  }
  render() {
    // { name1: 1, name2: 2, name3: 1, ... }
    const nameCount = {};
    this.target.map(name => {
      if (nameCount[name]) {
        nameCount[name] += 1;
      } else {
        nameCount[name] = 1;
      }
    });
    for (const name in nameCount) {
      const count = nameCount[name];
      if (count > 1) this.conflicts.push(name);
    }
    if (Object.keys(this.conflicts).length > 0) this.isValid = false;else this.isValid = true;
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_0__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 864450:
/*!********************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/rules/import-solution.rule.ts ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImportSolutionRule": () => (/* binding */ ImportSolutionRule)
/* harmony export */ });
/* harmony import */ var _RuleResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RuleResult */ 326439);
/* harmony import */ var _SimpleRule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SimpleRule */ 701902);


class ImportSolutionRule extends _SimpleRule__WEBPACK_IMPORTED_MODULE_1__.SimpleRule {
  constructor(name, message, columnName, target, possibleValueList, isDisplayable) {
    super(name, message, isDisplayable);
    this.target = target;
    this.possibleValueList = possibleValueList;
    this.columnName = columnName;
  }
  render() {
    if (this.target === null || this.target === undefined) {
      this.isValid = true;
    } else {
      const matchedItem = this.possibleValueList.find(el => el.name.trim() === this.target['name'].trim());
      if (matchedItem) {
        delete this.target['error'];
        delete this.target['errorDetail'];
        this.target['id'] = matchedItem.id;
      } else {
        console.log(this.target['name'], this.possibleValueList);
        this.isValid = false;
        this.newName = this.target['name'];
        this.target['error'] = true;
        this.target['errorDetail'] = 'Cannot find this name';
      }
    }
    return new _RuleResult__WEBPACK_IMPORTED_MODULE_0__.RuleResult(this, this.target);
  }
}

/***/ }),

/***/ 227538:
/*!**********************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/validation/ValidationContext.ts ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValidationContext": () => (/* binding */ ValidationContext)
/* harmony export */ });
/* harmony import */ var _ValidationContextState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ValidationContextState */ 945143);

/**
 * Use this class to create a new Validation Context for your application. With this
 * context, you can add rules and evaluate the rules.
 *
 * After the rules are evaluated, you can use the Validation Context to determine if there are
 * any rule violations.
 */
class ValidationContext {
  /**
   * The constructor for the base validation context.
   */
  constructor(source) {
    /**
     * Use to indicate the state of the validation context.
     */
    this.state = _ValidationContextState__WEBPACK_IMPORTED_MODULE_0__.ValidationContextState.NotEvaluated;
    /**
     * A list of results for all evaluated rules that belong to the validation context.
     */
    this.results = new Array();
    /**
     * A list of rules for rendering.
     */
    this.rules = new Array();
    /**
     * The source of the specified validation context instance.
     */
    this.source = '';
    if (source) {
      this.source = source;
    } else {
      this.source = '';
    }
  }
  /**
   * Use this method to add a new rule to the ValidationContext.
   */
  addRule(rule) {
    if (this.source) {
      rule.source = this.source;
    }
    this.rules.push(rule);
    return this;
  }
  /**
   * Use this extension method to set the [Source] for the current validation context.
   * @param source
   */
  withSource(source) {
    this.source = source;
    return this;
  }
  /**
   * Use this method to execute the rules added to the [ValidationContext].
   */
  renderRules() {
    this.results = new Array();
    if (this.rules && this.rules.length < 1) {
      return this;
    }
    this.rules.sort(r => r.priority).forEach(r => this.results.push(r.execute()));
    return this;
  }
  /**
   * Use to determine if the validation context has any rule violations.
   */
  hasRuleViolations() {
    let hasViolations = false;
    if (this.rules) {
      const ruleViolationsCount = this.rules && this.rules.filter(r => r.isValid === false).length;
      if (ruleViolationsCount > 0) {
        hasViolations = true;
      }
    }
    return hasViolations;
  }
  /**
   * *Use to indicate if the validation context is valid - no rule violations.
   */
  get isValid() {
    let isRuleValid = true;
    if (this.rules) {
      const invalidRulesCount = this.rules.filter(r => r.isValid === false).length;
      if (invalidRulesCount > 0) {
        isRuleValid = false;
      }
    }
    return isRuleValid;
  }
}

/***/ }),

/***/ 945143:
/*!***************************************************************************************!*\
  !*** ./libs/business-logic/rules-engine/src/lib/validation/ValidationContextState.ts ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValidationContextState": () => (/* binding */ ValidationContextState)
/* harmony export */ });
/**
 * Use this enumeration to determine the state of the Validation Context.
 */
var ValidationContextState;
(function (ValidationContextState) {
  /**
   * Indicates that no rules have been evaluated by the validation context.
   */
  ValidationContextState["NotEvaluated"] = "NotEvaluated";
  /** Use to indicate that all rules evaluated without any violations. */
  ValidationContextState["Success"] = "Success";
  /** Use to indicate that one or more evaluated rules contain violations. */
  ValidationContextState["Failure"] = "Failure";
})(ValidationContextState || (ValidationContextState = {}));

/***/ }),

/***/ 653098:
/*!***************************************************!*\
  !*** ./node_modules/guid-typescript/dist/guid.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {



exports.__esModule = true;
var Guid = /** @class */function () {
  function Guid(guid) {
    if (!guid) {
      throw new TypeError("Invalid argument; `value` has no value.");
    }
    this.value = Guid.EMPTY;
    if (guid && Guid.isGuid(guid)) {
      this.value = guid;
    }
  }
  Guid.isGuid = function (guid) {
    var value = guid.toString();
    return guid && (guid instanceof Guid || Guid.validator.test(value));
  };
  Guid.create = function () {
    return new Guid([Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join("-"));
  };
  Guid.createEmpty = function () {
    return new Guid("emptyguid");
  };
  Guid.parse = function (guid) {
    return new Guid(guid);
  };
  Guid.raw = function () {
    return [Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join("-");
  };
  Guid.gen = function (count) {
    var out = "";
    for (var i = 0; i < count; i++) {
      // tslint:disable-next-line:no-bitwise
      out += ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
    }
    return out;
  };
  Guid.prototype.equals = function (other) {
    // Comparing string `value` against provided `guid` will auto-call
    // toString on `guid` for comparison
    return Guid.isGuid(other) && this.value === other.toString();
  };
  Guid.prototype.isEmpty = function () {
    return this.value === Guid.EMPTY;
  };
  Guid.prototype.toString = function () {
    return this.value;
  };
  Guid.prototype.toJSON = function () {
    return {
      value: this.value
    };
  };
  Guid.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i");
  Guid.EMPTY = "00000000-0000-0000-0000-000000000000";
  return Guid;
}();
exports.Guid = Guid;

/***/ })

}]);